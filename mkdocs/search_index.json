{
    "docs": [
        {
            "location": "/", 
            "text": "scuff-em\n documentation: Table of contents\n\n \n\n\n\n\nIf you find any inconsistencies or missing bits in the documentation, please\n  \nfile an issue on the \nscuff-em\n GitHub page\n.\n\n\nGeneral reference\n\n\n\n\nTop-level overview\n\n\nInstallation\n\n\nGeometry files\n\n\nMaterial descriptions\n\n\nGeometrical transformations\n\n\nIncident Fields\n\n\nBrillouin-zone integration\n\n\nFAQ\n\n\n\n\nTutorial Examples\n\n\nPhotonics, imaging\n\n\n\n\nMie scattering\n\n\nElectrostatics of a spherical dielectric shell\n\n\nLDOS and polarization-sensitive response in plasmonic bowtie antennas\n\n\nLDOS and dyadic Green functions above an infinite aluminum half-space\n\n\nSpatially-resolved study of plane-wave transmission through an infinite-area thin dielectric film\n\n\nPlane-wave transmission with rotation of polarization: Chiral metasurface rotator\n\n\nImaging diffraction patterns of discs, disc arrays, and hole arrays in metal screens\n\n\nImaging diffraction patterns of aperiodic arrays: Vogel spirals\n\n\n\n\nFluctuation-induced phenomena\n\n\n\n\nCasimir forces in a compact geometry\n\n\nCasimir forces in a 1D extended geometry\n\n\nCasimir forces in a 2D extended geometry\n\n\nThermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres\n\n\nSpatial distribution of heat flux from a warm tip over a cold substrate\n\n\n\n\nPure electrostatics\n\n\n\n\nElectrostatic polarizability of platonic solids\n\n\nCapacitance of two-body capacitors\n\n\nCapacitance of PCB stripline trace\n\n\nImplicit handling of multilayer dielectric substrates\n\n\nFinite-size effects in metal-on-substrate capacitors (with data fitting in \npython\n)\n\n\nElectrostatic fields of an electrode array\n\n\n\n\nBU Symposium on Open-Source CAD Tools for Photonic Design Modeling\n\n\n\n\nBU Symposium on Open-Source CAD tools: \nscuff-em\n for photonics\n\n\n\n\nCommand-line application reference\n\n\n\n\n\n\nGeneral reference for \nscuff-em\n command-line applications\n\n\n\n\n\n\nNanophotonics codes\n\n\n\n\nscuff-scatter\n: general-purpose electromagnetic scattering\n\n\nscuff-ldos\n                  - photonic \nl\nocal \nd\nensity \no\nf \ns\ntates\n\n\nscuff-transmission\n  - plane-wave transmission through 2D extended structures\n\n\nscuff-tmatrix\n            - T-matrices of arbitrary compact objects in the spherical-wave basis  \n\n\n\n\n\n\n\n\nEquilibrium Casimir codes\n\n\n\n\nscuff-cas3d\n   - Casimir energies, forces, and torques\n\n\nscuff-caspol\n - Casimir-Polder potentials\n\n\n\n\n\n\n\n\nNon-equilibrium Casimir/ heat-transfer code\n\n\n\n\nscuff-neq\n       - radiative heat transfer and non-equilibrium Casimir forces/torques\n\n\n\n\n\n\n\n\nRF / microwave engineering code\n\n\n\n\nscuff-rf\n         - multiport network parameters\n                                 (S- and impedance parameters),\n                                 and radiated fields, for passive RF\n                                 and microwave structures.\n\n\n\n\n\n\n\n\nElectrostatics code\n\n\n\n\nscuff-static\n - pure electrostatics problems:\n                                 capacitance matrices, DC polarizabilities,\n                                 electrostatic potentials and fields\n\n\n\n\n\n\n\n\nUtility codes\n\n\n\n\nscuff-analyze\n - diagnostic tool to print info on \nscuff-em\n geometries\n\n\nscuff-integrate\n - utility tool to integrate functions using samples tabulated in data files\n\n\n\n\n\n\n\n\nValidation Test Suite\n\n\n\n\nOverview of the \nscuff-em\n test suite\n\n\nMie scattering\n\n\nFresnel scattering\n\n\nEquilibrium Casimir forces between spheres\n\n\nEquilibrium Casimir forces between plates\n\n\nEquilibrium Casimir-Polder potential near a sphere\n\n\nEquilibrium Casimir-Polder potential near a plate\n\n\nHeat transfer and non-equilibrium Casimir forces between spheres\n\n\nLow-level tests of the \nscuff-em\n core library\n\n\n\n\nAPI reference\n\n\n\n\nlibscuff\n - Accessing \nscuff-em\n from C++ and python programs\n\n\n\n\nDeveloper reference\n\n\n\n\nImplementation\n        - how \nscuff-em\n works\n\n\nDataStructures\n        - data structures and methods inside the \nscuff-em\n core library\n\n\nDocumentation\n          - about the \nscuff-em\n documentation\n\n\nSingular integrals\n - \nscuff-em\n's code for computing singular triangle-product integrals\n\n\n\n\nFAQ\n\n\n\n\nFAQ\n - frequently asked questions about \nscuff-em\n\n\n\n\nTechnical memos\n\n\n\n\nlibscuff\n Implementation and Technical Details\n - a technical memo describing many details of the core library implementation\n\n\nComputation of power, force, and torque in \nscuff-em\n - a technical memo describing methods for computing power, force and torque, with applications to both classical scattering and non-equilibrium fluctuational electrodynamics\n\n\nComputation of fields near panels in \nscuff-em\n - a technical memo describing the computation of fields near triangular panels in discretized surface meshes\n\n\nComputation of Green's Functions and LDOS in \nscuff-em\n - a technical memo describing the implementation of the \nscuff-ldos\n code for computing dyadic Green's functions and local photonic densities of states\n\n\nComputation of reflection and transmission coefficients in \nscuff-em\n - a technical memo describing the implementation of the \nscuff-transmission\n code for computing plane-wave transmission and reflection coefficients\n\n\nscuff-static:\n Pure electrostatics in \nscuff-em\n -- a technical memo describing the implementation of the \nscuff-static\n code for electrostatics\n\n\nElectromagnetism in the vector-spherical-wave (VSW) basis\n -- a technical memo collecting results of various classical electromagnetism calculations in the vector-spherical-wave basis", 
            "title": "SCUFF-EM documentation"
        }, 
        {
            "location": "/#tutorial-examples", 
            "text": "", 
            "title": "Tutorial Examples"
        }, 
        {
            "location": "/#photonics-imaging", 
            "text": "Mie scattering  Electrostatics of a spherical dielectric shell  LDOS and polarization-sensitive response in plasmonic bowtie antennas  LDOS and dyadic Green functions above an infinite aluminum half-space  Spatially-resolved study of plane-wave transmission through an infinite-area thin dielectric film  Plane-wave transmission with rotation of polarization: Chiral metasurface rotator  Imaging diffraction patterns of discs, disc arrays, and hole arrays in metal screens  Imaging diffraction patterns of aperiodic arrays: Vogel spirals", 
            "title": "Photonics, imaging"
        }, 
        {
            "location": "/#fluctuation-induced-phenomena", 
            "text": "Casimir forces in a compact geometry  Casimir forces in a 1D extended geometry  Casimir forces in a 2D extended geometry  Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres  Spatial distribution of heat flux from a warm tip over a cold substrate", 
            "title": "Fluctuation-induced phenomena"
        }, 
        {
            "location": "/#pure-electrostatics", 
            "text": "Electrostatic polarizability of platonic solids  Capacitance of two-body capacitors  Capacitance of PCB stripline trace  Implicit handling of multilayer dielectric substrates  Finite-size effects in metal-on-substrate capacitors (with data fitting in  python )  Electrostatic fields of an electrode array", 
            "title": "Pure electrostatics"
        }, 
        {
            "location": "/#bu-symposium-on-open-source-cad-tools-for-photonic-design-modeling", 
            "text": "BU Symposium on Open-Source CAD tools:  scuff-em  for photonics", 
            "title": "BU Symposium on Open-Source CAD Tools for Photonic Design Modeling"
        }, 
        {
            "location": "/#command-line-application-reference", 
            "text": "General reference for  scuff-em  command-line applications    Nanophotonics codes   scuff-scatter : general-purpose electromagnetic scattering  scuff-ldos                   - photonic  l ocal  d ensity  o f  s tates  scuff-transmission   - plane-wave transmission through 2D extended structures  scuff-tmatrix             - T-matrices of arbitrary compact objects in the spherical-wave basis       Equilibrium Casimir codes   scuff-cas3d    - Casimir energies, forces, and torques  scuff-caspol  - Casimir-Polder potentials     Non-equilibrium Casimir/ heat-transfer code   scuff-neq        - radiative heat transfer and non-equilibrium Casimir forces/torques     RF / microwave engineering code   scuff-rf          - multiport network parameters\n                                 (S- and impedance parameters),\n                                 and radiated fields, for passive RF\n                                 and microwave structures.     Electrostatics code   scuff-static  - pure electrostatics problems:\n                                 capacitance matrices, DC polarizabilities,\n                                 electrostatic potentials and fields     Utility codes   scuff-analyze  - diagnostic tool to print info on  scuff-em  geometries  scuff-integrate  - utility tool to integrate functions using samples tabulated in data files", 
            "title": "Command-line application reference"
        }, 
        {
            "location": "/#validation-test-suite", 
            "text": "Overview of the  scuff-em  test suite  Mie scattering  Fresnel scattering  Equilibrium Casimir forces between spheres  Equilibrium Casimir forces between plates  Equilibrium Casimir-Polder potential near a sphere  Equilibrium Casimir-Polder potential near a plate  Heat transfer and non-equilibrium Casimir forces between spheres  Low-level tests of the  scuff-em  core library", 
            "title": "Validation Test Suite"
        }, 
        {
            "location": "/#api-reference", 
            "text": "libscuff  - Accessing  scuff-em  from C++ and python programs", 
            "title": "API reference"
        }, 
        {
            "location": "/#developer-reference", 
            "text": "Implementation         - how  scuff-em  works  DataStructures         - data structures and methods inside the  scuff-em  core library  Documentation           - about the  scuff-em  documentation  Singular integrals  -  scuff-em 's code for computing singular triangle-product integrals", 
            "title": "Developer reference"
        }, 
        {
            "location": "/#faq", 
            "text": "FAQ  - frequently asked questions about  scuff-em", 
            "title": "FAQ"
        }, 
        {
            "location": "/#technical-memos", 
            "text": "libscuff  Implementation and Technical Details  - a technical memo describing many details of the core library implementation  Computation of power, force, and torque in  scuff-em  - a technical memo describing methods for computing power, force and torque, with applications to both classical scattering and non-equilibrium fluctuational electrodynamics  Computation of fields near panels in  scuff-em  - a technical memo describing the computation of fields near triangular panels in discretized surface meshes  Computation of Green's Functions and LDOS in  scuff-em  - a technical memo describing the implementation of the  scuff-ldos  code for computing dyadic Green's functions and local photonic densities of states  Computation of reflection and transmission coefficients in  scuff-em  - a technical memo describing the implementation of the  scuff-transmission  code for computing plane-wave transmission and reflection coefficients  scuff-static:  Pure electrostatics in  scuff-em  -- a technical memo describing the implementation of the  scuff-static  code for electrostatics  Electromagnetism in the vector-spherical-wave (VSW) basis  -- a technical memo collecting results of various classical electromagnetism calculations in the vector-spherical-wave basis", 
            "title": "Technical memos"
        }, 
        {
            "location": "/examples/MieScattering/MieScattering/", 
            "text": "Plane-wave scattering from a dielectric sphere (Mie scattering)\n\n\nWe first demonstrate how to use \nscuff-scatter\n to solve the canonical textbook \nproblem of \nMie scattering\n -- the scattering of a plane wave from a dielectric \nsphere. The files for this example are in \nthe \nshare/scuff-em/examples/SolidSphere\n subdirectory of the \nscuff-em\n\nsource distribution.\n\n\nWe begin by creating a \ngmsh\n geometry file for the \nsphere \n(\nSphere.geo\n)\n. We turn this geometry file into a mesh \nfile by running the following command:\n\n\n % gmsh -2 -clscale 1.0 Sphere.geo\n\n\n\n\nThis produces a file named \nSphere.msh\n which looks like this:\n\n\n\n\nYou can adjust the fineness of the surface mesh by varying the \n-clscale\n parameter \n(which stands for \"characteristic length scale\"); finer meshes will be more accurate \nbut will take longer to simulate.\n\n\nNext we create a \nscuff-em\n geometry file\n\nthat will tell \nscuff-scatter\n about our geometry, including both the surface mesh \nand the material properties (dielectric function) of the sphere. As a first example, \nwe'll use a dielectric model for silicon carbide that expresses the relative \npermittivity as a rational function of \u03c9; in this case we'll call the geometry \nfile \nSiCSphere.scuffgeo.\n\n\nMATERIAL SiliconCarbide\n\n   EpsInf = 6.7;\n   a0     = -3.32377e28;\n   a1     = +8.93329e11;\n   b0     = -2.21677e28;\n   b1     = 8.93329e11;\n   Eps(w) = EpsInf * (a0 + i*a1*w + w*w) / ( b0 + i*b1*w + w*w);\n\nENDMATERIAL \n\nOBJECT TheSphere\n        MESHFILE Sphere.msh\n        MATERIAL SiliconCarbide\nENDOBJECT\n\n\n\n\nWe create a simple file called \nOmegaValues.dat\n containing a \nlist of angular frequencies at which to run the scattering problem:\n\n\n    0.010\n    0.013\n    ...\n    10.0\n\n\n\n\n(We pause to note one subtlety here: Angular frequencies specified \nusing the \n--Omega\n or \n--OmegaFile\n arguments are interpreted in \nunits of \nc / 1 \\mu\nm = \n3\\cdot 10^{14}\n rad/sec.\nThese are natural \nfrequency units to use for problems involving micron-sized objects; \nin particular, for Mie scattering from a sphere of radius 1 \u03bcm, as \nwe are considering here, the numerical value of \nOmega\n is just the \nquantity \nkR\n (wavenumber times radius) known as the \n\"size parameter\" in the Mie scattering literature. In contrast, \nwhen specifying functions of angular frequency like \nEps(w)\n in \n\nMATERIAL...ENDMATERIAL\n sections of geometry files or in any other \n\nscuff-em\n material description\n, \nthe \nw\n variable \nis always interpreted in units of \n1 \nrad/sec\n, because these are \nthe units in which tabulated material properties and functional forms \nfor model dielectric functions are typically expressed.)\n\n\nFinally, we'll create a little text file called \nArgs\n that will contain \na list of command-line options for \nscuff-scatter\n; these will include \n\n(1)\n a specification of the geometry, \n(2)\n the frequency list, \n\n(3)\n the name of an output file for the power, force, and torque \n\n(4)\n the name of a cache file for geometric data (this file doesn't \nexist yet, but will be created by our first run of \nscuff-scatter\n), \nand \n(5)\n a specification of the incident field.\n\n\n    geometry SiCSphere.scuffgeo\n    OmegaFile OmegaValues.dat\n    PFTFile SiCSphere.PFT\n    Cache Sphere.cache\n    pwDirection 0 0 1\n    pwPolarization 1 0 0\n\n\n\n\n\nAnd now we just pipe this little file into the standard input of \n\nscuff-scatter\n:\n\n\n    % scuff-scatter \n Args \n\n\n\n\nThis produces the file \nSiCSphere.PFT\n, which contains one line per simulated \nfrequency; each line contains data on the scattered and total power, the force, \nand the torque on the particle at that frequency. (Look at the first few lines\nof the file for a text description of how to interpret it.)\n\n\n(On my fairly standard workstation (8 Xeon E5420 cores, 2.5 GHz), this calculation \ntakes a few minutes to run. You can monitor its progress by following the \nscuff-scatter.log\n \nfile. Note that, during computationally-intensive operations such as the BEM matrix assembly, \nthe code should be using all available CPU cores on your workstation; if you find that this is \nnot the case (for example, by monitoring CPU usage using \n\nhtop\n) \nyou may need to \n[reconfigure and recompile with different openmp/pthreads configuration options.][scuffEMInstallation.shtml]\n\n\nHere's a comparison of the \nscuff-scatter\n results with the analytical Mie series, as computed \nusing \nthis Mathematica script.\n [Like most Mie codes, this script computes the \nabsorption and scattering \ncross-sections\n, which we multiply by the incoming beam flux (\n\\frac{1}{2Z_0}\n for a unit-strength plane wave in vacuum) to get \nvalues for the absorbed and scattered \npower\n.]\n\n\n\n\nNow let's redo the calculation for a sphere made of gold instead of silicon carbide.  In this case we will name our \nscuff-em\n geometry file \nGoldSphere.scuffgeo\n:\n\n\n    MATERIAL Gold\n      wp = 1.37e16;\n      gamma = 5.32e13;\n      Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\n    ENDMATERIAL\n\n    OBJECT TheSphere\n        MESHFILE Sphere.msh\n        MATERIAL Gold\n    ENDOBJECT\n\n\n\n\n\nSince most of the command-line arguments to \nscuff-scatter\n will be the same as before, \nwe can reuse the same \nArgs\n file, with the options that need to be given new values \nspecified on the command line:\n\n\n% scuff-scatter --geometry GoldSphere.scuffgeo --PFTFile GoldSphere.PFT \n Args\n\n\n\n\n\n(Note that we don't have to change the name of the cache file specified with the \nCache\n \noption; because we are using the same surface mesh as before, and because \n\ncached geometric data in \nscuff-em\n are independent of material properties\n, \nwe can take advantage of geometric data computed during the earlier run for the silicon carbide sphere.)\n\n\nNow our data look like this:\n\n\n\n\nIn some cases it's useful to look at how the induced surface currents vary over the surface of the object. \nLet's re-run the SiC example, now at just the single angular frequency of \u03c9=0.1, and ask for a surface current plot.\n\n\n% scuff-scatter --geometry SiCSphere.scuffgeo --Omega 0.1 --Cache Sphere.cache --pwDirection 0 0 1 --pwPolarization 1 0 0 --PlotSurfaceCurrents\n\n\n\n\nThis produces a file named \nSiCSphere.0.1.pp\n, which we can open in gmsh like this:\n\n\n % gmsh SiCSphere.0.1.pp", 
            "title": "Mie scattering"
        }, 
        {
            "location": "/examples/DielectricShell/DielectricShell/", 
            "text": "Electrostatics of a spherical dielectric shell\n\n\nFor our next trick, we'll consider a spherical shell of dielectric material illuminated \nby a plane wave of such low frequency that we may think of the incident field as a \nspatially constant DC electric field. In this case it is easy to obtain an \n\nexact analytical solution of the scattering problem,\n \nwhich we will reproduce numerically using \nscuff-scatter\n. We will take the outer and \ninner radii to be \nR\nout\n=1\n and \nR\nin\n=0.5.\n The files for this example \nare in the \nshare/scuff-em/examples/SphericalShell\n subdirectory of the \nscuff-em\n \nsource distribution.\n\n\nTo represent a spherical shell in \nscuff-em\n, we need two surface meshes, one each for \nthe inner and outer spherical surfaces. These are described by \ngmsh\n mesh files \n\nSphere_R1P0.msh\n and \nSphere_R0P5.msh\n We describe the shell as an inner vacuum sphere \nembedded in the outer sphere; the geometry file for this situation is \n\nSphericalShell.scuffgeo:\n\n\n OBJECT OuterSphere \n     MESHFILE Sphere_R1P0.msh\n     MATERIAL CONST_EPS_10\n ENDOBJECT \n\n OBJECT InnerSphere \n     MESHFILE Sphere_R0P5.msh\n     MATERIAL Vacuum\n ENDOBJECT \n\n\n\n\n\n\nWe will run two separate calculations. First, we will fix the relative permittivity \nof the shell at \u03b5\nr\n=10 and look at the \nz\n component of the electric field \nat points on the \nz\n axis ranging from the origin (the center of the concentric spheres) \nto the exterior medium. We create a file called \nLineOfPoints\n which \nlists the Cartesian coordinates of each evaluation point:\n\n\n      0.0 0.0 0.000\n      0.0 0.0 0.025\n      0.0 0.0 0.050\n      ...\n      0.0 0.0 2.000\n\n\n\n\nWe will pass this file to \nscuff-scatter\n using the \n--EPFile\n option:\n\n\n     % scuff-scatter --EPFile LineOfPoints \n Args\n\n\n\n\nwhere the \nArgs\n file looks like this:\n\n\n      geometry       SphericalShell.scuffgeo\n      cache          SphericalShell.cache\n      omega          0.001\n      pwDirection    1.0 0.0 0.0\n      pwPolarization 0.0 0.0 1.0\n\n\n\n\nNote that we choose a frequency low enough to ensure we are well within the \nelectrostatic limit, and that the constant \nz\n-directed electrostatic field \ndescribed in the memo above becomes a linearly polarized plane wave traveling \nin the \nx-\n direction.\n\n\nThis run of the code produces files \nSphericalShell.scattered\n and \nSphericalShell.total\n. \nPlotting the 8th vs. the 3rd column of the latter file (look at the first few lines\nof the file for a description of which column is which) yields plot \nof the real part of \nE\nz\n vs. \nz\n and \nyields good agreement with the analytical calculation, \nmodulo some funkiness at points on or near the boundary surfaces which is to be \nexpected in an SIE/BEM calculation:\n\n\n\n\nNext, we will vary the shell permittivity and look at the electric field \nat the center of the shell. In this case the \n\nanalytical solution\n\nmakes the interesting prediction\n\n\n\n\nwhich we will try to verify numerically.\n\n\nThis calculation is slightly trickier than the last one, because \nscuff-scatter\n doesn't offer \ncommand-line options for varying the dielectric constant of an object. One way around this is to \nuse the python interface to \nscuff-em\n, as discussed \n\non this page\n.\nHere we will pursue a different solution involving a shell script that modifies \nthe \n.scuffgeo\n file for each different value of \u03b5 we want to simulate. That script \nlooks like this:\n\n\n#!/bin/bash\n\ncat EpsValues | while read EPS\ndo\n\n  # copy the .scuffgeo file with EPS_10 replaced by EPS_xx\n  sed \ns/EPS_10/EPS_${EPS}/\n SphericalShell.scuffgeo \n temp.scuffgeo\n\n  # run scuff-scatter to get E-field at origin\n  /bin/rm -f CenterPoint.total\n  /bin/rm -f CenterPoint.scattered\n  scuff-scatter --geometry temp.scuffgeo --EPFile CenterPoint \n Args\n\n  # extract the z-component of the field from the output file\n  EZ=`awk '{print $8}' CenterPoint.total`\n  echo \n${EPS} ${EZ}\n \n EzVsEps.dat\n\ndone\n\n\n\n\n(Here \nEpsValues\n is a file containing the values of \u03b5 \nthat we want to simulate, and \nCenterPoint\n is a file containing \njust the first line of the file \nLineOfPoints\n for the cartesian \ncoordinates of the origin.)\n\n\nThe result of the calculation looks like this:", 
            "title": "Electrostatics of a spherical dielectric shell"
        }, 
        {
            "location": "/examples/ThinFilm/ThinFilm/", 
            "text": "Spatially-resolved study of plane-wave transmission through an (infinite-area) thin dielectric film\n\n\nThe previous examples dealt with \ncompact\n scatterers. We'll next consider an \n\nextended\n geometry -- namely, a thin dielectric film of \nfinite thickness in the \nz\n direction but infinite extent in the \nx\n and \ny\n \ndirections. This is the same geometry for which we used \nscuff-transmission\n \nto look at the plane-wave transmission and reflection coefficients as a function \nof frequency in \nthis example\n,\nbut here we'll do a different calculation -- namely, we'll pick a single \nfrequency and look at how the electric and magnetic fields vary in space, \nboth inside and outside the thin film. (The files for this example may be \nfound in the \nshare/scuff-em/examples/ThinFilm\n directory of your \nscuff-em\n\ninstallation.)\n\n\nThe mesh file and \n.scuffgeo\n file for this geometry are discussed in the \n\ndocumentation for \nscuff-transmission\n.\nThe geometry consists of a film of thickness \nT\n=1\u03bcm, with relative dielectric \nconstant \n\\epsilon^r=100\n, illuminated from below by a plane wave at normal \nincidence. (We'll take the incident field to be linearly polarized with \nE\n field \npointing in the \nx\n direction.) The lower and upper surfaces of the film are at \n\nz=0\n and \nz=T.\n For this geometry it is easy to solve Maxwell's equation directly \nto obtain the \nE\n and \nH\n fields directly at points below, within, and above \nthe film:\n\n\n\n\nWe will try to reproduce this behavior using \n\nscuff-scatter\n. \n\n\nFirst create a little text file \n(\nThinFilm.EvalPoints\n) containing the \ncoordinates of a bunch of points on a straight line passing \nfrom below the film to above the film. Then put the following \ncommand-line arguments into a file called \nThinFilm_58.args:\n\n\n geometry ThinFilm_58.scuffgeo\n cache ThinFilm_58.scuffcache\n omega 1.0\n EPFile ThinFilm.EvalPoints\n pwDirection 0 0 1\n pwPolarization 1 0 0\n\n\n\n\nand pipe it into \nscuff-scatter\n:\n\n\n scuff-scatter \n scuff-scatter.args\n\n\n\n\nThis produces files named \nThinFilm.scattered\n and \n\nThinFilm.total\n. Looking at the first few lines of these\nfiles, we see that the 3rd data column on each line is \nthe \nz\n coordinate of the evaluation point, the 4th column\nis the real part of \nE_x\n, and the 12th column is \nthe real part of \nH_x\n. Thus, plotting the 4th vs. 3rd\nand 12th vs. 3rd columns of the \n.total\n file yields plots of\nthe total \nelectric and magnetic field vs. \nz\n, whereupon we find good\nagreement with theory:", 
            "title": "Spatially-resolved study of plane-wave transmission through an infinite-area thin dielectric film"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/", 
            "text": "Diffraction patterns for discs, disc arrays, and hole arrays in metal screens\n\n\nIn this example, we shine a laser beam (or a plane wave) on an \n(infinite-area) metal screen perforated by a square-lattice\narray of circular holes, and produce images of the diffraction \npatterns as observed on a visualization surface located behind the \nperforated screen. Here's a schematic depiction of the configuration:\n\n\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/DiffractionPatterns\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file and surface mesh for the screen unit cell\n\n\nThe \ngmsh\n geometry file \nHoleyScreenUnitCell.geo\n\ndescribes an (infinitely thin) square metallic screen, \nof dimensions 1\nm \n 1\nm, with a hole of radius 0.25 \nm\ncentered at the center of the square. I produce coarser and \nfiner surface meshes for this geometry by saying\n\n\n% gmsh -2 -clscale 1 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh\n% gmsh -2 -clscale 0.75 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh\n\n\n\n\n(where \nRenameMesh\n is a simple \n\nbash\n script that uses \nscuff-analyze\n to count the number \nof interior edges in a surface mesh and rename the mesh file \naccordingly.)\nThis produces the files \nHoleyScrenUnitCell_1228.msh\n\nand \nHoleyScreenUnitCell_2318.msh,\n\nwhich you can visualize by opening in \ngmsh\n::\n\n\n% gmsh HoleyScreenUnitCell_1228.msh\n% gmsh HoleyScreenUnitCell_2318.msh\n\n\n\n\n\n\n\n\nNote that finer meshing resolution is obtained by specifying\nthe \n-clscale\n argument to \ngmsh\n (it stands\nfor \"characteristic length scale\"), which specifies an overall\nscaling factor for all triangle edges.\n\n\n\n\nscuff-em\n geometry files\n\n\nThe \nscuff-em\n geometry files\n\nHoleyScreen_1228.scuffgeo\n\nand\n\nHoleyScreen_2318.scuffgeo\n\ndescribe infinite square lattices with unit\ncells defined by the unit-cell meshes we created\nabove. The \nN\n=1228 guy looks like this:\n\n\nLATTICE\n        VECTOR 1 0\n        VECTOR 0 1\nENDLATTICE    \n\nOBJECT HoleyScreen\n        MESHFILE HoleyScreenUnitCell_1228.msh\nENDOBJECT\n\n\n\n\nNote that we don't have to specify a \nMATERIAL\n\nfor the screen, since PEC is the default.\n\n\nWe can use \nscuff-analyze\n to produce an image\nof what the full geometry looks like, including\nthe lattice repetitions:\n\n\n% scuff-analyze --geometry HoleyScreen_1228.scuffgeo --WriteGMSHFiles --Neighbors 2\n\n\n\n\nThis produces the file \nHoleyScreen_1228.pp\n, which you \ncan view by opening it in \ngmsh\n:\n\n\n% gmsh HoleyScreen_1228.pp\n\n\n\n\n\n\n\n\nField visualization mesh\n\n\nThe next step is to create a meshed representation of the\nsurface on which we will visualize the diffraction patterns.\nHere's a \ngmsh\n file called\n\nFVMesh.geo\n that describes a square of\nside length 1 micron, parallel to the \nxy\n plane and\nlocated at a height of \nz\n=1 micron, thus corresponding\nto the region enclosed by the dotted line in the schematic\nfigure above. (\"FVMesh\" stands for \"field-visualization\nmesh.\") This \n.geo\n file contains a user-specifiable\nparameter \nN\n that sets the number of triangle edges per\nunit length in the mesh representation; I would\nlike to set this number to 50, so I say\n\n\n% gmsh -2 -setnumber N 50 FVMesh.geo -o FVMesh.msh\n% RenameMesh FVMesh.msh\n\n\n\n\nThis produces the file \nFVMesh_7400.msh\n:\n\n\n\n\n\n\nRunning \nscuff-scatter\n\n\nNow all that's left is to run the calculation.\nPut the following content into a little text\nfile called \nscuff-scatter.args\n and pipe it into\nthe standard input of \nscuff-scatter\n:\n\n\ngeometry        HoleyScreen_1228.scuffgeo\nFVMesh          FVMesh_7400.msh\nLambda          0.3751\nLambda          0.2501\nLambda          0.1251\npwDirection     0 0 1\npwPolarization  1 0 0 \n\n\n\n\nNote that I have chosen wavelengths of \n\n\\lambda=\\{1.5,1.0,0.5\\}R\n where \nR=0.25\\,\\mu\nm is \nthe hole radius. In each case I have shifted the wavelength by a \ntiny amount away from being commensurate with the lattice period\nto avoid numerical instabilities associated with Wood anomalies.\n\n\n % scuff-scatter \n scuff-scatter.args\n % scuff-scatter --geometry HoleyScreen_2318.scuffgeo \n scuff-scatter.args\n\n\n\n\nIn the second command line here, the command-line specified \ngeometry overrides the geometry in the \n.args\n file. \n\n\nThis produces the files \nHoleyScreen_1228.FVMesh_7400.pp\n\nand \nHoleyScreen_2318.FVMesh_7400.pp\n, which can be\nvisualized by opening them in \ngmsh\n.\n\n\n\n \n\n  \n \n\n  \n \n\n \n\n \n\n  \n \n=1.5 R (coarse mesh)\n  \n \n=1.5 R (fine mesh)\n \n\n \n\n  \n \n\n  \n \n\n \n\n \n\n  \n \n=1.0 R (coarse mesh)\n  \n \n=1.0 R (fine mesh)\n \n\n \n\n  \n \n\n  \n \n\n \n\n \n\n  \n \n=0.5 R (coarse mesh)\n  \n \n=0.5 R (fine mesh)", 
            "title": "Imaging diffraction patterns of discs, disc arrays, and hole arrays in metal screens"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#gmsh-geometry-file-and-surface-mesh-for-the-screen-unit-cell", 
            "text": "The  gmsh  geometry file  HoleyScreenUnitCell.geo \ndescribes an (infinitely thin) square metallic screen, \nof dimensions 1 m   1 m, with a hole of radius 0.25  m\ncentered at the center of the square. I produce coarser and \nfiner surface meshes for this geometry by saying  % gmsh -2 -clscale 1 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh\n% gmsh -2 -clscale 0.75 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh  (where  RenameMesh  is a simple  bash  script that uses  scuff-analyze  to count the number \nof interior edges in a surface mesh and rename the mesh file \naccordingly.)\nThis produces the files  HoleyScrenUnitCell_1228.msh \nand  HoleyScreenUnitCell_2318.msh, \nwhich you can visualize by opening in  gmsh ::  % gmsh HoleyScreenUnitCell_1228.msh\n% gmsh HoleyScreenUnitCell_2318.msh    Note that finer meshing resolution is obtained by specifying\nthe  -clscale  argument to  gmsh  (it stands\nfor \"characteristic length scale\"), which specifies an overall\nscaling factor for all triangle edges.", 
            "title": "gmsh geometry file and surface mesh for the screen unit cell"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#scuff-em-geometry-files", 
            "text": "The  scuff-em  geometry files HoleyScreen_1228.scuffgeo \nand HoleyScreen_2318.scuffgeo \ndescribe infinite square lattices with unit\ncells defined by the unit-cell meshes we created\nabove. The  N =1228 guy looks like this:  LATTICE\n        VECTOR 1 0\n        VECTOR 0 1\nENDLATTICE    \n\nOBJECT HoleyScreen\n        MESHFILE HoleyScreenUnitCell_1228.msh\nENDOBJECT  Note that we don't have to specify a  MATERIAL \nfor the screen, since PEC is the default.  We can use  scuff-analyze  to produce an image\nof what the full geometry looks like, including\nthe lattice repetitions:  % scuff-analyze --geometry HoleyScreen_1228.scuffgeo --WriteGMSHFiles --Neighbors 2  This produces the file  HoleyScreen_1228.pp , which you \ncan view by opening it in  gmsh :  % gmsh HoleyScreen_1228.pp", 
            "title": "scuff-em geometry files"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#field-visualization-mesh", 
            "text": "The next step is to create a meshed representation of the\nsurface on which we will visualize the diffraction patterns.\nHere's a  gmsh  file called FVMesh.geo  that describes a square of\nside length 1 micron, parallel to the  xy  plane and\nlocated at a height of  z =1 micron, thus corresponding\nto the region enclosed by the dotted line in the schematic\nfigure above. (\"FVMesh\" stands for \"field-visualization\nmesh.\") This  .geo  file contains a user-specifiable\nparameter  N  that sets the number of triangle edges per\nunit length in the mesh representation; I would\nlike to set this number to 50, so I say  % gmsh -2 -setnumber N 50 FVMesh.geo -o FVMesh.msh\n% RenameMesh FVMesh.msh  This produces the file  FVMesh_7400.msh :", 
            "title": "Field visualization mesh"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#running-scuff-scatter", 
            "text": "Now all that's left is to run the calculation.\nPut the following content into a little text\nfile called  scuff-scatter.args  and pipe it into\nthe standard input of  scuff-scatter :  geometry        HoleyScreen_1228.scuffgeo\nFVMesh          FVMesh_7400.msh\nLambda          0.3751\nLambda          0.2501\nLambda          0.1251\npwDirection     0 0 1\npwPolarization  1 0 0   Note that I have chosen wavelengths of  \\lambda=\\{1.5,1.0,0.5\\}R  where  R=0.25\\,\\mu m is \nthe hole radius. In each case I have shifted the wavelength by a \ntiny amount away from being commensurate with the lattice period\nto avoid numerical instabilities associated with Wood anomalies.   % scuff-scatter   scuff-scatter.args\n % scuff-scatter --geometry HoleyScreen_2318.scuffgeo   scuff-scatter.args  In the second command line here, the command-line specified \ngeometry overrides the geometry in the  .args  file.   This produces the files  HoleyScreen_1228.FVMesh_7400.pp \nand  HoleyScreen_2318.FVMesh_7400.pp , which can be\nvisualized by opening them in  gmsh .  \n  \n     \n     \n  \n  \n     =1.5 R (coarse mesh)\n     =1.5 R (fine mesh)\n  \n  \n     \n     \n  \n  \n     =1.0 R (coarse mesh)\n     =1.0 R (fine mesh)\n  \n  \n     \n     \n  \n  \n     =0.5 R (coarse mesh)\n     =0.5 R (fine mesh)", 
            "title": "Running scuff-scatter"
        }, 
        {
            "location": "/examples/CubeTorus/", 
            "text": "Casimir forces between compact objects: A cube--torus geometry\n\n\nThis section of the \nscuff-em\n documentation has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of this section of the documentation.", 
            "title": "Casimir forces in a compact geometry"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/", 
            "text": "Casimir forces between infinitely extended silicon beams (1D periodicity)\n\n\n\nIn this example, we exploit \nscuff-em\n's \nsupport for 1D periodic geometries\nto compute the equilibrium Casimir force per unit length \nbetween infinitely extended silicon beams of \nrounded rectangular cross section.\nThe files for this example may be found in the\n\nshare/scuff-em/examples/SiliconBeams\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file for unit-cell geometry\n\n\nThe \ngmsh\n geometry file \n\nRoundedBeamUnitCell.geo\n\ndescribes the portion of the surface of a single\nbeam that lies within the \nunit cell,\n\ni.e. the cell that is infinitely periodically\nreplicated to yield the full geometry.\nTo produce a discretized surface-mesh\nrepresentation of this geometry, we run it through \n\ngmsh\n:\n\n\n% gmsh -2 RoundedBeamUnitCell.geo\n\n\n\n\nThis produces the file \nRoundedBeamUnitCell.msh\n, which\nI rename to \nRoundedBeamUnitCell_192.msh\n because 192\nis the number of interior edges (this information may be \nfound, for example, by running \n\nscuff-analyze --mesh RoundedBeamUnitCell.msh\n).\nYou can open the \n.msh\n file in \ngmsh\n to visualize\nthe unit-cell mesh:\n\n\n% gmsh RoundedBeamUnitCell_192.msh\n\n\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 1D periodic geometries in \nscuff-em\n, the direction\n   of infinite extent must be the \nx\n direction.\n\n\n\n\n\n\nOnly the sidewall of the cylinder is meshed;\n   the endcaps must not be meshed.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on the unit-cell boundary must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nIn this case the unit cell is 1 \n\\mu\nm long.\n   (More generally, the unit cell could have any \n   length you like.)\n\n\n\n\n\n\n\n\nscuff-em\n geometry file\n\n\nThe \nscuff-em\n \n\ngeometry file\n \ndescribing our two infinite-length silicon beams is\n\nSiliconBeams_192.scuffgeo\n.\nThis specifies a geometry consisting of two identical\nsilicon beams, of infinite extent in the \nx\n direction,\nseparated by a distance of 2 \n\\mu\nm in the \nz\n direction.\nThe infinite beams consist of the finite-length unit-cell\ngeometry, periodically replicated infinitely many times.\n(The length of the lattice vector specified by the \nLATTICE\n\nstatement should agree with the length of the unit cell as \ndefined in the \ngmsh\n geometry file.)\n\n\nLATTICE\n    VECTOR 1.0 0.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT Beam1\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\nENDOBJECT\n\nOBJECT Beam2\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\n    DISPLACED 0 0 2\nENDOBJECT\n\n\n\n\nWe can use \nscuff-analyze\n to visualize the geometry \ndescribed by this \n.scuffgeo\n file:\n\n\n% scuff-analyze --geometry SiliconBeams_192.scuffgeo --WriteGMSHFiles --Neighbors 2\n\n\n\n\n[The option \n--Neighbors 2\n requests that, in addition to the unit-cell\ngeometry, the first 2 periodic images of the unit cell \nin both the \npositive and negative directions\n (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file \nSiliconBeams_192.pp\n, which you \ncan view in \ngmsh\n:\n\n\n% gmsh SiliconBeams_192.pp\n\n\n\n\n\n\nNote that the visualization file produced by \nscuff-analyze\n includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called \nstraddlers\n,\nand they are added automatically by \nscuff-em\n to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.\n\n\n\n\nscuff-em\n transformation file\n\n\nIn Casimir problems we typically want to compute\nforces (or torques, or energies) at multiple\nvalues of the surface--surface separation.\nThis is done by writing a \n\ntransformation file\n.\nIn this case we'll request the Casimir force between\nthe beams for 9 distinct values of the surface-surface\nseparation ranging between 1-5\n\\mu\nm.\nThe file that specifies this is called\n\nBeams.trans\n:\n\n\nTRANS 1.00 OBJECT Beam2 DISP 0 0 0.00\nTRANS 1.50 OBJECT Beam2 DISP 0 0 0.50\nTRANS 2.00 OBJECT Beam2 DISP 0 0 1.00\nTRANS 2.50 OBJECT Beam2 DISP 0 0 1.50\nTRANS 3.00 OBJECT Beam2 DISP 0 0 2.00\nTRANS 3.50 OBJECT Beam2 DISP 0 0 2.50\nTRANS 4.00 OBJECT Beam2 DISP 0 0 3.00\nTRANS 4.50 OBJECT Beam2 DISP 0 0 3.50\nTRANS 5.00 OBJECT Beam2 DISP 0 0 4.00\n\n\n\n\nFor full details on \nscuff-em\n\ntransformation files, see \n\nthis reference page\n.\nFor the time being, note the following:\n\n\n\n\n\n\nThe text \nTRANS 4.00\n specifies the string \n4.00\n\n   as the \nname\n of this transformation. This is the string\n   that will be written to output files to identify\n   the Casimir quantities corresponding to each \n   geometrical transformation. This can be any \n   string not including spaces (in particular, it \n   need not be a number), but it's usually convenient\n   to label transformations by numbers so that we can \n   subsequently plot e.g. force vs. distance.\n\n\n\n\n\n\nThe text \nOBJECT Beam2 DISP 0 0 3.00\n specifies \n   that, in this particular geometrical transformation,\n   the object labeled \nBeam2\n in the \n.scuffgeo\n file \n   is to be displaced 3 \n\\mu\nm in the \nz\n direction.\n\n\n\n\n\n\nWhy do we assign the label \n4.00\n to a transformation\n   in which the displacement is 3 \n\\mu\nm? Because \n   transformations are \nrelative\n to the configuration\n   described in the \n.scuffgeo\n file, and in the \n   \n.scuffgeo\n file discussed above the second beam\n   is already displaced a distance of 2 \n\\mu\nm from\n   the first beam, which means the default\n   surface-surface separation is 1 \n\\mu\nm.\n   Applying an addition 3 \n\\mu\nm displacement then\n   yields a surface-surface separation of 4 \n\\mu\nm.\n\n\n\n\n\n\nYou can use \nscuff-analyze\n to obtain a \nvisualization of what your geometry looks \nlike under each transformation:\n\n\n% scuff-analyze --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans\n\n\n\n\nThis produces a file named \nSiliconBeams_192.transformed.pp\n, which\nyou can open in \ngmsh\n to confirm that the transformations you\ngot are the ones you wanted.\n\n\n\n\nA first trial run of \nscuff-cas3d\n at a single frequency\n\n\nTo compute the full Casimir force per unit length\nbetween the beams (call this quantity \n\\mathcal F\n), \n\nscuff-cas3d\n numerically evaluates an\nintegral over both imaginary frequencies \n\\xi\n and Bloch \nwavenumbers \nk\n:\n\n \\mathcal F \n  = \\int_0^\\infty d\\xi\n           \\underbrace{\\left [ \\frac{1}{V_{\\scriptsize{BZ}}}\n                                \\int_{V_{\\scriptsize{BZ}}}\n                                f(\\xi, k) dk \\,\n                       \\right]\n                      }_{\\equiv F(\\xi)}\n\n\nwhere the \nk\n integral is over the Brillouin zone (BZ)\nand \nV_{\\scriptsize{BZ}}\n is the one-dimensional volume \nof the BZ. For a 1D periodic geometry, the Brillouin \nzone is the 1D interval \n0\\le k \\le \\frac{2\\pi}{L}\n,\nand its one-dimensional volume (its length) is \n\\frac{2\\pi}{L}\n,\nwhere \nL=1\\, \\mu\nm is the length of the real-space unit cell.\n,\nBecause the full calculation can be somewhat time-consuming,\nit's often useful to run a quick \nsingle-frequency\n\ncalculation just to make sure things are making sense\nbefore launching the full run. We do this by \nspecifying the \n--Xi\n command-line option to\n\nscuff-cas3d\n, which requests a calculation\nof just the quantity \nF(\\xi)\n in the above\nequation at a single imaginary frequency \n\\xi\n.\n(Note that, for our 1D periodic geometry,\nthis single-frequency calculation still entails a \nwavenumber integration over the 1D Brillouin zone.)\n\n\n % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce --xi 0.7\n\n\n\n\nThis produces (among other files) files called \n\nSiliconBeams_192.byXi\n\nand \n\nSiliconBeams_192.byXikBloch.\n\nThe former file reports values of the quantity \nF(\\xi)\n,\nat the requested value of \n\\xi\n, for each of the\ntransformations in the \n.trans\n file. The latter\nfile gives more granular information: it reports \nvalues of the quantity \nf(\\xi,k)\n at the requested \nvalue of \n\\xi\n and at each \nk\n point sampled by \nthe built-in numerical integrator.\n\n\nThe file \nSiliconBeams_192.byXi\n looks like this:\n\n\n# scuff-cas3D run on superhr1 at 06/07/15::01:01:38\n# data file columns: \n#1: transform tag\n#2: imaginary angular frequency\n#3: z-force Xi integrand\n#4: z-force error due to numerical Brillouin-zone integration \n1.00 7.000000e-01 1.53365587e-02 1.10343992e-05\n1.50 7.000000e-01 3.27174955e-03 6.54894735e-06\n...\n5.00 7.000000e-01 2.84878401e-06 4.63609357e-08\n\n\n\n\nAs the file header says, the first column here is the\ntransform tag (the surface--surface separation), \nthe second column is the imaginary angular frequency \nin units of \n\\xi_0=3\\cdot 10^{14}\n rad/sec, and the\nthird column is the Casimir force per unit length \nper unit frequency (in units of \n \n\\hbar c/(\\omega_0 L_0^3)=31.6 (\\text{fN/micron})/\\omega_0\n\n)\nwhere \nL_0=1\\mu\\text{m}\n and \nwhere \n\\text{fN}\n=femtoNewtons.\n\n\n\n\nThe full run\n\n\nNow just launch the full run:\n\n\n % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce\n\n\n\n\n(This is the same command line as before, just without the \n\n--Xi\n option.) \n\n\nAfter some computation, this produces the output file \n\nSiliconBeams_192.out\n. You can plot the force (per unit length)\nversus surface--surface separation using e.g. \ngnuplot\n:\n\n\n% gnuplot\ngnuplot\n set xlabel 'Surface--surface separation (microns)'\ngnuplot\n set ylabel 'Casimir force per unit length (31.6 fN/micron)'\ngnuplot\n set logscale y\ngnuplot\n plot 'SiliconBeams_192.out' u 1:3 w lp pt 7 ps 1.5", 
            "title": "Casimir forces in a 1D extended geometry"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#scuff-em-geometry-file", 
            "text": "The  scuff-em   geometry file  \ndescribing our two infinite-length silicon beams is SiliconBeams_192.scuffgeo .\nThis specifies a geometry consisting of two identical\nsilicon beams, of infinite extent in the  x  direction,\nseparated by a distance of 2  \\mu m in the  z  direction.\nThe infinite beams consist of the finite-length unit-cell\ngeometry, periodically replicated infinitely many times.\n(The length of the lattice vector specified by the  LATTICE \nstatement should agree with the length of the unit cell as \ndefined in the  gmsh  geometry file.)  LATTICE\n    VECTOR 1.0 0.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT Beam1\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\nENDOBJECT\n\nOBJECT Beam2\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\n    DISPLACED 0 0 2\nENDOBJECT  We can use  scuff-analyze  to visualize the geometry \ndescribed by this  .scuffgeo  file:  % scuff-analyze --geometry SiliconBeams_192.scuffgeo --WriteGMSHFiles --Neighbors 2  [The option  --Neighbors 2  requests that, in addition to the unit-cell\ngeometry, the first 2 periodic images of the unit cell  in both the \npositive and negative directions  (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file  SiliconBeams_192.pp , which you \ncan view in  gmsh :  % gmsh SiliconBeams_192.pp   Note that the visualization file produced by  scuff-analyze  includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called  straddlers ,\nand they are added automatically by  scuff-em  to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.", 
            "title": "scuff-em geometry file"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#scuff-em-transformation-file", 
            "text": "In Casimir problems we typically want to compute\nforces (or torques, or energies) at multiple\nvalues of the surface--surface separation.\nThis is done by writing a  transformation file .\nIn this case we'll request the Casimir force between\nthe beams for 9 distinct values of the surface-surface\nseparation ranging between 1-5 \\mu m.\nThe file that specifies this is called Beams.trans :  TRANS 1.00 OBJECT Beam2 DISP 0 0 0.00\nTRANS 1.50 OBJECT Beam2 DISP 0 0 0.50\nTRANS 2.00 OBJECT Beam2 DISP 0 0 1.00\nTRANS 2.50 OBJECT Beam2 DISP 0 0 1.50\nTRANS 3.00 OBJECT Beam2 DISP 0 0 2.00\nTRANS 3.50 OBJECT Beam2 DISP 0 0 2.50\nTRANS 4.00 OBJECT Beam2 DISP 0 0 3.00\nTRANS 4.50 OBJECT Beam2 DISP 0 0 3.50\nTRANS 5.00 OBJECT Beam2 DISP 0 0 4.00  For full details on  scuff-em \ntransformation files, see  this reference page .\nFor the time being, note the following:    The text  TRANS 4.00  specifies the string  4.00 \n   as the  name  of this transformation. This is the string\n   that will be written to output files to identify\n   the Casimir quantities corresponding to each \n   geometrical transformation. This can be any \n   string not including spaces (in particular, it \n   need not be a number), but it's usually convenient\n   to label transformations by numbers so that we can \n   subsequently plot e.g. force vs. distance.    The text  OBJECT Beam2 DISP 0 0 3.00  specifies \n   that, in this particular geometrical transformation,\n   the object labeled  Beam2  in the  .scuffgeo  file \n   is to be displaced 3  \\mu m in the  z  direction.    Why do we assign the label  4.00  to a transformation\n   in which the displacement is 3  \\mu m? Because \n   transformations are  relative  to the configuration\n   described in the  .scuffgeo  file, and in the \n    .scuffgeo  file discussed above the second beam\n   is already displaced a distance of 2  \\mu m from\n   the first beam, which means the default\n   surface-surface separation is 1  \\mu m.\n   Applying an addition 3  \\mu m displacement then\n   yields a surface-surface separation of 4  \\mu m.    You can use  scuff-analyze  to obtain a \nvisualization of what your geometry looks \nlike under each transformation:  % scuff-analyze --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans  This produces a file named  SiliconBeams_192.transformed.pp , which\nyou can open in  gmsh  to confirm that the transformations you\ngot are the ones you wanted.", 
            "title": "scuff-em transformation file"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#a-first-trial-run-of-scuff-cas3d-at-a-single-frequency", 
            "text": "To compute the full Casimir force per unit length\nbetween the beams (call this quantity  \\mathcal F ),  scuff-cas3d  numerically evaluates an\nintegral over both imaginary frequencies  \\xi  and Bloch \nwavenumbers  k :  \\mathcal F \n  = \\int_0^\\infty d\\xi\n           \\underbrace{\\left [ \\frac{1}{V_{\\scriptsize{BZ}}}\n                                \\int_{V_{\\scriptsize{BZ}}}\n                                f(\\xi, k) dk \\,\n                       \\right]\n                      }_{\\equiv F(\\xi)} \nwhere the  k  integral is over the Brillouin zone (BZ)\nand  V_{\\scriptsize{BZ}}  is the one-dimensional volume \nof the BZ. For a 1D periodic geometry, the Brillouin \nzone is the 1D interval  0\\le k \\le \\frac{2\\pi}{L} ,\nand its one-dimensional volume (its length) is  \\frac{2\\pi}{L} ,\nwhere  L=1\\, \\mu m is the length of the real-space unit cell.\n,\nBecause the full calculation can be somewhat time-consuming,\nit's often useful to run a quick  single-frequency \ncalculation just to make sure things are making sense\nbefore launching the full run. We do this by \nspecifying the  --Xi  command-line option to scuff-cas3d , which requests a calculation\nof just the quantity  F(\\xi)  in the above\nequation at a single imaginary frequency  \\xi .\n(Note that, for our 1D periodic geometry,\nthis single-frequency calculation still entails a \nwavenumber integration over the 1D Brillouin zone.)   % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce --xi 0.7  This produces (among other files) files called  SiliconBeams_192.byXi \nand  SiliconBeams_192.byXikBloch. \nThe former file reports values of the quantity  F(\\xi) ,\nat the requested value of  \\xi , for each of the\ntransformations in the  .trans  file. The latter\nfile gives more granular information: it reports \nvalues of the quantity  f(\\xi,k)  at the requested \nvalue of  \\xi  and at each  k  point sampled by \nthe built-in numerical integrator.  The file  SiliconBeams_192.byXi  looks like this:  # scuff-cas3D run on superhr1 at 06/07/15::01:01:38\n# data file columns: \n#1: transform tag\n#2: imaginary angular frequency\n#3: z-force Xi integrand\n#4: z-force error due to numerical Brillouin-zone integration \n1.00 7.000000e-01 1.53365587e-02 1.10343992e-05\n1.50 7.000000e-01 3.27174955e-03 6.54894735e-06\n...\n5.00 7.000000e-01 2.84878401e-06 4.63609357e-08  As the file header says, the first column here is the\ntransform tag (the surface--surface separation), \nthe second column is the imaginary angular frequency \nin units of  \\xi_0=3\\cdot 10^{14}  rad/sec, and the\nthird column is the Casimir force per unit length \nper unit frequency (in units of \n  \\hbar c/(\\omega_0 L_0^3)=31.6 (\\text{fN/micron})/\\omega_0 \n)\nwhere  L_0=1\\mu\\text{m}  and \nwhere  \\text{fN} =femtoNewtons.", 
            "title": "A first trial run of scuff-cas3d at a single frequency"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#the-full-run", 
            "text": "Now just launch the full run:   % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce  (This is the same command line as before, just without the  --Xi  option.)   After some computation, this produces the output file  SiliconBeams_192.out . You can plot the force (per unit length)\nversus surface--surface separation using e.g.  gnuplot :  % gnuplot\ngnuplot  set xlabel 'Surface--surface separation (microns)'\ngnuplot  set ylabel 'Casimir force per unit length (31.6 fN/micron)'\ngnuplot  set logscale y\ngnuplot  plot 'SiliconBeams_192.out' u 1:3 w lp pt 7 ps 1.5", 
            "title": "The full run"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/", 
            "text": "Casimir forces between infinite-area silicon slabs (2D periodicity)\n\n\n\nIn this example, we exploit \nscuff-em\n's\n\nsupport for 2D periodic geometries\n\nto compute the equilibrium Casimir force per unit area\nbetween silicon slabs of infinite surface area.\nThe files for this example may be found in the\n\nshare/scuff-em/examples/SiliconSlabs\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file for unit-cell geometry\n\n\nThe \ngmsh\n geometry file \nSquare_N.geo\n\ndescribes the portion of the surface of a single\nslab that lies within the \nunit cell,\n\ni.e. the cell that is infinitely periodically\nreplicated to yield the full geometry.\nIn this case, the slab is infinitely thick (it is a \nhalf-space), so its surface consists of just a single\ntwo-dimensional sheet extending throughout the entire\nunit cell. I call this file \nSquare_N.geo\n to \nremind myself that it contains a parameter \nN\n \nthat describes the meshing fineness; more specifically,\n\nN\n defines the number of segments per unit length.\n\n\nTo produce a discretized surface-mesh\nrepresentation of this geometry, we run it through \n\ngmsh\n:\n\n\n% gmsh -2 Square_N.geo\n\n\n\n\nThis produces the file \nSquare_N.msh\n, which\nI rename to \nSquare_L2.40.msh\n because the side length\nof the square is \nL=2\\,\\mu\\text{m}\n and because\nthis particular mesh has 40 interior edges (this\nnumber defines the number of surface-current basis\nfunctions and thus the size of the BEM matrix in a\n\nscuff-em\n calculation). Editing the \n.geo\n file\nto change the \nN\n parameter to 3 (from its default \nvalue of 2) and re-running \ngmsh -2\n produces a\nfiner mesh file, which I rename to \nSquare_L2_96.msh\n.\nThese meshes may be visualized in \ngmsh\n:\n\n\n% gmsh Square_L2_40.msh\n% gmsh Square_L2_96.msh\n\n\n\n\n \nSquare_L2_40.msh\n\n\n\n\n \nSquare_L2_96.msh\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 2D periodic geometries in \nscuff-em\n, the \n   lattice vectors must lie in the \nxy\n plane.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on any edge of the unit cell must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nIn this case the unit cell dimensions are \n   \nL_x\\times L_y\n where \nL_x=L_y=2\\, \\mu\\text{m}\n.\n   (More generally, \nL_x\n and \nL_y\n may be any arbitrary\n   nonzero values, and they need not equal each other.)\n\n\n\n\n\n\n\n\nscuff-em\n geometry file\n\n\nThe \n\nscuff-em\n geometry file\n\ndescribing two silicon half-spaces (infinitely-thick slabs)\nbounded by the coarser of the two unit-cell meshes described \nabove is \nSiliconSlabs_L2_40.scuffgeo\n:\n\n\n# SCUFF-EM geometry file for two silicon slabs,\n# each of infinite cross-sectional area and infinite\n# thickness, separated in the z direction by 1 microns\n\nLATTICE\n    VECTOR 2.0 0.0\n    VECTOR 0.0 2.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nREGION UpperSlab MATERIAL Silicon\nREGION Gap       MATERIAL Vacuum\nREGION LowerSlab MATERIAL Silicon\n\nSURFACE UpperSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS UpperSlab Gap\n    DISPLACED 0 0 0.5\nENDOBJECT\n\nSURFACE LowerSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS LowerSlab Gap\nENDOBJECT\n\n\n\n\nNote the following points: \n\n\n\n\n\n\nEven though our geometry doesn't contain any \n\nmulti-material junctions\n,\nnonetheless we have to describe it using \n\nREGION\n and \nSURFACE\n statements\n\ninstead of \n\nOBJECT\n...\nENDOBJECT\n statements\n\nbecause the geometry can't be described as one or \nmore compact objects embedded in an exterior medium.\n\n\n\n\n\n\nIn the default configuration described by the \n.scuffgeo\n\nfile, the slab surfaces are displaced from each other\nby a distance of 0.5 \n\\mu\nm. The geometric transformations \ndescribed below will be relative to this default \nseparation.\n\n\n\n\n\n\n\n\nscuff-em\n transformation file\n\n\nThe file describing a list of\n\ngeometric transformations\n\nis \nSlabs.trans\n:\n\n\nTRANS 0.5 SURFACE UpperSurface DISP 0 0 0.0\nTRANS 1.0 SURFACE UpperSurface DISP 0 0 0.5\nTRANS 1.5 SURFACE UpperSurface DISP 0 0 1.0\nTRANS 2.0 SURFACE UpperSurface DISP 0 0 1.5\nTRANS 2.5 SURFACE UpperSurface DISP 0 0 2.0\nTRANS 3.0 SURFACE UpperSurface DISP 0 0 2.5\nTRANS 3.5 SURFACE UpperSurface DISP 0 0 3.0\nTRANS 4.0 SURFACE UpperSurface DISP 0 0 3.5\nTRANS 4.5 SURFACE UpperSurface DISP 0 0 4.0\nTRANS 5.0 SURFACE UpperSurface DISP 0 0 4.5\n\n\n\n\nIt's convenient to visualize the effect of these\ntransformations on our geometry before we run the calculation:\n\n\n% scuff-analyze --geometry SiliconSlabs_L2_40.scuffgeo --TransFile Slabs.trans\n\n\n\n\nThis produces the file \nSiliconSlabs_L2_40.transformed.pp\n,\nwhich can be visualized by opening it in \nGMSH\n:\n\n\n\n\n\n\nLaunching the run\n\n\nHere's a \nbash\n script that will run the full Casimir \ncalculation on both the coarser and finer meshes:\n\n\n# /bin/bash\n\nfor N in 40 192\ndo\n  ARGS=\n\n  ARGS=\n${ARGS} --geometry   SiliconSlabs_L2_${N}.scuffgeo\n\n  ARGS=\n${ARGS} --TransFile  Beams.trans\n\n  ARGS=\n${ARGS} --BZSymmetry BZSymmetry\n\n  ARGS=\n${ARGS} --energy\n\n  ARGS=\n${ARGS} --zForce\n\n\n  scuff-cas3D ${ARGS}\ndone\n\n\n\n\nThis produces the files \nSiliconSlabs_L2_40.out\n\nand \nSiliconSlabs_L2_96.out\n. The former file looks\nlike this:\n\n\n# scuff-cas3D run on superhr1 at 06/15/15::23:50:32\n# data file columns: \n#1: transform tag\n#2: energy \n#3: energy error due to numerical Xi integration \n#4: z-force \n#5: z-force error due to numerical Xi integration \n0.5 -1.254502e-01 5.463886e-05 -7.264755e-01 3.268714e-04 \n1.0 -1.631064e-02 5.770642e-06 -4.865678e-02 2.055737e-05 \n...\n\n\n\n\nNow plot the energy and force per unit area vs.\nseparation distance:\n\n\n% gnuplot\ngnuplot\n set xlabel 'surface--surface separation (um)'\ngnuplot\n set ylabel 'Energy / (\\hbar c / 1um), Force / ( \\hbar c/(1um^2) )'\ngnuplot\n set logscale y\ngnuplot\n FILE='SiliconSlabs_L2_N40.out'\ngnuplot\n plot FILE u 1:2 t 'Energy (SCUFF)', '' u 1:4 t 'Force (SCUFF)'\n\n\n\n\n\n\n\nIn this plot, the solid lines are the results of the Lifshitz\nformula for the Casimir energy and force between silicon\nslabs.", 
            "title": "Casimir forces in a 2D extended geometry"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/#scuff-em-geometry-file", 
            "text": "The  scuff-em  geometry file \ndescribing two silicon half-spaces (infinitely-thick slabs)\nbounded by the coarser of the two unit-cell meshes described \nabove is  SiliconSlabs_L2_40.scuffgeo :  # SCUFF-EM geometry file for two silicon slabs,\n# each of infinite cross-sectional area and infinite\n# thickness, separated in the z direction by 1 microns\n\nLATTICE\n    VECTOR 2.0 0.0\n    VECTOR 0.0 2.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nREGION UpperSlab MATERIAL Silicon\nREGION Gap       MATERIAL Vacuum\nREGION LowerSlab MATERIAL Silicon\n\nSURFACE UpperSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS UpperSlab Gap\n    DISPLACED 0 0 0.5\nENDOBJECT\n\nSURFACE LowerSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS LowerSlab Gap\nENDOBJECT  Note the following points:     Even though our geometry doesn't contain any  multi-material junctions ,\nnonetheless we have to describe it using  REGION  and  SURFACE  statements \ninstead of  OBJECT ... ENDOBJECT  statements \nbecause the geometry can't be described as one or \nmore compact objects embedded in an exterior medium.    In the default configuration described by the  .scuffgeo \nfile, the slab surfaces are displaced from each other\nby a distance of 0.5  \\mu m. The geometric transformations \ndescribed below will be relative to this default \nseparation.", 
            "title": "scuff-em geometry file"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/#scuff-em-transformation-file", 
            "text": "The file describing a list of geometric transformations \nis  Slabs.trans :  TRANS 0.5 SURFACE UpperSurface DISP 0 0 0.0\nTRANS 1.0 SURFACE UpperSurface DISP 0 0 0.5\nTRANS 1.5 SURFACE UpperSurface DISP 0 0 1.0\nTRANS 2.0 SURFACE UpperSurface DISP 0 0 1.5\nTRANS 2.5 SURFACE UpperSurface DISP 0 0 2.0\nTRANS 3.0 SURFACE UpperSurface DISP 0 0 2.5\nTRANS 3.5 SURFACE UpperSurface DISP 0 0 3.0\nTRANS 4.0 SURFACE UpperSurface DISP 0 0 3.5\nTRANS 4.5 SURFACE UpperSurface DISP 0 0 4.0\nTRANS 5.0 SURFACE UpperSurface DISP 0 0 4.5  It's convenient to visualize the effect of these\ntransformations on our geometry before we run the calculation:  % scuff-analyze --geometry SiliconSlabs_L2_40.scuffgeo --TransFile Slabs.trans  This produces the file  SiliconSlabs_L2_40.transformed.pp ,\nwhich can be visualized by opening it in  GMSH :", 
            "title": "scuff-em transformation file"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/#launching-the-run", 
            "text": "Here's a  bash  script that will run the full Casimir \ncalculation on both the coarser and finer meshes:  # /bin/bash\n\nfor N in 40 192\ndo\n  ARGS= \n  ARGS= ${ARGS} --geometry   SiliconSlabs_L2_${N}.scuffgeo \n  ARGS= ${ARGS} --TransFile  Beams.trans \n  ARGS= ${ARGS} --BZSymmetry BZSymmetry \n  ARGS= ${ARGS} --energy \n  ARGS= ${ARGS} --zForce \n\n  scuff-cas3D ${ARGS}\ndone  This produces the files  SiliconSlabs_L2_40.out \nand  SiliconSlabs_L2_96.out . The former file looks\nlike this:  # scuff-cas3D run on superhr1 at 06/15/15::23:50:32\n# data file columns: \n#1: transform tag\n#2: energy \n#3: energy error due to numerical Xi integration \n#4: z-force \n#5: z-force error due to numerical Xi integration \n0.5 -1.254502e-01 5.463886e-05 -7.264755e-01 3.268714e-04 \n1.0 -1.631064e-02 5.770642e-06 -4.865678e-02 2.055737e-05 \n...  Now plot the energy and force per unit area vs.\nseparation distance:  % gnuplot\ngnuplot  set xlabel 'surface--surface separation (um)'\ngnuplot  set ylabel 'Energy / (\\hbar c / 1um), Force / ( \\hbar c/(1um^2) )'\ngnuplot  set logscale y\ngnuplot  FILE='SiliconSlabs_L2_N40.out'\ngnuplot  plot FILE u 1:2 t 'Energy (SCUFF)', '' u 1:4 t 'Force (SCUFF)'   In this plot, the solid lines are the results of the Lifshitz\nformula for the Casimir energy and force between silicon\nslabs.", 
            "title": "Launching the run"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/", 
            "text": "Casimir-Polder potentials in dielectric nanostructures\n\n\n\nIn this example, we exploit \nscuff-em\n's support for periodic\ngeometries to compute Casimir-Polder potentials for atoms inside\ndielectric waveguides. Our basic test example will be the 1D \nphotonic crystal studied in this paper:\n\n\n\n\nC. L. Hung, S. M. Meenehan, D. E. Chang, O. Painter,\n    H. J. Kimble, ``Trapped atoms in one-dimensional\n    photonic crystals.'' \nNew Journal of Physics\n \n15\n\n    083026 (2013).\n\n\n\n\nWe will illustrate the use of \nscuff-em\n's Casimir-Polder\nmodule \nscuff-caspol\n by reproducing the results of \nHung et al. for a 1D lattice, then extend the calculation\nto the case of a 2D square lattice.\nThe files for this example may be found in the\n\nshare/scuff-em/examples/NanobeamCasimirPolder\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry and surface mesh for nanobeam unit cell\n\n\nThe \ngmsh\n geometry file \nUnitCell.geo\n\ndescribes just the portion of the nanobeam surface that \nlies within the \nunit cell,\n i.e. the cell that is \ninfinitely periodically replicated to yield the full \ngeometry. To produce a discretized surface-mesh\nrepresentation of this geometry, we run it through\n\ngmsh\n:\n\n\n% gmsh -2 UnitCell.geo\n\n\n\n\nThis produces a file named \nUnitCell.msh\n, which\nI rename to \nNanoBeamUnitCell_1006_.msh\n because\n\n(a)\n I will be using it as the unit cell of a beam\ngeometry, in contrast to a different use I will find\nfor the same unit cell below; and \n(b)\n the mesh has 1006 \ninterior edges (this is the number that defines the \nmemory and computation time requirements for the \n\nscuff-em\n calculation; it may be found by running\n\nscuff-analyze --mesh UnitCell.msh\n).\nYou can open the \n.msh\n file in \ngmsh\n to visualize\nthe unit-cell mesh:\n\n\n% gmsh NanoBeamUnitCell_1006.msh\n\n\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 1D periodic geometries in \nscuff-em\n, the direction\n   of infinite extent must be the \nx\n direction.\n\n\n\n\n\n\nThe sidewalls normal to the \ny\n and \nz\n directions are \n   meshed, but the sidewalls normal to the \nx\n direction are \n   \nnot\n meshed for this structure, because those surfaces are \n   not interfaces between different dielectrics.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on the unit-cell boundary must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nIn this case the unit cell is 0.367 \n\\mu\nm long.\n   This and other geometric parameters can be modified \n   by editing the file \nUnitCell.geo\n or directly\n   on the \ngmsh\n commmand line using the \n-setnumber\n option.\n\n\n\n\n\n\n\n\nscuff-em\n geometry file for dielectric nanobeam\n\n\nA \nscuff-em\n [geometry file]\nscuffEMGeometries\n \ndescribing an extended nanobeam consisting of infinitely\nmany repetitions of the above unit cell filled with\na dielectric material of constant relative permittivity\n\n\\epsilon=4\n, is \n\nNanoBeam_1006.scuffgeo\n.\nThe file reads, in its entirety, \n\n\nLATTICE\n    VECTOR 0.367 0.0\nENDLATTICE\n\nOBJECT Nanobeam\n    MESHFILE NanoBeamUnitCell_1006.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT\n\n\n\n\nWe can use \nscuff-analyze\n to visualize the geometry \ndescribed by this \n.scuffgeo\n file:\n\n\n% scuff-analyze --geometry NanoBeam_1006.scuffgeo --WriteGMSHFiles --Neighbors 3\n\n\n\n\n[The option \n--Neighbors 3\n requests that, in addition to the unit-cell\ngeometry, the first 3 periodic images of the unit cell \nin both the \npositive and negative directions\n (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file \nNanoBeam_1006.pp\n, which you \ncan view in \ngmsh\n:\n\n\n% gmsh NanoBeam_1006.pp\n\n\n\n\n\n\nNote that the visualization file produced by \nscuff-analyze\n includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called \nstraddlers\n,\nand they are added automatically by \nscuff-em\n to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.\n\n\n\n\ngmsh\n geometry and surface mesh for nanoarray unit cell\n\n\nIt's easy to generalize all of this to a geometry\nwith two-dimensional periodicity. The only modification\nrequired to the unit-cell mesh is that we have to \nremove the sidewalls normal to the \ny\n direction.\nThis can be done using the same \ngmsh\n geometry\nwe used above for the nanobeam unit cell, but with \nthe extra command-line option \n-setnumber LDim 2\n\non the \ngmsh\n command line. (Here \nLDim\n stands\nfor \"lattice dimension\".)\n\n\n% gmsh -2 -setnumber LDim 2 UnitCell.geo\n\n\n\n\nThis produces a file named \nUnitCell.msh\n, which\nI rename to \nNanoArrayUnitCell_800_.msh.\n It looks like this\n\n\n\n\n\n\nscuff-em\n geometry file for dielectric nanoarray\n\n\nA \n \nscuff-em\n geometry file\n\ndescribing a dielectric surface extended in two\ndimensions and perforated with a square lattice\nof the holes pictured above is \n\nNanoArray_800.scuffgeo\n.\nThe file reads\n\n\nLATTICE\n    VECTOR 0.367  0.0\n    VECTOR 0.000  0.845\nENDLATTICE\n\nOBJECT NanoArray\n    MESHFILE NanoArrayUnitCell_800.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT\n\n\n\n\nAgain we use \nscuff-analyze\n to visualize the geometry\ndescribed by this \n.scuffgeo\n file:\n\n\n% scuff-analyze --geometry NanoArray_800.scuffgeo --WriteGMSHFiles --Neighbors 3\n\n\n\n\n\n\n\n\nEvaluation points for Casimir-Polder potentials\n\n\nFor a Casimir-Polder calculation we will want to evaluate\nthe Casimir-Polder potential at range of points. We \nput the Cartesian coordinates of these points into a \ntext file named \nEPFile\n, which looks like \nthis:\n\n\n0.1835 0.4225 -0.500\n0.1835 0.4225 -0.480\n0.1835 0.4225 -0.460\n...\n0.1835 0.4225 0.480\n0.1835 0.4225 0.500\n\n\n\n\nand defines a line of points running through the middle of the hole\nin the beam unit cell.\n\n\nTo double-check that the evaluation points we specify\nare actually where we expect them to be vis-a-vis the \nmeshed surfaces in our problem, we can ask \nscuff-analyze\n\nto plot the evaluation points together with the \nunit-cell geometry:\n\n\n % scuff-analyze --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --WriteGMSHFiles\n\n\n\n\n\n\nThis confirms that our \nEPFile\n describes a line of evaluation\npoints running through the middle of the hole in the beam \nstructure, as desired.\n\n\n\n\nSetting up the Casimir-Polder calculation\n\n\nTo compute the Casimir-Polder potential on, say,\na rubidium atom at the above evaluation points\nfor the 1D and 2D extended structures, we now say simply\n\n\n  % scuff-caspol --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --Atom Rubidium\n\n\n\n\nand/or\n\n\n  % scuff-caspol --geometry NanoArray_800.scuffgeo --EPFile EPFile --Atom Rubidium\n\n\n\n\nThese calculations will produce files named \nNanoBeam_1006.out\n and \n\nNanoArray_800.out\n tabulating the Casimir-Polder potential \nexperience by the rubidium atom at each of the specified evaluation\npoints.\n\n\nFor more information on \nscuff-caspol\n, see the \n\nold \nscuff-caspol\n documentation\n,\nwhich is thorough and up-to-date (though it does not \ncover CP calculations in extended geometries) despite \nhaving not yet been ported from its previous format.", 
            "title": "Casimir-Polder potentials in dielectric nanostructures"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#scuff-em-geometry-file-for-dielectric-nanobeam", 
            "text": "A  scuff-em  [geometry file] scuffEMGeometries  \ndescribing an extended nanobeam consisting of infinitely\nmany repetitions of the above unit cell filled with\na dielectric material of constant relative permittivity \\epsilon=4 , is  NanoBeam_1006.scuffgeo .\nThe file reads, in its entirety,   LATTICE\n    VECTOR 0.367 0.0\nENDLATTICE\n\nOBJECT Nanobeam\n    MESHFILE NanoBeamUnitCell_1006.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT  We can use  scuff-analyze  to visualize the geometry \ndescribed by this  .scuffgeo  file:  % scuff-analyze --geometry NanoBeam_1006.scuffgeo --WriteGMSHFiles --Neighbors 3  [The option  --Neighbors 3  requests that, in addition to the unit-cell\ngeometry, the first 3 periodic images of the unit cell  in both the \npositive and negative directions  (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file  NanoBeam_1006.pp , which you \ncan view in  gmsh :  % gmsh NanoBeam_1006.pp   Note that the visualization file produced by  scuff-analyze  includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called  straddlers ,\nand they are added automatically by  scuff-em  to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.", 
            "title": "scuff-em geometry file for dielectric nanobeam"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#gmsh-geometry-and-surface-mesh-for-nanoarray-unit-cell", 
            "text": "It's easy to generalize all of this to a geometry\nwith two-dimensional periodicity. The only modification\nrequired to the unit-cell mesh is that we have to \nremove the sidewalls normal to the  y  direction.\nThis can be done using the same  gmsh  geometry\nwe used above for the nanobeam unit cell, but with \nthe extra command-line option  -setnumber LDim 2 \non the  gmsh  command line. (Here  LDim  stands\nfor \"lattice dimension\".)  % gmsh -2 -setnumber LDim 2 UnitCell.geo  This produces a file named  UnitCell.msh , which\nI rename to  NanoArrayUnitCell_800_.msh.  It looks like this", 
            "title": "gmsh geometry and surface mesh for nanoarray unit cell"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#scuff-em-geometry-file-for-dielectric-nanoarray", 
            "text": "A    scuff-em  geometry file \ndescribing a dielectric surface extended in two\ndimensions and perforated with a square lattice\nof the holes pictured above is  NanoArray_800.scuffgeo .\nThe file reads  LATTICE\n    VECTOR 0.367  0.0\n    VECTOR 0.000  0.845\nENDLATTICE\n\nOBJECT NanoArray\n    MESHFILE NanoArrayUnitCell_800.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT  Again we use  scuff-analyze  to visualize the geometry\ndescribed by this  .scuffgeo  file:  % scuff-analyze --geometry NanoArray_800.scuffgeo --WriteGMSHFiles --Neighbors 3", 
            "title": "scuff-em geometry file for dielectric nanoarray"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#evaluation-points-for-casimir-polder-potentials", 
            "text": "For a Casimir-Polder calculation we will want to evaluate\nthe Casimir-Polder potential at range of points. We \nput the Cartesian coordinates of these points into a \ntext file named  EPFile , which looks like \nthis:  0.1835 0.4225 -0.500\n0.1835 0.4225 -0.480\n0.1835 0.4225 -0.460\n...\n0.1835 0.4225 0.480\n0.1835 0.4225 0.500  and defines a line of points running through the middle of the hole\nin the beam unit cell.  To double-check that the evaluation points we specify\nare actually where we expect them to be vis-a-vis the \nmeshed surfaces in our problem, we can ask  scuff-analyze \nto plot the evaluation points together with the \nunit-cell geometry:   % scuff-analyze --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --WriteGMSHFiles   This confirms that our  EPFile  describes a line of evaluation\npoints running through the middle of the hole in the beam \nstructure, as desired.", 
            "title": "Evaluation points for Casimir-Polder potentials"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#setting-up-the-casimir-polder-calculation", 
            "text": "To compute the Casimir-Polder potential on, say,\na rubidium atom at the above evaluation points\nfor the 1D and 2D extended structures, we now say simply    % scuff-caspol --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --Atom Rubidium  and/or    % scuff-caspol --geometry NanoArray_800.scuffgeo --EPFile EPFile --Atom Rubidium  These calculations will produce files named  NanoBeam_1006.out  and  NanoArray_800.out  tabulating the Casimir-Polder potential \nexperience by the rubidium atom at each of the specified evaluation\npoints.  For more information on  scuff-caspol , see the  old  scuff-caspol  documentation ,\nwhich is thorough and up-to-date (though it does not \ncover CP calculations in extended geometries) despite \nhaving not yet been ported from its previous format.", 
            "title": "Setting up the Casimir-Polder calculation"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/", 
            "text": "Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres\n\n\nIn this example, we use \nscuff-neq\n to compute \n(1)\n the\npower radiated by a single SiO2 sphere, and \n(2)\n the heat\ntransfer and non-equilibrium Casimir force between two SiO2\nspheres. We compare the results of \nscuff-neq\n to \nthe predictions of the \n\nT-matrix formalism of Krueger et al\n.\n\n\nThe files for this example may be found in the \n\nshare/scuff-em/examples/SiO2Spheres\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file and surface mesh for a single sphere\n\n\nThe \ngmsh\n geometry file \nSphere.geo\n\ndescribes a sphere of radius 1 micron; it may \nbe meshed to generate coarse and fine surface meshes as follows:\n\n\n% gmsh -2 -clscale 1 Sphere.geo\n% RenameMesh Sphere.msh\n% gmsh -2 -clscale 0.5 Sphere.geo\n% RenameMesh Sphere.msh\n\n\n\n\n(Here \nRenameMesh\n is a simple \nbash\n script\nthat uses \nscuff-analyze\n to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThis produces the files \nSphere_501.msh\n and \nSphere_1479.msh,\n\nwhich you can visualize by opening in \ngmsh\n::\n\n\n% gmsh Sphere_501.msh\n\n\n\n\n\n\n% gmsh Sphere_1479.msh\n\n\n\n\n\n\n\n\nscuff-em\n geometry files\n\n\nThe \nscuff-em\n geometry file\n\nSiO2Sphere_501.scuffgeo\n\ndescribes a single SiO2 sphere.\n\n\nThe \nscuff-em\n geometry files\n\nSiO2Spheres_501.scuffgeo\n\n\nSiO2Spheres_1479.scuffgeo\n\neach describe the same configuration: two SiO2 spheres\nseparated by a center--center distance of 10 microns.\nYou can visualize this configuration by typing e.g.\n\n\n% scuff-analyze --geometry SiO2Spheres_1479.scuffgeo --WriteGMSHFiles\n% gmsh SiO2Spheres_1479.pp\n\n\n\n\n\n\n\n\nSpectral density of radiated power\n\n\nAs described in the \n\nscuff-neq\n documentation\n,\n\nscuff-neq\n computes the total power radiated by\nfinite-temperature objects as an integral over angular frequencies\n\n\\omega,\n in which the integrand involves a\ntemperature-dependent Bose-Einstein factor \nand a temperature-independent dimensionless flux \n\\Phi.\n \nTo calculate this radiated-power flux at a given set\nof frequencies, we say\n\n\n % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile --PRad\n\n\n\n\nwhere \nOmegaFile\n is a list of\nangular frequencies. (Here \n--PRad\n says that we \nare interested in the radiated power).\nThis produces the file\n\nSiO2Sphere_501.SiFlux\n, which looks something\nlike this:\n\n\n# scuff-neq run on superhr2 (07/11/15::00:31:36)\n# data file columns: \n# 1 transform tag\n# 2 omega \n# 3 (sourceObject,destObject) \n# 4 PRad flux spectral density\nDEFAULT 1.000000e-01 11 4.18911788e-06 \nDEFAULT 1.300000e-01 11 1.38869207e-05 \nDEFAULT 1.600000e-01 11 3.93335327e-05 \nDEFAULT 1.900000e-01 11 1.05263974e-04 \n\n\n\n\nAs the file header says, the second column here\nis the angular frequency \nin units of \n\\omega_0=3\\cdot 10^{14}\n rad/sec\nand the fourth column is the dimensionless power\nflux. (The first column lists the \n\ngeometrical transformation\n; since \nwe didn't specify the \n--transfile\n option to \n\nscuff-neq\n, we have just a single geometric\nconfiguration, labeled \nDEFAULT\n. The third \ncolumn identifies the source and destination objects;\nsince this geometry only has a single object,\nthe source and destination object are both \nalways object 1 and this column always reads\n\n11\n.)\n\n\nHere's a plot of the data:\n\n\n\n\nIn this plot, the solid line is the prediction of \nthe \nKrueger formalism\n, as computed\nby a \njulia\n code called \nKruegerFormulas.jl\n.\n\n\nThe plot is produced by \ngnuplot\n using \n\nthis script\n.\n\n\n\n\nSpectral density of power transfer and non-equilibrium force\n\n\nHere's a \nbash script\n that runs \nscuff-neq\n\nfor both the coarsely-meshed and finely-meshed two-sphere\ngeometry to compute the fluxes of power transfer\nand nonequilibrium force between the spheres. \nRunning the script produces files \nSiO2Spheres_501.SIFlux\n\nand \nSiO2Spheres_1479.SIFlux.\n Here are plots (produced\nby the same \ngnuplot\n script referenced above)\nof the heat-transfer flux from sphere 1 to sphere 2,\nand the force fluxes from sphere 1 to sphere 2 and\nfrom sphere 2 to sphere 2, compared to the Krueger\nT-matrix results (again computed using the \njulia\n\ncode referenced above).", 
            "title": "Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#gmsh-geometry-file-and-surface-mesh-for-a-single-sphere", 
            "text": "The  gmsh  geometry file  Sphere.geo \ndescribes a sphere of radius 1 micron; it may \nbe meshed to generate coarse and fine surface meshes as follows:  % gmsh -2 -clscale 1 Sphere.geo\n% RenameMesh Sphere.msh\n% gmsh -2 -clscale 0.5 Sphere.geo\n% RenameMesh Sphere.msh  (Here  RenameMesh  is a simple  bash  script\nthat uses  scuff-analyze  to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThis produces the files  Sphere_501.msh  and  Sphere_1479.msh, \nwhich you can visualize by opening in  gmsh ::  % gmsh Sphere_501.msh   % gmsh Sphere_1479.msh", 
            "title": "gmsh geometry file and surface mesh for a single sphere"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#scuff-em-geometry-files", 
            "text": "The  scuff-em  geometry file SiO2Sphere_501.scuffgeo \ndescribes a single SiO2 sphere.  The  scuff-em  geometry files SiO2Spheres_501.scuffgeo  SiO2Spheres_1479.scuffgeo \neach describe the same configuration: two SiO2 spheres\nseparated by a center--center distance of 10 microns.\nYou can visualize this configuration by typing e.g.  % scuff-analyze --geometry SiO2Spheres_1479.scuffgeo --WriteGMSHFiles\n% gmsh SiO2Spheres_1479.pp", 
            "title": "scuff-em geometry files"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#spectral-density-of-radiated-power", 
            "text": "As described in the  scuff-neq  documentation , scuff-neq  computes the total power radiated by\nfinite-temperature objects as an integral over angular frequencies \\omega,  in which the integrand involves a\ntemperature-dependent Bose-Einstein factor \nand a temperature-independent dimensionless flux  \\Phi.  \nTo calculate this radiated-power flux at a given set\nof frequencies, we say   % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile --PRad  where  OmegaFile  is a list of\nangular frequencies. (Here  --PRad  says that we \nare interested in the radiated power).\nThis produces the file SiO2Sphere_501.SiFlux , which looks something\nlike this:  # scuff-neq run on superhr2 (07/11/15::00:31:36)\n# data file columns: \n# 1 transform tag\n# 2 omega \n# 3 (sourceObject,destObject) \n# 4 PRad flux spectral density\nDEFAULT 1.000000e-01 11 4.18911788e-06 \nDEFAULT 1.300000e-01 11 1.38869207e-05 \nDEFAULT 1.600000e-01 11 3.93335327e-05 \nDEFAULT 1.900000e-01 11 1.05263974e-04   As the file header says, the second column here\nis the angular frequency \nin units of  \\omega_0=3\\cdot 10^{14}  rad/sec\nand the fourth column is the dimensionless power\nflux. (The first column lists the  geometrical transformation ; since \nwe didn't specify the  --transfile  option to  scuff-neq , we have just a single geometric\nconfiguration, labeled  DEFAULT . The third \ncolumn identifies the source and destination objects;\nsince this geometry only has a single object,\nthe source and destination object are both \nalways object 1 and this column always reads 11 .)  Here's a plot of the data:   In this plot, the solid line is the prediction of \nthe  Krueger formalism , as computed\nby a  julia  code called  KruegerFormulas.jl .  The plot is produced by  gnuplot  using  this script .", 
            "title": "Spectral density of radiated power"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#spectral-density-of-power-transfer-and-non-equilibrium-force", 
            "text": "Here's a  bash script  that runs  scuff-neq \nfor both the coarsely-meshed and finely-meshed two-sphere\ngeometry to compute the fluxes of power transfer\nand nonequilibrium force between the spheres. \nRunning the script produces files  SiO2Spheres_501.SIFlux \nand  SiO2Spheres_1479.SIFlux.  Here are plots (produced\nby the same  gnuplot  script referenced above)\nof the heat-transfer flux from sphere 1 to sphere 2,\nand the force fluxes from sphere 1 to sphere 2 and\nfrom sphere 2 to sphere 2, compared to the Krueger\nT-matrix results (again computed using the  julia \ncode referenced above).", 
            "title": "Spectral density of power transfer and non-equilibrium force"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/", 
            "text": "Spatial distribution of heat flux from a warm tip over a cold substrate\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/TipSubstrate\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry files for paraboloidal tip and cylindrical substrate\n\n\n\n\nParaboloid.geo\n\n\nCylinder.geo\n\n\n\n\nThe following script generates coarse and fine meshes of \nthese objects; it uses \nthis script\n.\n\n\n#!/bin/bash\nfor SHAPE in Paraboloid Cylinder\ndo\n  for L in 1.0 0.5\n  do\n    gmsh -2 -clscale ${L} ${SHAPE}.geo -o ${SHAPE}.msh\n    RenameMesh ${SHAPE}.msh\n  done\ndone\n\n\n\n\n\n\ngmsh\n geometry files\n\n\n\n\nTipSubstrate_Coarse.scuffgeo\n\n\nTipSubstrate_Fine.scuffgeo\n\n\n\n\n\n\n\n\nList of geometric transformations\n\n\n\n\nTipSubstrate.trans\n\n\n\n\n\n\nList of evaluation points\n\n\n\n\nEPFile\n\n\n\n\n\n\nRun \nscuff-neq\n\n\n#!/bin/bash\nARGS=\n\nARGS=\n${ARGS} --geometry ../TipSubstrate_Fine.scuffgeo\n\nARGS=\n${ARGS} --TransFile ../TipSubstrate.trans\n\nARGS=\n${ARGS} --Omega 0.7\n\nARGS=\n${ARGS} --EPFile ../EPFile\n\nARGS=\n${ARGS} --Power --ZForce\n\n\nscuff-neq ${ARGS}\n\n\n\n\n\n\nPlot \nz\n-directed Poynting flux from the tip through the vacuum and into the substrate:\n\n\ngnuplot\n plot 'TipSubstrate_Fine.SRFlux' u 5:9", 
            "title": "Spatial distribution of heat flux from a warm tip over a cold substrate"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#gmsh-geometry-files-for-paraboloidal-tip-and-cylindrical-substrate", 
            "text": "Paraboloid.geo  Cylinder.geo   The following script generates coarse and fine meshes of \nthese objects; it uses  this script .  #!/bin/bash\nfor SHAPE in Paraboloid Cylinder\ndo\n  for L in 1.0 0.5\n  do\n    gmsh -2 -clscale ${L} ${SHAPE}.geo -o ${SHAPE}.msh\n    RenameMesh ${SHAPE}.msh\n  done\ndone", 
            "title": "gmsh geometry files for paraboloidal tip and cylindrical substrate"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#gmsh-geometry-files", 
            "text": "TipSubstrate_Coarse.scuffgeo  TipSubstrate_Fine.scuffgeo", 
            "title": "gmsh geometry files"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#list-of-geometric-transformations", 
            "text": "TipSubstrate.trans", 
            "title": "List of geometric transformations"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#list-of-evaluation-points", 
            "text": "EPFile", 
            "title": "List of evaluation points"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#run-scuff-neq", 
            "text": "#!/bin/bash\nARGS= \nARGS= ${ARGS} --geometry ../TipSubstrate_Fine.scuffgeo \nARGS= ${ARGS} --TransFile ../TipSubstrate.trans \nARGS= ${ARGS} --Omega 0.7 \nARGS= ${ARGS} --EPFile ../EPFile \nARGS= ${ARGS} --Power --ZForce \n\nscuff-neq ${ARGS}", 
            "title": "Run scuff-neq"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#plot-z-directed-poynting-flux-from-the-tip-through-the-vacuum-and-into-the-substrate", 
            "text": "gnuplot  plot 'TipSubstrate_Fine.SRFlux' u 5:9", 
            "title": "Plot z-directed Poynting flux from the tip through the vacuum and into the substrate:"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/", 
            "text": "Dyadic Green's Functions and LDOS above a material half-space\n\n\n\nIn this example, we exploit \nscuff-em\n's\n\nsupport for 2D periodic geometries\n\nby using \nscuff-ldos\n\nto compute dyadic Green's functions (DGFs) and \nelectromagnetic local densities of states (LDOS) \nat evaluation points lying above an\ninfinite planar dielectric interface.\n\n\nBecause this geometry happens to be amenable to an analytical\ntreatment, we will also \ncheck\n the numerical results of\n\nscuff-em\n against the results of analytical calculations of\nthe LDOS.\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/HalfSpaceLDOS\n subdirectory\nof your \nscuff-em\n installation.\n\n\nReview: What we are computing and why we need Brillouin-zone integration\n\n\nFor the benefit of users who may be wondering why numerical Brillouin-zone\nintegration is needed for this calculation, this section briefly reviews\nsome of the theoretical background. \n(This material is discussed in more detail in the memo\n\nComputation of Green's Functions and LDOS in \nscuff-em\n).\nIf you just want to get started running the calculations in \nscuff-em\n, \nfeel free to \nskip to the next section\n.\n\n\nGreen's functions and LDOS\n\n\nThe scattering dyadic Green's function\n\n\\boldsymbol{\\mathcal G}^{\\text E}(\\omega;\n             \\mathbf{x}_{\\text D},\n             \\mathbf{x}_{\\text S})\n\nof a material geometry\nis a \n3\\times 3\n matrix whose \ni,j\n entry is proportional to the\n\ni\n-component of the scattered electric field \nat \n\\mathbf{x}_{\\text D}\n due to a \n\nj\n-directed point electric dipole source at\n\n\\mathbf{x}_{\\text S}\n, all quantities having\ntime dependence \n\\sim e^{-i\\omega t}\n. (We could also \nconsider the magnetic Green's function\n\n\\boldsymbol{\\mathcal G}^{\\text M}\n,\nwhich describes the scattered \nmagnetic\n fields\narising from a point \nmagnetic\n dipole excitation.)\nThe subscripts \"D\" and \"S\" label the \"destination\" and \n\"source\" points; if these coincide\n\n(\\mathbf{x}_{\\text D}=\\mathbf{x}_{\\text S})\n,\nwe are talking about \none-point DGFs\n; otherwise\nwe have \ntwo-point DGFs.\n\n\nThe one-point scattering DGFs for a material geometry contain\ninformation on how the bodies in the geometry modify\nthe electromagnetic local density of states (LDOS)\nin the vicinity of the body. More specifically,\nthe full LDOS \n\\rho(\\mathbf{x})\n at a point \n\\mathbf{x}\n\nmay be decomposed as a sum of electric and magnetic\ncontributions, which themselves may be further decomposed\ninto vacuum and scattering contributions:\n\n \\begin{array}{lcl}\n\\rho(\\omega; \\mathbf{x}) &=& \\rho^\\text{E}(\\omega; \\mathbf{x}) + \\rho^\\text{M}(\\omega; \\mathbf{x})\n\\\\[5pt]\n\\rho^{\\text{E,M}}(\\mathbf{x})\n &=&   \\rho_0(\\omega)\n     + \\Delta \\rho^\\text{E,M}(\\omega; \\mathbf{x})\n\\\\[5pt]\n\\rho_0(\\omega) &=&\\frac{\\omega^2}{\\pi^2 c^3}\n\\\\[5pt]\n\\Delta \\rho^{\\text{E,M}}(\\omega; \\mathbf{x})\n &=& \\frac{\\omega}{\\pi c^2}\n     \\text{Tr Im }\\boldsymbol{\\mathcal{G}}^\\text{E,M}(\\omega; \\mathbf{x}, \\mathbf{x})\n\\end{array}\n\n\n\n\nComputing Green's functions\n\n\nThe electric and magnetic DGFs for a given source point\n(and any number of destination points)\ncollectively describe the results of 6 scattering\nproblems (with incident fields produced by electric and\nmagnetic dipoles oriented in each of the 3 cartesian\ndirections), and---for \ncompact\n geometries---could\nbe computed in \nscuff-em\n simply by\nassembling 6 right-hand-side vectors, solving the \nBEM system for the corresponding surface currents, and\ncomputing the scattered fields at all desired destination\npoints. \n\n\nHowever, the situation is more complicated for\ninfinitely extended geometries. \n\nRecall\n that such\ngeometries are described in \nscuff-em\n by a\nunit-cell geometry together with a basis of vectors \nfor a (one- or two-dimensional) lattice \n\\mathcal{L}\n.\nBy restricting our attention to scattering problems\nin which the incident fields (and thus all fields and\ncurrents) satisfies the Bloch-periodicity\ncondition \n\nf(\\mathbf{x}+\\mathbf{L})\n  =\n  e^{i\\mathbf{k}_\\text{B}\\cdot \\mathbf{L}}f(\\mathbf{x})\n  \\quad\\text{ for all } \\quad\n  \\mathbf{L}\\in\\mathcal{L}\n\n\nfor some Bloch wavevector \n\\mathbf{k}_\\text{B}\n,\nwe can get away with solving only for the surface\ncurrents within the unit cell, the currents\neverywhere else being then fixed by the Bloch periodicity.\nThis is the basic magic trick that allows infinite\ngeometries to be modeled on finite computers.\n\n\nOf course, the restriction to scattering problems involving\nonly Bloch-periodic incident fields is in fact highly restrictive;\nindeed, it excludes the particular problem we must solve\nto compute DGFs and LDOS, in which the incident field emanates\nfrom a point source at \n\\mathbf{x}_\\text{S}\n and is certainly \nnot Bloch-periodic. But here we can avail to the linearity\nof Maxwell's equations and the magic of Fourier analysis.\nInstead of solving a scattering problem involving the field\nof a point source at \n\\mathbf{x}_\\text{S}\n, we consider\nthe field of an infinite phased \narray\n of point sources,\nlocated at points \n\\{\\mathbf{x}_\\text{S} + \\mathbf{L}\\}\n\nwith phases \ne^{i\\mathbf{k}_\\text{B} \\cdot \\mathbf{L}}\n,\nfor all \n\\mathbf{L}\\in \\mathcal{L}\n. This \nis\n a\nBloch-periodic field, so we can take it as the incident\nfield in a \nscuff-em\n scattering problem, \nand the \nresulting scattered fields at \n\\mathbf{x}_\\text{D}\n\ndefine the \nBloch-periodic scattering DGFs\n\n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\omega; \\mathbf{k}_\\text{B};\n\\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S}).\n\nTo recover the non-periodic DGF \n\\boldsymbol{\\mathcal{G}}\n\nfrom \n\\overline{\\boldsymbol{\\mathcal{G}}}\n, we now\nimagine solving and summing the results of\nmany scattering problems involving our infinite array\nof point sources phased with many different Bloch vectors \n\n\\mathbf{k}_\\text{B}\n, chosen cleverly to ensure that the\ncontributions of the single point source at \n\\mathbf{x}_\\text{S}\n add\nconstructively, while the contributions of all \nother\n \npoint sources in the array add destructively\nand cancel. The formal expression of this procedure\nis a sort of inverse Fourier transform relating\n\n\\boldsymbol{\\mathcal{G}}\n to the average of\n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\mathbf{k}_\\text{B})\n \nover the Brillouin zone (BZ) of the reciprocal lattice:\n\n \\boldsymbol{\\mathcal G}(\\omega; \\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S})\n  =\\frac{1}{V_\\text{BZ}}\n   \\int_\\text{BZ}\n   \\overline{\\boldsymbol{\\mathcal G}}(\\omega; \\mathbf{k}_\\text{B};\n                           \\mathbf{x}_\\text{D},\n                           \\mathbf{x}_\\text{S})\n   \\, d\\mathbf{k}_\\text{B}\n   \\qquad (1)\n\n\nor, evaluating the integral approximately by numerical cubature,\n\n \\boldsymbol{\\mathcal G}(\\omega; \\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S})\n   \\approx \\frac{1}{V_\\text{BZ}}\n   \\sum_{m} w_m \n   \\overline{\\boldsymbol{\\mathcal G}}(\\omega; \\mathbf{k}_{\\text{B}m}; \\mathbf{x}_\\text{D},\n                           \\mathbf{x}_\\text{S})\n\n\nwhere \n\\{\\mathbf{k}_{\\text{B}m}, w_m\\}\n are the points and weights in a\ncubature rule for integration over the Brillouin zone.\nThus, getting the LDOS at a single point in a periodic geometry\nrequires summing the results of many scattering calculations at\nvarious Bloch vectors \n\\mathbf{k}_{\\text{B}m}\n lying in the Brillouin \nzone of the reciprocal lattice.\n\n\nThe question of how to choose the cubature rule---that is, the set of\nBloch vectors \n\\{\\mathbf{k}_{\\text{B}m}\\}\n at which the integrand\nis sampled and the weights \n\\{w_m\\}\n with which the samples are \ncombined---to yield accurate integral estimates without exorbitant \ncomputational cost is a tricky one, and one whose answer varies from \nproblem to problem. There are two ways to proceed:\n\n\n\n\nYou can design your own cubature scheme for integration over\nthe Brillouin zone, and simply ask \nscuff-ldos\n to give you\nvalues of the integrand \n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\mathbf{k}_\\text{B})\n\nat specific Bloch vectors \n\\bf k_\\text{B}\n.\nIn this case you will pass the \n--OmegakBlochFile\n command-line\nargument to \nscuff-ldos\n, and you will get back a data file\n(with extension \n.byOmegakBloch\n) reporting values of \n\n\\overline{\\boldsymbol{\\mathcal{G}}}\n at each \n\\bf k_\\text{B}\n\npoint you specified. (See below for examples).\n\n\n\n\n\n\n\n\nAlternatively, you can use the built-in Brillouin-zone integrator\nin \nscuff-ldos\n to perform the BZ integral automatically. In this\ncase you will get back a data file with extension \n.LDOS\n\nreporting values of \n\\boldsymbol{\\mathcal{G}}\n and \n\\Delta\\rho\n\nat each frequency and evaluation point you specified, \nplus\n a \ndata file with extension \n.byOmegakBloch\n reporting the Bloch\nvectors \n\\bf k_\\text{B}\n at which the internal integrator\nsampled the integrand and the values of\n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\bf k_\\text{B})\n \nat each sample point. \nIn this case you will probably want to set various command-line \noptions to optimize the integral evaluation; this is illustrated\nbelow and discussed in more detail on the page \n\nBrillouin-zone integration in \nscuff-em\n.\n\n\n\n\n\n\n\n\ngmsh\n geometry files for unit-cell geometries\n\n\nTo compute DGFs and LDOS in a half-space geometry,\nwe will describe the interface between the upper (vacuum)\nand lower (dielectric) regions of our geometry as the\ninfinite periodic replication of a unit-cell mesh \nover the sites of a 2D square lattice.\nBecause this particular geometry has infinite translational\nsymmetry, we are free to choose the lattice constant \n\nL=L_x=L_y\n however we like; here we will consider \nthe two values \nL=10\n nm and \nL=100\n nm.\n\n\nThe \ngmsh\n geometry file \nSquare_L_N.geo\n\ndescribes a square with user-adjustable parameters \n\nL\n and \nN\n that may be configured using the \n-setnumber\n\noption on the \ngmsh\n command line to define the square\nside length and the number of triangle edges per side length \n(the meshing fineness). To produce unit-cell meshes for\nthe two desired lattice constants, I go like this:\n\n\n% gmsh -2 -setnumber L 0.1 -setnumber N 4 Square_L_N.geo -o Square_L0P1.msh \n% RenameMesh Square_L0P1.msh\n\n% gmsh -2 -setnumber L 0.01 -setnumber N 4 Square_L_N.geo -o Square_L0P01.msh \n% RenameMesh Square_L0P01.msh\n\n\n\n\n(Here \nRenameMesh\n is a simple \nbash\n script\nthat uses \nscuff-analyze\n to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThese commands produce the files \n\nSquare_L0P1_40.msh\n and \nSquare_L0P01_40.msh.\n I also repeat the \nprocess with \n-setnumber N 8\n to yield finer meshes (with 176 instead\nof 40 interior edges).\nThese meshes may be visualized in \ngmsh\n by saying e.g.\n\n\n% gmsh Square_L0P1.40.msh\n% gmsh Square_L0P01.176.msh\n\n\n\n\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 2D periodic geometries in \nscuff-em\n, the \n   lattice vectors must lie in the \nxy\n plane.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on any edge of the unit cell must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nAmong the various possible ways to discretize a square\nintro triangles, I have chosen one that preserves as \nmuch symmetry as possible---specifically, the mesh \nis symmetric under the transformations\n\nx \\leftrightarrow -x\n, \ny \\leftrightarrow -y\n, and\n\nx \\leftrightarrow y\n. This is important for exploiting\nsymmetries to reduce the cost of Brillouin-zone integration\n(see below).\n\n\n\n\n\n\nThe \n.msh\n files needed to run the calculations in this\ntutorial may be found in the \nmshFiles/\n subfolder\nof the \nHalfSpaceLDOS\n example distributed with\n\nscuff-em\n.\n\n\n\n\nscuff-em\n geometry files\n\n\nFor each unit-cell mesh I create\n\nscuff-em\n geometry files\n\ndescribing three material geometries:\n\n\n\n\n\n\nan infinite-area perfectly electrically conducting (PEC) plate at height \nz=0\n;\n\n\n\n\n\n\nan infinite lossless dielectric (\n\\epsilon \\equiv 10\n) filling\n  space for \nz<0\n, with vacuum for \nz>0\n;\n\n\n\n\n\n\nsame as previous, but now with lossy metal (aluminum) instead\n  of lossless dielectric.\n\n\n\n\n\n\nThe resulting \n.scuffgeo\n files may be found in the \n\nscuffgeoFiles/\n subfolder of the \nHalfSpaceLDOS\n\nexample directory.\nFor example, the PEC-plate geometry at the coarser resolution\nwith the longer lattice constant is\n\nPECPlate_L0P1_40.scuffgeo\n,\nwhile the aluminum half-space geometry at the finer resolution\nwith the shorter lattice constant is\n\nAlHalfSpace_L0P01_176.scuffgeo\n.\nThe latter file looks like this:\n\n\n# this comes from Phys Rev B **68** 245405\nMATERIAL ALUMINUM\n    wp = 1.747e16; \n    gamma = 7.596e13;\n    Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nLATTICE\n    VECTOR 0.01 0.00\n    VECTOR 0.00 0.01\nENDLATTICE\n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION Exterior       MATERIAL Aluminum\n\nSURFACE Plate\n    MESHFILE Square_L0P01_176.msh\n    REGIONS Exterior UpperHalfSpace\nENDSURFACE\n\n\n\n\n\n\nList of evaluation points\n\n\nWe'll compute one-point DGFs and LDOS at four points,\nlocated at distances of 1, 10, 100, and 1000 nm above\nthe surface on the \nz\n-axis (\nx=y=0\n). Thus our evaluation-point\nfile (\nEPFile\n) looks like this:\n\n\n0.0 0.0 0.001\n0.0 0.0 0.010\n0.0 0.0 0.100\n0.0 0.0 1.000\n\n\n\n\n\n\nStudying the integrand to select the optimal cubature rule\n\n\nUltimately we will want to launch a full\nBrillouin-zone-integrated calculation to get\nthe total LDOS at our desired evaluation points \nand frequencies. However, before doing this we\nshould acquire some insight into the behavior of\nthe integrand so that we can make intelligent\nchoices for the various \n\noptions controlling Brillouin-zone integration\n.\n\n\nChecking Brillouin-zone symmetry\n\n\nA first thing to check is the \nsymmetry\n of the\nintegrand within the Brillouin zone (BZ).\nAs discussed \nhere\n, the built-in cubature\nroutines for 2D BZ integration in \nscuff-em\n\ncan exploit 2, 4, or 8-fold rotational symmetry.\nIn this case, because\n\n\n\n\n\n\n(1)\n the underlying (real-space) geometry is symmetric\nunder \nx\\leftrightarrow -x\n, \ny\\leftrightarrow -y\n,\nand \nx\\leftrightarrow y\n,\n\n\n\n\n\n\n(2)\n we have chosen a mesh discretization that \npreserves these symmetries, and\n\n\n\n\n\n\n(3)\n we are computing a one-point DGF, \n\n\n\n\n\n\nwe expect the BZ integrand \n\n\\overline{\\boldsymbol{\\mathcal{G}}}(k_x,k_y)\n\nto have 8-fold rotational symmetry, and thus\nwe should be able to restrict the domain of the \nBZ integration to just the \nirreducible\n Brillouin\nzone (a triangular wedge having 1/8 the total area\nof the BZ, as shown \nhere\n) and multiply by 8 \nto get the full BZ integral. \n\n\nTo test this, we'll run a quick first calculation in which\nwe compute just the integrand \n\\boldsymbol{\\mathcal{G}}(k_x,k_y)\n\nat 8 \n(k_x,k_y)\n points related by symmetry. Specifically,\nfor a square lattice with lattice constant \nL=100\\text{ nm}\n\n(reciprocal lattice constant \n\\Gamma=\\frac{2\\pi}{100\\text{ nm}}\n)\nwe'll consider the point\n\n(k_x,k_y)=(0.40\\Gamma,0.27\\Gamma)\\approx(25,17)\\,\\mu\\text{m}^{-1}\n\nand the 7 other points obtained by flipping signs and interchanging\ncomponents. Here's a picture showing the locations of these 8 points\nwithin in the BZ:\n\n\n\n\nWorking at angular frequency \n\\omega=10 \\cdot 3\\times 10^{14}\n rad/sec,\nwe create a little text file named \nEightPoints\n listing the\n\n(\\omega, k_x, k_y)\n values at which we want to sample the BZ integrand:\n\n\n10 +25 +17\n10 +17 +25\n10 -17 +25\n10 -25 +17\n10 -25 -17\n10 -17 -25\n10 +17 -25\n10 +25 -17\n\n\n\n\nNow run \nscuff-ldos\n:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile EightPoints --EPFile EPFile\n\n\n\n\nThis produces the file \nAlHalfSpace_L0P1_40.byOmegakBloch\n,\nin which each individual line reports \n\\overline{\\mathcal{G}}\n values\nfor a single evaluation point, frequency, and Bloch vector.\nLooking at just the portion of the file corresponding to the\nevaluation point at \nz=100\n nm, we see this:\n\n\n\n\nThis shows that, as expected, the Brillouin-zone integrands for\nthe electric and magnetic LDOS \n\\rho^\\text{E,M}\n are\ninvariant---up to small numerical errors on the order \nof around 1%, which are reduced to around 0.1% when we re-run\nthe calculation on the finer [N=176] mesh---under the 8-fold\nsymmetry relating the various Brillouin-zone points here. \nLater we will exploit this symmetry by specifying the command-line\noption \n--BZSymmetryFactor 8\n to reduce the cost of\nevaluating the full BZ integral.\n\n\nIncidentally, notice that the individual components of the DGFs (such as\n\n\\overline{\\mathcal{G}}_{xx}\n) do \nnot\n obey the full set of symmetries obeyed by the LDOS. You will need to take this into account if your goal is to compute DGFs and not just LDOS.\n\n\nObserving the variation of the integrand with \n|\\mathbf{k}_\\text{B}|\n\n\n\n\nAnother diagnostic test is to inspect the variation of the integrand with the magnitude of the Bloch vector. For this purpose we'll compute the integrand at points lying on the \nx\n-axis between the origin and the edge of the BZ, again working with the \nL=100\n nm lattice at \n\\omega=10\n.  We create a file called \nXAxisPoints\n specifying the (\n\\omega,k_x,k_y\n) points we want to sample: \n\n\n10  00.0  0.0\n10  1.57  0.0\n10  3.14  0.0\n...\n10  29.8  0.0\n10  31.4  0.0\n\n\n\n\nRun \nscuff-ldos\n:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile XAxisPoints --EPFile EPFile\n\n\n\n\nThis produces the file \nAlHalfSpace_L0P1_40.byOmegakBloch.\n\nWe plot the BZ integrand for the electric LDOS \n\n\\rho^\\text{E}(\\mathbf{k})\n versus \nk_x\n at \nz=100\n nm: \n\n\n% gnuplot\ngnuplot\n FILE='AlHalfSpace_L0P1_40.byOmegakBloch'\ngnuplot\n set yrange [-100:100]\ngnuplot\n plot FILE u ($3==0.1 ? $6 : 1/0):8 w lp pt 7 ps 1\n\n\n\n\n\n\nWhoops! There seems to be some sort of blowup happening\nnear \nk_x=10\n, i.e. near the point \nk_x=\\frac{\\omega}{c}\n\nwhere the Bloch wavelength coincides with the free-space\nphoton wavelength. Zooming in on the region near \nk_x=10\n,\nthe data look like this (where we have additionally plotted\ndata for evaluation points at a couple of other heights\noff the surface):\n\n\n\n\nThe important things to read off from this plot are:\n\n\n\n\n\n\nAs \n|\\mathbf{k}_\\text{B}|\\to k_0\\equiv \\frac{\\omega}{c}\n from below, the integrand\n  blows up like \n1/\\sqrt{k_0 - |\\mathbf{k}_\\text{B}|}.\n\n\n\n\n\n\n\n\nOn the other side of \nk_0\n, the integrand decays exponentially\n  at a \nz\n-dependent rate.\n\n\n\n\n\n\nThis behavior is expected for cases in which the photon wavenumber\nlies within the Brillouin zone; the square-root blowup in\nthe LDOS is just the usual van Hove singularity, while \nthe exponential decay for larger \nk\n arises because plane waves\nwith transverse wavelength shorter than the free-space \nphoton wavelength are evanescent (not propagating) waves\nthat decay exponentially with distance from the surface.\n\n\n(BTW, \nhere\n is the \ngnuplot\n\nscript that produces the two plots above.)\n\n\n\n\nRunning full Brillouin-zone-integrated calculations\n\n\nNow it's time to launch runs for full BZ-integrated LDOS. For\nthis purpose we will want to set appropriate values for the\n\ncommand-line options controlling Brillouin-zone integration\n.\nWe have already determined that the integrand has \n8-fold symmetry, so we will be specifying \n--BZSymmetryFactor 8.\n\nThe next task is to choose a cubature\nrule (\"BZ integration method\"), i.e. a strategy for sampling\nthe integrand at appropriately-chosen \n|\\mathbf{k}_\\text{B}|\n\npoints to estimate the integral accurately with as few\nsamples as possible.\n\n\nThe presence of the \n|\\mathbf{k}_\\text{B}|=k_0\n singularity\nin the Brillouin zone makes this a good candidate for\nthe \nPolar2\n strategy, which performs the BZ integral\nusing a polar decomposition\n\n\\mathbf{k}_\\text{B}=(k_\\rho, k_\\theta)\n,\nwith the integrals over the regions \nk_\\rho < k_0\n \nand \nk_\\rho>k_0\n handled separately, and with the \nchange of variables \nk_\\rho \\to k_z=\\sqrt{|k_0^2 - k_\\rho^2|}\n\nto neutralize the square-root singularity at \n\nk_\\rho = k_0.\n In this case the integrals\nover \nk_z\n and \nk_\\theta\n are performed using \n\nN_\\rho\n and \nN_\\theta\n evaluation points, \nrespectively, where \nN_\\rho\n and \nN_\\theta\n \nare combined into a single value specified as \nthe \n--BZIOrder\n command-line option, i.e.\n\n \\texttt{--BZIOrder} = N_\\rho \\times 100 + N_\\theta.\n\nFor example, to use 31 points for the radial integral\nand 11 points for the \n\\theta\n integral, we would\nsay \n--BZIOrder 3111\n.\n\n\n(Actually, in this particular case, we expect to have\nfull rotational symmetry, i.e. the integrand should be \nindependent of \nk_\\theta\n, and thus we can specify\nthe special value \nN_\\theta=2\n to request that the\n\nk_\\theta\n integral be evaluated by a one-point\ncubature sampling just the point \nk_\\theta=0\n.)\n\n\nChoosing an 11-point integration rule for the\nradial integral and the above-discussed 1-point\ncubature for the \n\\theta\n integral, our \nscuff-ldos\n\ncommand-line looks like this:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 1102\n\n\n\n\nAs a comparison, I will also run calculations with\n\nN_\\rho=0\n. This selects an \nadaptive\n integration\nalgorithm for the radial integral, which determines\nthe number and location of the sample points\nautomatically to achieve user-specified relative\nand absolute error tolerances, which are set with the \n\n--BZIRelTol\n and \n--BZIAbsTol\n command-line options:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 0002 --BZIRelTol 1.0e-2 --BZIRelTol 1.0e-8\n\n\n\n\nI also run calculations on the finer-resolution mesh (the \n_176.scuffgeo\n files) and the \nmesh with lattice constant \nL=0.01\\,\\mu\\text{m}\n (the \nL0P01\n files).\n\n\nHere's a plot of the LDOS enhancement at \nz=10 nm\n:\n\n\n\n\nThe green dots are for the calculation with all numerical\nresolution parameters\nset to their maximum (most accurate and most expensive) values: \nfinest mesh, smallest lattice constant, and adaptive BZ cubature. \nThese points agree well with the analytical prediction up to the \nhighest frequencies, where they start to deviate.\n\n\nThe other data symbols are the results of calculations in\nwhich one fineness parameter is relaxed to a less-expensive \nvalue:\n\n\n\n\nThe blue triangles are for the geometry with lattice constant\n\nL=100\n nm (but still using a fine mesh with adaptive cubature).\nEvidently this degrades the quality of the numerical data\ncompletely. That makes sense, since the evaluation point \nis at a height \nz=10\n nm above the surface. For larger \nz\n \nvalues the data values for the two lattice constants are in \nbetter agreement.\n\n\n\n\n\n\n\n\nThe orange triangles are for the geometry with lattice\nconstant \nL=10\n nm, but now meshed at coarser resolution\n(resulting in \nN=40\n triangle edges instead of \nN=176\n for\nthe finer case). Evidently this doesn't degrade the \nquality of the data \nat all\n, so for this case we can \nrun calculations with the (significantly cheaper) coarser\nmesh at no cost in accuracy. \n\n\n\n\n\n\n\n\nThe yellow stars are for the \nL=10\n nm geometry with\nthe fine (\nN=176\n) mesh resolution, but with the BZ integration\nperformed using a fixed-order numerical integration (\nN_\\rho=31\n samples)\ninstead of adaptive quadrature\nfor the radial part of the BZ integral. Evidently this \nyields data that agree with the more accurate adaptive-quadrature\ndata at most frequencies, but deviate over a range of \nfrequencies in the range \n\\omega\\in[10,40]\n\nand again at high frequencies.", 
            "title": "LDOS and dyadic Green functions above an infinite aluminum half-space"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#greens-functions-and-ldos", 
            "text": "The scattering dyadic Green's function \\boldsymbol{\\mathcal G}^{\\text E}(\\omega;\n             \\mathbf{x}_{\\text D},\n             \\mathbf{x}_{\\text S}) \nof a material geometry\nis a  3\\times 3  matrix whose  i,j  entry is proportional to the i -component of the scattered electric field \nat  \\mathbf{x}_{\\text D}  due to a  j -directed point electric dipole source at \\mathbf{x}_{\\text S} , all quantities having\ntime dependence  \\sim e^{-i\\omega t} . (We could also \nconsider the magnetic Green's function \\boldsymbol{\\mathcal G}^{\\text M} ,\nwhich describes the scattered  magnetic  fields\narising from a point  magnetic  dipole excitation.)\nThe subscripts \"D\" and \"S\" label the \"destination\" and \n\"source\" points; if these coincide (\\mathbf{x}_{\\text D}=\\mathbf{x}_{\\text S}) ,\nwe are talking about  one-point DGFs ; otherwise\nwe have  two-point DGFs.  The one-point scattering DGFs for a material geometry contain\ninformation on how the bodies in the geometry modify\nthe electromagnetic local density of states (LDOS)\nin the vicinity of the body. More specifically,\nthe full LDOS  \\rho(\\mathbf{x})  at a point  \\mathbf{x} \nmay be decomposed as a sum of electric and magnetic\ncontributions, which themselves may be further decomposed\ninto vacuum and scattering contributions:  \\begin{array}{lcl}\n\\rho(\\omega; \\mathbf{x}) &=& \\rho^\\text{E}(\\omega; \\mathbf{x}) + \\rho^\\text{M}(\\omega; \\mathbf{x})\n\\\\[5pt]\n\\rho^{\\text{E,M}}(\\mathbf{x})\n &=&   \\rho_0(\\omega)\n     + \\Delta \\rho^\\text{E,M}(\\omega; \\mathbf{x})\n\\\\[5pt]\n\\rho_0(\\omega) &=&\\frac{\\omega^2}{\\pi^2 c^3}\n\\\\[5pt]\n\\Delta \\rho^{\\text{E,M}}(\\omega; \\mathbf{x})\n &=& \\frac{\\omega}{\\pi c^2}\n     \\text{Tr Im }\\boldsymbol{\\mathcal{G}}^\\text{E,M}(\\omega; \\mathbf{x}, \\mathbf{x})\n\\end{array}", 
            "title": "Green's functions and LDOS"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#computing-greens-functions", 
            "text": "The electric and magnetic DGFs for a given source point\n(and any number of destination points)\ncollectively describe the results of 6 scattering\nproblems (with incident fields produced by electric and\nmagnetic dipoles oriented in each of the 3 cartesian\ndirections), and---for  compact  geometries---could\nbe computed in  scuff-em  simply by\nassembling 6 right-hand-side vectors, solving the \nBEM system for the corresponding surface currents, and\ncomputing the scattered fields at all desired destination\npoints.   However, the situation is more complicated for\ninfinitely extended geometries.  Recall  that such\ngeometries are described in  scuff-em  by a\nunit-cell geometry together with a basis of vectors \nfor a (one- or two-dimensional) lattice  \\mathcal{L} .\nBy restricting our attention to scattering problems\nin which the incident fields (and thus all fields and\ncurrents) satisfies the Bloch-periodicity\ncondition  f(\\mathbf{x}+\\mathbf{L})\n  =\n  e^{i\\mathbf{k}_\\text{B}\\cdot \\mathbf{L}}f(\\mathbf{x})\n  \\quad\\text{ for all } \\quad\n  \\mathbf{L}\\in\\mathcal{L} \nfor some Bloch wavevector  \\mathbf{k}_\\text{B} ,\nwe can get away with solving only for the surface\ncurrents within the unit cell, the currents\neverywhere else being then fixed by the Bloch periodicity.\nThis is the basic magic trick that allows infinite\ngeometries to be modeled on finite computers.  Of course, the restriction to scattering problems involving\nonly Bloch-periodic incident fields is in fact highly restrictive;\nindeed, it excludes the particular problem we must solve\nto compute DGFs and LDOS, in which the incident field emanates\nfrom a point source at  \\mathbf{x}_\\text{S}  and is certainly \nnot Bloch-periodic. But here we can avail to the linearity\nof Maxwell's equations and the magic of Fourier analysis.\nInstead of solving a scattering problem involving the field\nof a point source at  \\mathbf{x}_\\text{S} , we consider\nthe field of an infinite phased  array  of point sources,\nlocated at points  \\{\\mathbf{x}_\\text{S} + \\mathbf{L}\\} \nwith phases  e^{i\\mathbf{k}_\\text{B} \\cdot \\mathbf{L}} ,\nfor all  \\mathbf{L}\\in \\mathcal{L} . This  is  a\nBloch-periodic field, so we can take it as the incident\nfield in a  scuff-em  scattering problem, \nand the \nresulting scattered fields at  \\mathbf{x}_\\text{D} \ndefine the  Bloch-periodic scattering DGFs  \\overline{\\boldsymbol{\\mathcal{G}}}(\\omega; \\mathbf{k}_\\text{B};\n\\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S}). \nTo recover the non-periodic DGF  \\boldsymbol{\\mathcal{G}} \nfrom  \\overline{\\boldsymbol{\\mathcal{G}}} , we now\nimagine solving and summing the results of\nmany scattering problems involving our infinite array\nof point sources phased with many different Bloch vectors  \\mathbf{k}_\\text{B} , chosen cleverly to ensure that the\ncontributions of the single point source at  \\mathbf{x}_\\text{S}  add\nconstructively, while the contributions of all  other  \npoint sources in the array add destructively\nand cancel. The formal expression of this procedure\nis a sort of inverse Fourier transform relating \\boldsymbol{\\mathcal{G}}  to the average of \\overline{\\boldsymbol{\\mathcal{G}}}(\\mathbf{k}_\\text{B})  \nover the Brillouin zone (BZ) of the reciprocal lattice:  \\boldsymbol{\\mathcal G}(\\omega; \\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S})\n  =\\frac{1}{V_\\text{BZ}}\n   \\int_\\text{BZ}\n   \\overline{\\boldsymbol{\\mathcal G}}(\\omega; \\mathbf{k}_\\text{B};\n                           \\mathbf{x}_\\text{D},\n                           \\mathbf{x}_\\text{S})\n   \\, d\\mathbf{k}_\\text{B}\n   \\qquad (1) \nor, evaluating the integral approximately by numerical cubature,  \\boldsymbol{\\mathcal G}(\\omega; \\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S})\n   \\approx \\frac{1}{V_\\text{BZ}}\n   \\sum_{m} w_m \n   \\overline{\\boldsymbol{\\mathcal G}}(\\omega; \\mathbf{k}_{\\text{B}m}; \\mathbf{x}_\\text{D},\n                           \\mathbf{x}_\\text{S}) \nwhere  \\{\\mathbf{k}_{\\text{B}m}, w_m\\}  are the points and weights in a\ncubature rule for integration over the Brillouin zone.\nThus, getting the LDOS at a single point in a periodic geometry\nrequires summing the results of many scattering calculations at\nvarious Bloch vectors  \\mathbf{k}_{\\text{B}m}  lying in the Brillouin \nzone of the reciprocal lattice.  The question of how to choose the cubature rule---that is, the set of\nBloch vectors  \\{\\mathbf{k}_{\\text{B}m}\\}  at which the integrand\nis sampled and the weights  \\{w_m\\}  with which the samples are \ncombined---to yield accurate integral estimates without exorbitant \ncomputational cost is a tricky one, and one whose answer varies from \nproblem to problem. There are two ways to proceed:   You can design your own cubature scheme for integration over\nthe Brillouin zone, and simply ask  scuff-ldos  to give you\nvalues of the integrand  \\overline{\\boldsymbol{\\mathcal{G}}}(\\mathbf{k}_\\text{B}) \nat specific Bloch vectors  \\bf k_\\text{B} .\nIn this case you will pass the  --OmegakBlochFile  command-line\nargument to  scuff-ldos , and you will get back a data file\n(with extension  .byOmegakBloch ) reporting values of  \\overline{\\boldsymbol{\\mathcal{G}}}  at each  \\bf k_\\text{B} \npoint you specified. (See below for examples).     Alternatively, you can use the built-in Brillouin-zone integrator\nin  scuff-ldos  to perform the BZ integral automatically. In this\ncase you will get back a data file with extension  .LDOS \nreporting values of  \\boldsymbol{\\mathcal{G}}  and  \\Delta\\rho \nat each frequency and evaluation point you specified,  plus  a \ndata file with extension  .byOmegakBloch  reporting the Bloch\nvectors  \\bf k_\\text{B}  at which the internal integrator\nsampled the integrand and the values of \\overline{\\boldsymbol{\\mathcal{G}}}(\\bf k_\\text{B})  \nat each sample point. \nIn this case you will probably want to set various command-line \noptions to optimize the integral evaluation; this is illustrated\nbelow and discussed in more detail on the page  Brillouin-zone integration in  scuff-em .", 
            "title": "Computing Green's functions"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#gmsh-geometry-files-for-unit-cell-geometries", 
            "text": "To compute DGFs and LDOS in a half-space geometry,\nwe will describe the interface between the upper (vacuum)\nand lower (dielectric) regions of our geometry as the\ninfinite periodic replication of a unit-cell mesh \nover the sites of a 2D square lattice.\nBecause this particular geometry has infinite translational\nsymmetry, we are free to choose the lattice constant  L=L_x=L_y  however we like; here we will consider \nthe two values  L=10  nm and  L=100  nm.  The  gmsh  geometry file  Square_L_N.geo \ndescribes a square with user-adjustable parameters  L  and  N  that may be configured using the  -setnumber \noption on the  gmsh  command line to define the square\nside length and the number of triangle edges per side length \n(the meshing fineness). To produce unit-cell meshes for\nthe two desired lattice constants, I go like this:  % gmsh -2 -setnumber L 0.1 -setnumber N 4 Square_L_N.geo -o Square_L0P1.msh \n% RenameMesh Square_L0P1.msh\n\n% gmsh -2 -setnumber L 0.01 -setnumber N 4 Square_L_N.geo -o Square_L0P01.msh \n% RenameMesh Square_L0P01.msh  (Here  RenameMesh  is a simple  bash  script\nthat uses  scuff-analyze  to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThese commands produce the files  Square_L0P1_40.msh  and  Square_L0P01_40.msh.  I also repeat the \nprocess with  -setnumber N 8  to yield finer meshes (with 176 instead\nof 40 interior edges).\nThese meshes may be visualized in  gmsh  by saying e.g.  % gmsh Square_L0P1.40.msh\n% gmsh Square_L0P01.176.msh    Note the following:    For 2D periodic geometries in  scuff-em , the \n   lattice vectors must lie in the  xy  plane.    For surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on any edge of the unit cell must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use  extrusions \n   in  gmsh , as in the  .geo  file above.    Among the various possible ways to discretize a square\nintro triangles, I have chosen one that preserves as \nmuch symmetry as possible---specifically, the mesh \nis symmetric under the transformations x \\leftrightarrow -x ,  y \\leftrightarrow -y , and x \\leftrightarrow y . This is important for exploiting\nsymmetries to reduce the cost of Brillouin-zone integration\n(see below).    The  .msh  files needed to run the calculations in this\ntutorial may be found in the  mshFiles/  subfolder\nof the  HalfSpaceLDOS  example distributed with scuff-em .", 
            "title": "gmsh geometry files for unit-cell geometries"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#scuff-em-geometry-files", 
            "text": "For each unit-cell mesh I create scuff-em  geometry files \ndescribing three material geometries:    an infinite-area perfectly electrically conducting (PEC) plate at height  z=0 ;    an infinite lossless dielectric ( \\epsilon \\equiv 10 ) filling\n  space for  z<0 , with vacuum for  z>0 ;    same as previous, but now with lossy metal (aluminum) instead\n  of lossless dielectric.    The resulting  .scuffgeo  files may be found in the  scuffgeoFiles/  subfolder of the  HalfSpaceLDOS \nexample directory.\nFor example, the PEC-plate geometry at the coarser resolution\nwith the longer lattice constant is PECPlate_L0P1_40.scuffgeo ,\nwhile the aluminum half-space geometry at the finer resolution\nwith the shorter lattice constant is AlHalfSpace_L0P01_176.scuffgeo .\nThe latter file looks like this:  # this comes from Phys Rev B **68** 245405\nMATERIAL ALUMINUM\n    wp = 1.747e16; \n    gamma = 7.596e13;\n    Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nLATTICE\n    VECTOR 0.01 0.00\n    VECTOR 0.00 0.01\nENDLATTICE\n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION Exterior       MATERIAL Aluminum\n\nSURFACE Plate\n    MESHFILE Square_L0P01_176.msh\n    REGIONS Exterior UpperHalfSpace\nENDSURFACE", 
            "title": "scuff-em geometry files"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#list-of-evaluation-points", 
            "text": "We'll compute one-point DGFs and LDOS at four points,\nlocated at distances of 1, 10, 100, and 1000 nm above\nthe surface on the  z -axis ( x=y=0 ). Thus our evaluation-point\nfile ( EPFile ) looks like this:  0.0 0.0 0.001\n0.0 0.0 0.010\n0.0 0.0 0.100\n0.0 0.0 1.000", 
            "title": "List of evaluation points"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#studying-the-integrand-to-select-the-optimal-cubature-rule", 
            "text": "Ultimately we will want to launch a full\nBrillouin-zone-integrated calculation to get\nthe total LDOS at our desired evaluation points \nand frequencies. However, before doing this we\nshould acquire some insight into the behavior of\nthe integrand so that we can make intelligent\nchoices for the various  options controlling Brillouin-zone integration .", 
            "title": "Studying the integrand to select the optimal cubature rule"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#checking-brillouin-zone-symmetry", 
            "text": "A first thing to check is the  symmetry  of the\nintegrand within the Brillouin zone (BZ).\nAs discussed  here , the built-in cubature\nroutines for 2D BZ integration in  scuff-em \ncan exploit 2, 4, or 8-fold rotational symmetry.\nIn this case, because    (1)  the underlying (real-space) geometry is symmetric\nunder  x\\leftrightarrow -x ,  y\\leftrightarrow -y ,\nand  x\\leftrightarrow y ,    (2)  we have chosen a mesh discretization that \npreserves these symmetries, and    (3)  we are computing a one-point DGF,     we expect the BZ integrand  \\overline{\\boldsymbol{\\mathcal{G}}}(k_x,k_y) \nto have 8-fold rotational symmetry, and thus\nwe should be able to restrict the domain of the \nBZ integration to just the  irreducible  Brillouin\nzone (a triangular wedge having 1/8 the total area\nof the BZ, as shown  here ) and multiply by 8 \nto get the full BZ integral.   To test this, we'll run a quick first calculation in which\nwe compute just the integrand  \\boldsymbol{\\mathcal{G}}(k_x,k_y) \nat 8  (k_x,k_y)  points related by symmetry. Specifically,\nfor a square lattice with lattice constant  L=100\\text{ nm} \n(reciprocal lattice constant  \\Gamma=\\frac{2\\pi}{100\\text{ nm}} )\nwe'll consider the point (k_x,k_y)=(0.40\\Gamma,0.27\\Gamma)\\approx(25,17)\\,\\mu\\text{m}^{-1} \nand the 7 other points obtained by flipping signs and interchanging\ncomponents. Here's a picture showing the locations of these 8 points\nwithin in the BZ:   Working at angular frequency  \\omega=10 \\cdot 3\\times 10^{14}  rad/sec,\nwe create a little text file named  EightPoints  listing the (\\omega, k_x, k_y)  values at which we want to sample the BZ integrand:  10 +25 +17\n10 +17 +25\n10 -17 +25\n10 -25 +17\n10 -25 -17\n10 -17 -25\n10 +17 -25\n10 +25 -17  Now run  scuff-ldos :  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile EightPoints --EPFile EPFile  This produces the file  AlHalfSpace_L0P1_40.byOmegakBloch ,\nin which each individual line reports  \\overline{\\mathcal{G}}  values\nfor a single evaluation point, frequency, and Bloch vector.\nLooking at just the portion of the file corresponding to the\nevaluation point at  z=100  nm, we see this:   This shows that, as expected, the Brillouin-zone integrands for\nthe electric and magnetic LDOS  \\rho^\\text{E,M}  are\ninvariant---up to small numerical errors on the order \nof around 1%, which are reduced to around 0.1% when we re-run\nthe calculation on the finer [N=176] mesh---under the 8-fold\nsymmetry relating the various Brillouin-zone points here. \nLater we will exploit this symmetry by specifying the command-line\noption  --BZSymmetryFactor 8  to reduce the cost of\nevaluating the full BZ integral.  Incidentally, notice that the individual components of the DGFs (such as \\overline{\\mathcal{G}}_{xx} ) do  not  obey the full set of symmetries obeyed by the LDOS. You will need to take this into account if your goal is to compute DGFs and not just LDOS.", 
            "title": "Checking Brillouin-zone symmetry"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#observing-the-variation-of-the-integrand-with-mathbfk_textb", 
            "text": "Another diagnostic test is to inspect the variation of the integrand with the magnitude of the Bloch vector. For this purpose we'll compute the integrand at points lying on the  x -axis between the origin and the edge of the BZ, again working with the  L=100  nm lattice at  \\omega=10 .  We create a file called  XAxisPoints  specifying the ( \\omega,k_x,k_y ) points we want to sample:   10  00.0  0.0\n10  1.57  0.0\n10  3.14  0.0\n...\n10  29.8  0.0\n10  31.4  0.0  Run  scuff-ldos :  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile XAxisPoints --EPFile EPFile  This produces the file  AlHalfSpace_L0P1_40.byOmegakBloch. \nWe plot the BZ integrand for the electric LDOS  \\rho^\\text{E}(\\mathbf{k})  versus  k_x  at  z=100  nm:   % gnuplot\ngnuplot  FILE='AlHalfSpace_L0P1_40.byOmegakBloch'\ngnuplot  set yrange [-100:100]\ngnuplot  plot FILE u ($3==0.1 ? $6 : 1/0):8 w lp pt 7 ps 1   Whoops! There seems to be some sort of blowup happening\nnear  k_x=10 , i.e. near the point  k_x=\\frac{\\omega}{c} \nwhere the Bloch wavelength coincides with the free-space\nphoton wavelength. Zooming in on the region near  k_x=10 ,\nthe data look like this (where we have additionally plotted\ndata for evaluation points at a couple of other heights\noff the surface):   The important things to read off from this plot are:    As  |\\mathbf{k}_\\text{B}|\\to k_0\\equiv \\frac{\\omega}{c}  from below, the integrand\n  blows up like  1/\\sqrt{k_0 - |\\mathbf{k}_\\text{B}|}.     On the other side of  k_0 , the integrand decays exponentially\n  at a  z -dependent rate.    This behavior is expected for cases in which the photon wavenumber\nlies within the Brillouin zone; the square-root blowup in\nthe LDOS is just the usual van Hove singularity, while \nthe exponential decay for larger  k  arises because plane waves\nwith transverse wavelength shorter than the free-space \nphoton wavelength are evanescent (not propagating) waves\nthat decay exponentially with distance from the surface.  (BTW,  here  is the  gnuplot \nscript that produces the two plots above.)", 
            "title": "Observing the variation of the integrand with |\\mathbf{k}_\\text{B}|"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#running-full-brillouin-zone-integrated-calculations", 
            "text": "Now it's time to launch runs for full BZ-integrated LDOS. For\nthis purpose we will want to set appropriate values for the command-line options controlling Brillouin-zone integration .\nWe have already determined that the integrand has \n8-fold symmetry, so we will be specifying  --BZSymmetryFactor 8. \nThe next task is to choose a cubature\nrule (\"BZ integration method\"), i.e. a strategy for sampling\nthe integrand at appropriately-chosen  |\\mathbf{k}_\\text{B}| \npoints to estimate the integral accurately with as few\nsamples as possible.  The presence of the  |\\mathbf{k}_\\text{B}|=k_0  singularity\nin the Brillouin zone makes this a good candidate for\nthe  Polar2  strategy, which performs the BZ integral\nusing a polar decomposition \\mathbf{k}_\\text{B}=(k_\\rho, k_\\theta) ,\nwith the integrals over the regions  k_\\rho < k_0  \nand  k_\\rho>k_0  handled separately, and with the \nchange of variables  k_\\rho \\to k_z=\\sqrt{|k_0^2 - k_\\rho^2|} \nto neutralize the square-root singularity at  k_\\rho = k_0.  In this case the integrals\nover  k_z  and  k_\\theta  are performed using  N_\\rho  and  N_\\theta  evaluation points, \nrespectively, where  N_\\rho  and  N_\\theta  \nare combined into a single value specified as \nthe  --BZIOrder  command-line option, i.e.  \\texttt{--BZIOrder} = N_\\rho \\times 100 + N_\\theta. \nFor example, to use 31 points for the radial integral\nand 11 points for the  \\theta  integral, we would\nsay  --BZIOrder 3111 .  (Actually, in this particular case, we expect to have\nfull rotational symmetry, i.e. the integrand should be \nindependent of  k_\\theta , and thus we can specify\nthe special value  N_\\theta=2  to request that the k_\\theta  integral be evaluated by a one-point\ncubature sampling just the point  k_\\theta=0 .)  Choosing an 11-point integration rule for the\nradial integral and the above-discussed 1-point\ncubature for the  \\theta  integral, our  scuff-ldos \ncommand-line looks like this:  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 1102  As a comparison, I will also run calculations with N_\\rho=0 . This selects an  adaptive  integration\nalgorithm for the radial integral, which determines\nthe number and location of the sample points\nautomatically to achieve user-specified relative\nand absolute error tolerances, which are set with the  --BZIRelTol  and  --BZIAbsTol  command-line options:  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 0002 --BZIRelTol 1.0e-2 --BZIRelTol 1.0e-8  I also run calculations on the finer-resolution mesh (the  _176.scuffgeo  files) and the \nmesh with lattice constant  L=0.01\\,\\mu\\text{m}  (the  L0P01  files).  Here's a plot of the LDOS enhancement at  z=10 nm :   The green dots are for the calculation with all numerical\nresolution parameters\nset to their maximum (most accurate and most expensive) values: \nfinest mesh, smallest lattice constant, and adaptive BZ cubature. \nThese points agree well with the analytical prediction up to the \nhighest frequencies, where they start to deviate.  The other data symbols are the results of calculations in\nwhich one fineness parameter is relaxed to a less-expensive \nvalue:   The blue triangles are for the geometry with lattice constant L=100  nm (but still using a fine mesh with adaptive cubature).\nEvidently this degrades the quality of the numerical data\ncompletely. That makes sense, since the evaluation point \nis at a height  z=10  nm above the surface. For larger  z  \nvalues the data values for the two lattice constants are in \nbetter agreement.     The orange triangles are for the geometry with lattice\nconstant  L=10  nm, but now meshed at coarser resolution\n(resulting in  N=40  triangle edges instead of  N=176  for\nthe finer case). Evidently this doesn't degrade the \nquality of the data  at all , so for this case we can \nrun calculations with the (significantly cheaper) coarser\nmesh at no cost in accuracy.      The yellow stars are for the  L=10  nm geometry with\nthe fine ( N=176 ) mesh resolution, but with the BZ integration\nperformed using a fixed-order numerical integration ( N_\\rho=31  samples)\ninstead of adaptive quadrature\nfor the radial part of the BZ integral. Evidently this \nyields data that agree with the more accurate adaptive-quadrature\ndata at most frequencies, but deviate over a range of \nfrequencies in the range  \\omega\\in[10,40] \nand again at high frequencies.", 
            "title": "Running full Brillouin-zone-integrated calculations"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/", 
            "text": "Electrostatic polarizability of platonic solids\n\n\n\nIn this example we use the \nscuff-static\n electrostatic\nmodule of \nscuff-em\n to compute the DC polarizabilities\nof dielectric bodies with regular shapes and varying\ndielectric permittivity. This example was inspired by this paper:\n\n\n\n\nA. Sihvola, P. Yla-Oijala, S. Jarvenpaa, and J. Avelin, \"Polarizabilities of Platonic Solids,\" \nIEEE Transactions on Antennas and Propagation\n \n52\n 9 (2004)\n\n\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/PlatonicSolids\n subdirectory\nof your \nscuff-em\n installation.\n\n\ngmsh\n geometry files for spherical, tetrahedral, and octrahedral particles\n\n\nThe \ngmsh\n geometry files\n\nSphere.geo\n,\n\nTetrahedron.geo\n\nand \n\nOctahedron.geo\n\nrespectively describe spherical, tetrahedral, and \noctahedral particles.\nI turn them into \n.msh\n files describing surface meshes of\ntwo different finenesses by running the following \nbash\n\nscript, which invokes the\n\nRenameMesh\n\nscript:\n\n\n#!/bin/bash\n\nfor SCALE in 1.0 0.7\ndo\n  for SHAPE in Sphere Tetrahedron Octahedron\n  do\n    gmsh -clscale ${SCALE} -2 ${SHAPE}.geo -o ${SHAPE}.msh\n    RenameMesh ${SHAPE}.msh\n  done\ndone\n\n\n\n\nNote\n: The \n.geo\n files contain a variable parameter \nL\n that \nsets the sphere radius or the polygon edge length. In each case,\nthe default value of \nL\n is chosen to ensure that the volume \nof the result particle matches the volume of a sphere of radius \n1, but you may override this setting (to set \nL\n to a value of, \nsay, 2.34) by adding the command-line option \n-setnumber L 2.34\n \nto the \ngmsh\n command above.\n\n\nHere are pictures of the finer of the three meshes produced by this procedure:\n\n\n\n\nPolarizability of a dielectric sphere\n\n\nHere's a simple \nscuff-em\n geometry file\n named \nE10Sphere.scuffgeo\n that describes a dielectric sphere with relative permittivity \n\\epsilon=10\n:\n\n\nOBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_10\nENDOBJECT\n\n\n\n\nTo compute the DC polarizability of this object, we say\n\n\n% scuff-static --Geometry E10Sphere.scuffgeo --PolFile E10Sphere.pol\n\n\n\n\nThis produces a file named \nE10Sphere.pol\n, which reports\nall 9 components of the DC polarizability tensor for the \nsphere:\n\n\n# data file columns: \n# 01: object label \n# 02: alpha_{xx} \n# 03: alpha_{yx} \n# 04: alpha_{zx} \n# 05: alpha_{xy} \n# 06: alpha_{yy} \n# 07: alpha_{zy} \n# 08: alpha_{xz} \n# 09: alpha_{yz} \n# 10: alpha_{zz} \nSphere 9.221300e+00 6.692939e-03 4.299017e-02 1.225110e-02 9.231265e+00 1.831022e-03 -1.860956e-02 1.039749e-02 9.233396e+00 \n\n\n\n\nHere are some observations on this result:\n\n\n\n\n\n\nThe diagonal components here are in decent agreement with the\ntheoretical value of \n\\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{\\epsilon-1}{\\epsilon+2}R^3\\approx 9.4 R^3\n.\n\n\n\n\n\n\nThe slight discrepancies between the three diagonal components\narise because the surface mesh slightly breaks rotational symmetry\nof the sphere.\n\n\n\n\n\n\nThe nonzero values of the off-diagonal components are \nnumerical noise.\n\n\n\n\n\n\nIn all three cases, the result is improved by running\ncalculations with finer surface meshes.\n\n\nPolarizability of a dielectric cavity\n\n\nHere's an alternative geometry file describing a spherical\nvacuum \ncavity\n in a universe filled with \n\\epsilon=10\n \ndielectric material:\n\n\nMEDIUM\n    MATERIAL CONST_EPS_10\nENDMEDIUM\n\nOBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_1\nENDOBJECT\n\n\n\n\nThe polarizability data predicted by \nscuff-static\n for this\ngeometry are\n\n\nSphere -5.168105e+00 3.103541e-03 1.420259e-02 3.842746e-03 -5.164908e+00 -1.409712e-03 -6.971980e-03 4.036885e-03 -5.165247e+00 \n\n\n\n\nThe diagonal components here agree with the theoretical value of\n\n\\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{1-\\epsilon}{1+2\\epsilon}R^3\\approx -5.14 R^3\n.\n\n\nbash\n script to run calculations at many different permittivities\n\n\nUltimately we want to compute the polarizability at many\ndifferent values of the interior and exterior permittivity,\nand it would be unwieldy to have to repeat the above process\nby hand in each case. Instead, it's convenient to write a\na \nbash\n script to automate the process. This script \nis called \nGetPolVsTau.sh\n. It has a \nhard-coded list of surface meshes and reads pairs of \ninterior and exterior permittivity values\nin the form (EpsOut, EpsIn) from a file named\n\nEpsFile\n. For each surface mesh and each\npair of permittivity values, the script does the \nfollowing:\n\n\n\n\n\n\nIt constructs a \n.scuffgeo\n file for the given\nmesh and permittivity values by appropriately modifying\na template file called \nTemplate.scuffgeo\n.\n\n\n\n\n\n\nIt runs \nscuff-static\n to get the polarizability\nfor this object with this pair of permittivity values.\n\n\n\n\n\n\nIt reads the resulting polarizability data from the output file\nwritten by \nscuff-static\n and writes the data, together\nwith the (EpsOut, EpsIn) values, to an overall output\nfile for the shape in question. \n\n\n\n\n\n\nThis script, which takes about 10 minutes to run on my laptop,\nproduces a series of files with names like\n\nTetrahedron_1179.AlphaVsTau.\n Here \nTau\n refers to the quantity\n\n\\tau\\equiv \\epsilon^{\\text{in}}/\\epsilon^{\\text{out}}\n\ndefined in the paper by Sihvola et al. referenced above.\n\n\nPlotting polarizability vs. \n\\tau\n for the three shapes\nreproduces Figure 4 of the paper by Sihvola et al.\nreferenced above,\nexcept for something funky that appears to be happening \nfor the tetrahedron around \n\\epsilon=100.\n\n\n\n\n\n\nIncidentally, here's the \ngnuplot\n script that I\nused to produce this plot: \nPlotter.gp\n.", 
            "title": "Electrostatic polarizability of platonic solids"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/#polarizability-of-a-dielectric-sphere", 
            "text": "Here's a simple  scuff-em  geometry file  named  E10Sphere.scuffgeo  that describes a dielectric sphere with relative permittivity  \\epsilon=10 :  OBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_10\nENDOBJECT  To compute the DC polarizability of this object, we say  % scuff-static --Geometry E10Sphere.scuffgeo --PolFile E10Sphere.pol  This produces a file named  E10Sphere.pol , which reports\nall 9 components of the DC polarizability tensor for the \nsphere:  # data file columns: \n# 01: object label \n# 02: alpha_{xx} \n# 03: alpha_{yx} \n# 04: alpha_{zx} \n# 05: alpha_{xy} \n# 06: alpha_{yy} \n# 07: alpha_{zy} \n# 08: alpha_{xz} \n# 09: alpha_{yz} \n# 10: alpha_{zz} \nSphere 9.221300e+00 6.692939e-03 4.299017e-02 1.225110e-02 9.231265e+00 1.831022e-03 -1.860956e-02 1.039749e-02 9.233396e+00   Here are some observations on this result:    The diagonal components here are in decent agreement with the\ntheoretical value of  \\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{\\epsilon-1}{\\epsilon+2}R^3\\approx 9.4 R^3 .    The slight discrepancies between the three diagonal components\narise because the surface mesh slightly breaks rotational symmetry\nof the sphere.    The nonzero values of the off-diagonal components are \nnumerical noise.    In all three cases, the result is improved by running\ncalculations with finer surface meshes.", 
            "title": "Polarizability of a dielectric sphere"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/#polarizability-of-a-dielectric-cavity", 
            "text": "Here's an alternative geometry file describing a spherical\nvacuum  cavity  in a universe filled with  \\epsilon=10  \ndielectric material:  MEDIUM\n    MATERIAL CONST_EPS_10\nENDMEDIUM\n\nOBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_1\nENDOBJECT  The polarizability data predicted by  scuff-static  for this\ngeometry are  Sphere -5.168105e+00 3.103541e-03 1.420259e-02 3.842746e-03 -5.164908e+00 -1.409712e-03 -6.971980e-03 4.036885e-03 -5.165247e+00   The diagonal components here agree with the theoretical value of \\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{1-\\epsilon}{1+2\\epsilon}R^3\\approx -5.14 R^3 .", 
            "title": "Polarizability of a dielectric cavity"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/#bash-script-to-run-calculations-at-many-different-permittivities", 
            "text": "Ultimately we want to compute the polarizability at many\ndifferent values of the interior and exterior permittivity,\nand it would be unwieldy to have to repeat the above process\nby hand in each case. Instead, it's convenient to write a\na  bash  script to automate the process. This script \nis called  GetPolVsTau.sh . It has a \nhard-coded list of surface meshes and reads pairs of \ninterior and exterior permittivity values\nin the form (EpsOut, EpsIn) from a file named EpsFile . For each surface mesh and each\npair of permittivity values, the script does the \nfollowing:    It constructs a  .scuffgeo  file for the given\nmesh and permittivity values by appropriately modifying\na template file called  Template.scuffgeo .    It runs  scuff-static  to get the polarizability\nfor this object with this pair of permittivity values.    It reads the resulting polarizability data from the output file\nwritten by  scuff-static  and writes the data, together\nwith the (EpsOut, EpsIn) values, to an overall output\nfile for the shape in question.     This script, which takes about 10 minutes to run on my laptop,\nproduces a series of files with names like Tetrahedron_1179.AlphaVsTau.  Here  Tau  refers to the quantity \\tau\\equiv \\epsilon^{\\text{in}}/\\epsilon^{\\text{out}} \ndefined in the paper by Sihvola et al. referenced above.  Plotting polarizability vs.  \\tau  for the three shapes\nreproduces Figure 4 of the paper by Sihvola et al.\nreferenced above,\nexcept for something funky that appears to be happening \nfor the tetrahedron around  \\epsilon=100.    Incidentally, here's the  gnuplot  script that I\nused to produce this plot:  Plotter.gp .", 
            "title": "bash script to run calculations at many different permittivities"
        }, 
        {
            "location": "/examples/TwoBodyCapacitors/TwoBodyCapacitors/", 
            "text": "Capacitance of parallel-plate and two-sphere capacitors\n\n\nIn this example, we exploit \nscuff-em\n's\n\nelectrostatics module\n\nto compute the capacitance of parallel-plate and two-sphere\ncapacitors. \n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/TwoBodyCapacitors\n subdirectory\nof your \nscuff-em\n installation.\n\n\nCapacitance of a parallel-plate capacitor\n\n\nI consider a parallel-plate capacitor consisting of\ntwo square conducting plates of side length \nL\n separated by\nvarious distances \nd\n. Neglecting fringing-field (i.e.\nfinite-size) effects, the capacitance is \nC(d)=\\epsilon_0 \\frac{L^2}{d}.\n\n\n\n\nCreating \nscuff-em\n input files\n\n\nBecause \nelectrostatics is scale-invariant\n,\nI can choose length units arbitrarily, and I will choose\nunits in which \nL=1\n. \nTo specify my geometry thus\nrequires meshed representations of squares of side\nlength 1, which I generate (at two different meshing\nresolutions) like this in \ngmsh\n:\n\n\n% gmsh -setnumber N 10 -2 Square_N.geo -o Square.msh \n% RenameMesh Square.msh\n% gmsh -setnumber N 20 -2 Square_N.geo -o Square.msh \n% RenameMesh Square.msh\n\n\n\n\nHere \nSquare_N.geo\n is the\n\ngmsh\n input file\nand \nRenameMesh\n is a little script that uses\n[\nscuff-analyze\n][scuff-analyze] to\ncount the number of interior edges in a surface mesh and\nrename the file accordingly.\n\n\nThis produces files named\n\nSquare_280.msh\n and \nSquare_1160.msh\n.\nNow write \n\nscuff-em\n geometry files\n:\n\n\n+\nTwoPlateCapacitor_280.scuffgeo\n\n\n+\nTwoPlateCapacitor_1160.scuffgeo\n\n\nand a\n\nlist of geometrical transformations\n\ndescribing 20 values of the plate-plate spacing \nd\n\nranging from \nd=0.01L\n to \nd=L\n:\n\n\n+\nTwoPlateCapacitor.trans\n\n\nBefore running calculations, double-check that our \n.scuffgeo\n\nand \n.trans\n files file correctly describe the range of geometries\nwe want to study:\n\n\n% scuff-analyze --geometry TwoPlateCapacitor_280.scuffgeo --transfile TwoPlateCapacitor.trans \n% gmsh TwoPlateCapacitor_280.transformed.pp\n\n\n\n\n\n\nRunning the calculation\n\n\n% for N in 280 1160\n% do\n%   ARGS=\n\n%   ARGS=\n${ARGS} --geometry  TwoPlateCapacitor_${N}.scuffgeo\n\n%   ARGS=\n${ARGS} --TransFile TwoPlateCapacitor.trans\n\n%   ARGS=\n${ARGS} --CapFile   TwoPlateCapacitor_${N}.out\n\n%   scuff-static ${ARGS}\n% done\n\n\n\n\nPlotting the data\n\n\n% gnuplot\ngnuplot\n set logscale xy\ngnuplot\n plot 'TwoPlateCapacitor_280.out' u 1:(abs($3)) t 'SCUFF, N=280' w p pt 7 ps 1, 'TwoPlateCapacitor_1160.out' u 1:(abs($3)) t 'SCUFF, N=1160' w p pt 6 ps 2, 1/x w l lw 2 t 'Theoretical Prediction'\n\n\n\n\n\n\nThe deviations from the theoretical prediction at small \nd\n are\ndue to finite mesh resolution and are reduced in the finer-mesh\ncalculation. On the other hand, the deviations at large \nd\n are\ndue to the finite size of the plates and are not changed by \ncomputing at finer resolution.\n\n\nCapacitance of a two-sphere capacitor\n\n\nThe \nshare/scuff-em/examples/TwoBodyCapacitors\n subdirectory\nof your \nscuff-em\n installation also contains input files\nfor computing the self- and mutual capacitances of a capacitor\nconsisting of two conducting spheres of radius \nR\n separated by a \nsurface-surface separation distance \nd\n (center-center separation \nd+2R\n).\nAnalytical formulas for the self-capacitance \nC_{11}=C_{22}\n and mutual\ncapacitance \nC_{12}=C_{21}\n for this case may be found in this paper\nfrom 1926:\n\n\n\n\nA. Russell, \"The problem of the spherical condenser\", \nJournal of the Institution of Electrical Engineers\n \n \n 64 \n \n 727 (1926). DOI: \n10.1049/jiee-1.1926.0065\n\n\n\n\nThe \nscuff-static\n computation proceeds as above with\nnew geometry and transformation files:\n\n\n\n\nTwoSphereCapacitor_501.scuffgeo\n\n\nTwoSphereCapacitor_2604.scuffgeo\n\n\nTwoSphereCapacitor.trans\n\n\n\n\n% for N in 501 2604\n% do\n%   ARGS=\n\n%   ARGS=\n${ARGS} --geometry  TwoSphereCapacitor_${N}.scuffgeo\n\n%   ARGS=\n${ARGS} --TransFile TwoSphereCapacitor.trans\n\n%   ARGS=\n${ARGS} --CapFile   TwoSphereCapacitor_${N}.out\n\n%   scuff-static ${ARGS}\n% done\n\n\n\n\nThis time we'll plot both \nC_{11}(d)\n and \nC_{12}(d)\n and\ncompare against the large-\nd\n and small-\nd\n analytical formulas\nin the paper of Russel above.\n\n\n\n\nHere's the \ngnuplot\n script I used\nto make this plot: \nTwoSphereCapacitor.gp\n.", 
            "title": "Capacitance of two-body capacitors"
        }, 
        {
            "location": "/examples/TwoBodyCapacitors/TwoBodyCapacitors/#capacitance-of-a-parallel-plate-capacitor", 
            "text": "I consider a parallel-plate capacitor consisting of\ntwo square conducting plates of side length  L  separated by\nvarious distances  d . Neglecting fringing-field (i.e.\nfinite-size) effects, the capacitance is  C(d)=\\epsilon_0 \\frac{L^2}{d}.", 
            "title": "Capacitance of a parallel-plate capacitor"
        }, 
        {
            "location": "/examples/TwoBodyCapacitors/TwoBodyCapacitors/#creating-scuff-em-input-files", 
            "text": "Because  electrostatics is scale-invariant ,\nI can choose length units arbitrarily, and I will choose\nunits in which  L=1 . \nTo specify my geometry thus\nrequires meshed representations of squares of side\nlength 1, which I generate (at two different meshing\nresolutions) like this in  gmsh :  % gmsh -setnumber N 10 -2 Square_N.geo -o Square.msh \n% RenameMesh Square.msh\n% gmsh -setnumber N 20 -2 Square_N.geo -o Square.msh \n% RenameMesh Square.msh  Here  Square_N.geo  is the gmsh  input file\nand  RenameMesh  is a little script that uses\n[ scuff-analyze ][scuff-analyze] to\ncount the number of interior edges in a surface mesh and\nrename the file accordingly.  This produces files named Square_280.msh  and  Square_1160.msh .\nNow write  scuff-em  geometry files :  + TwoPlateCapacitor_280.scuffgeo  + TwoPlateCapacitor_1160.scuffgeo  and a list of geometrical transformations \ndescribing 20 values of the plate-plate spacing  d \nranging from  d=0.01L  to  d=L :  + TwoPlateCapacitor.trans  Before running calculations, double-check that our  .scuffgeo \nand  .trans  files file correctly describe the range of geometries\nwe want to study:  % scuff-analyze --geometry TwoPlateCapacitor_280.scuffgeo --transfile TwoPlateCapacitor.trans \n% gmsh TwoPlateCapacitor_280.transformed.pp", 
            "title": "Creating scuff-em input files"
        }, 
        {
            "location": "/examples/TwoBodyCapacitors/TwoBodyCapacitors/#running-the-calculation", 
            "text": "% for N in 280 1160\n% do\n%   ARGS= \n%   ARGS= ${ARGS} --geometry  TwoPlateCapacitor_${N}.scuffgeo \n%   ARGS= ${ARGS} --TransFile TwoPlateCapacitor.trans \n%   ARGS= ${ARGS} --CapFile   TwoPlateCapacitor_${N}.out \n%   scuff-static ${ARGS}\n% done", 
            "title": "Running the calculation"
        }, 
        {
            "location": "/examples/TwoBodyCapacitors/TwoBodyCapacitors/#plotting-the-data", 
            "text": "% gnuplot\ngnuplot  set logscale xy\ngnuplot  plot 'TwoPlateCapacitor_280.out' u 1:(abs($3)) t 'SCUFF, N=280' w p pt 7 ps 1, 'TwoPlateCapacitor_1160.out' u 1:(abs($3)) t 'SCUFF, N=1160' w p pt 6 ps 2, 1/x w l lw 2 t 'Theoretical Prediction'   The deviations from the theoretical prediction at small  d  are\ndue to finite mesh resolution and are reduced in the finer-mesh\ncalculation. On the other hand, the deviations at large  d  are\ndue to the finite size of the plates and are not changed by \ncomputing at finer resolution.", 
            "title": "Plotting the data"
        }, 
        {
            "location": "/examples/TwoBodyCapacitors/TwoBodyCapacitors/#capacitance-of-a-two-sphere-capacitor", 
            "text": "The  share/scuff-em/examples/TwoBodyCapacitors  subdirectory\nof your  scuff-em  installation also contains input files\nfor computing the self- and mutual capacitances of a capacitor\nconsisting of two conducting spheres of radius  R  separated by a \nsurface-surface separation distance  d  (center-center separation  d+2R ).\nAnalytical formulas for the self-capacitance  C_{11}=C_{22}  and mutual\ncapacitance  C_{12}=C_{21}  for this case may be found in this paper\nfrom 1926:   A. Russell, \"The problem of the spherical condenser\",  Journal of the Institution of Electrical Engineers      64     727 (1926). DOI:  10.1049/jiee-1.1926.0065   The  scuff-static  computation proceeds as above with\nnew geometry and transformation files:   TwoSphereCapacitor_501.scuffgeo  TwoSphereCapacitor_2604.scuffgeo  TwoSphereCapacitor.trans   % for N in 501 2604\n% do\n%   ARGS= \n%   ARGS= ${ARGS} --geometry  TwoSphereCapacitor_${N}.scuffgeo \n%   ARGS= ${ARGS} --TransFile TwoSphereCapacitor.trans \n%   ARGS= ${ARGS} --CapFile   TwoSphereCapacitor_${N}.out \n%   scuff-static ${ARGS}\n% done  This time we'll plot both  C_{11}(d)  and  C_{12}(d)  and\ncompare against the large- d  and small- d  analytical formulas\nin the paper of Russel above.   Here's the  gnuplot  script I used\nto make this plot:  TwoSphereCapacitor.gp .", 
            "title": "Capacitance of a two-sphere capacitor"
        }, 
        {
            "location": "/examples/StriplineCapacitor/StriplineCapacitor/", 
            "text": "Capacitance of a PCB stripline trace\n\n\nIn this example, we use \nscuff-static\n to compute the\ncapacitance of a metal trace on an FR4 printed circuit board (PCB)\nwith ground plane. Here's a schematic depiction:\n\n\n\n\nHere the green region is dielectric, the yellow region\nis an (infinitesimally thin) metallic trace on the upper surface\nof the dielectric, and black indicates a ground plane\non the bottom surface of the dielectric.\n\n\ngmsh\n and \nscuff-em\n geometry files\n\n\nDue to the presence of \nmulti-material junctions\n\n(points at which three or more material regions meet, which in the \nfigure above occur along the edges of the metal trace and the\nground plane), the geometry cannot be described as a collection\nof 3D volumes bounded by closed surfaces, and instead requires\na more sophisticated geometry description in terms of\n\nregions\n and \nsurfaces\n. More specifically, there\nare only two regions in the problem (the exterior vacuum region\nand the dielectric), but there are three distinct surfaces:\n \n(1)\n the metal trace, \n(2)\n the dielectric-air interface, \nand \n(3)\n the ground plane.\nTo define a \nscuff-em\n geometry description\nfor this case, we need separate meshes for each of these\nthree surfaces. The following picture shows these three surface\nmeshes, displaced for clarity from their positions in the actual\ngeometry:\n\n\n\n\nHere's a \ngmsh\n geometry file\ndefining the various surfaces we need; note that this file makes\nthree \nPhysical Surface\n statements to define surfaces \n(1)\n, \n(2)\n, \nand \n(3)\n above. \n\n\n\n\nStriplineCapacitor.geo\n\n\n\n\nThis file contains user-specifiable parameters\n\nW\n, \nL\n, \nT\n, and \nB\n corresponding to the geometric quantities \nlabeled in the figure above, as well as a user-specifiable parameter \nN\n\nsetting the number of triangles per unit length. I generate surface\nmeshes at two different resolutions like this:\n\n\n% gmsh -2 -setnumber N 2 StriplineCapacitor.geo\n% gmsh -2 -setnumber N 4 StriplineCapacitor.geo\n\n\n\n\nThese produce \n.msh\n files containing respectively 1948 and 7856\ninner triangle edges (you can get this information by running\n\nscuff-analyze --mesh StriplineCapacitor.msh\n), so I rename them\nto \nStriplineCapacitor_1948.msh\n and \n\nStriplineCapacitor_7856.msh.\n\n\nNext I write a \nscuff-em\n geometry file\n\nfor each meshing resolution. This file defines the two regions and\nthe three surfaces defined above, specifying that the meshes for\neach surface\nare to be read from the \n.msh\n file with the appropriate \nPhysical Surface\n\ntag.\nFor the coarser-resolution mesh the file is called\n \nStriplineCapacitor_1948.scuffgeo\n,\nand it looks like this:\n\n\nREGION Exterior   MATERIAL Vacuum\nREGION Dielectric MATERIAL CONST_EPS_4\n\nOBJECT Trace\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 1\nENDOBJECT\n\nSURFACE RightBoundary\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 2\n    REGIONS Exterior Dielectric\nENDSURFACE\n\nSURFACE LeftBoundary\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 2\n    ROTATED 180 ABOUT 0 0 1\n    REGIONS Exterior Dielectric\nENDSURFACE\n\nOBJECT GroundPlane\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 3\nENDOBJECT\n\n\n\n\nSome notes on this geometry description:\n\n\n\n\n\n\nSince the default material for an \nOBJECT\n or \nSURFACE\n\nis PEC (\nP\nerfectly \nE\nlectrically \nC\nonducting), I\ndon't need to include a \nMaterial\n specification for the\ntrace or the ground plane.\n\n\n\n\n\n\nI have broken up surface 2 (dielectric--vacuum interface)\n into two halves, described by identical surface meshes \n with one rotated 180 degrees around the \nz\n axis. This is \nnot necessary, but it saves a little time in the matrix \nassembly, as the diagonal matrix blocks corresponding to the\ntwo half-surfaces are identical and thus only need to be \ncomputed once.\n\n\n\n\n\n\nThis geometry specification is perfectly adequate for\nelectrostatic problems, but would be not quite right for\nfinite-frequency problems. For such problems I would \ninstead want to define the trace and ground plane \nas regions of (in this case, infinite) surface conductivity\non a closed dielectric boundary surface.\n\n\n\n\n\n\nHaving written this \n.scuffgeo\n file for the coarser of my two\nsurface meshes, I can obtain one for the finer mesh by going like\nthis:\n\n\n\n\n\n\n BASE=StriplineCapacitor\n sed 's/1948/7856/g' ${BASE}_1948.scuffgeo \n ${BASE}_7856.scuffgeo\n\n\n\n\nCalculation of capacitance matrix\n\n\nTo compute the capacitance matrices for the two mesh resolutions,\ngo like this from the shell command line:\n\n\nfor N in 1948 7856 \ndo\n GEOM=StriplineCapacitor_${N}\n scuff-static --geometry ${GEOM}.scuffgeo --CapFile ${GEOM}.CapMatrix\ndone\n\n\n\n\nThis produces files\n\nStripLineCapacitor_1948.CapMatrix\n\nand \n\nStripLineCapacitor_7856.CapMatrix\n\nreporting capacitance-matrix entries.\n\n\nThese files look something like this:\n\n\n# scuff-static run on hikari (02/18/17::18:46:43)# indices of conducting surfaces: # data file columns: \n# 0 Trace\n# 1 GroundPlane\n# 01: C_{0,0} \n# 02: C_{0,1} \n# 03: C_{1,1} \n3.644861e+01 -3.080723e+01 1.142077e+02 \n\n\n\n\nThe three numbers reported here are the capacitance-matrix\nentries \nC_{11}\n, \nC_{12}\n, \nC_{22}\n divided by \n\\epsilon_0.\n\nThe capacitance from trace to ground plane is\n\n\n \\begin{array}{lcl} \n C &=& \\displaystyle{\n        \\frac{1}{\\frac{1}{C_{11}} + \\frac{1}{C_{22}} - \\frac{2}{C_{12}}}\n                    }\n\\\\[5pt]\n   &=& \\displaystyle{\n         \\frac{1}{   \\frac{1}{\\texttt{36.45}}\n                   + \\frac{1}{\\texttt{114.2}}\n                   + \\frac{2}{\\texttt{30.81}}\n                 }  }\n       \\cdot \\texttt{8.85e-12}\n\\\\[5pt]\n   &=& 0.89 \\texttt{pf}\n \\end{array}\n\n\n\n\n\nField visualization\n\n\nHere's a cross-sectional plot of electrostatic potential\nwith the trace and ground plane maintained at potentials\nof 1 and 0 volt respectively:\n\n\n\n\nThis plot is generated as follows:\n\n\nARGS=\n\nARGS=\n${ARGS} --geometry StriplineCapacitor_7876.scuffgeo\n\nARGS=\n${ARGS} --PotFile MyPotentialFile\n\nARGS=\n${ARGS} --FVMesh FVMesh.msh\n\nscuff-static ${ARGS}\n\n\n\n\nHere \nMyPotentialFile\n is a text file \nspecifying the conductor potentials and \nFVMesh.msh\n is a \nfield-visualization screen mesh produced by \ngmsh\n from \nthe file \nFVMesh.geo\n.\n\n\nCapacitance vs. PCB thickness\n\n\nHere's a \nbash\n script that computes capacitance vs. PCB\nthickness:\n\n\n\n\nCapVsT.sh\n\n\n\n\nFor each thickness value \nT\n in the file \nTFile,\n\nthis script\n\n\n\n\n\n\nruns \ngmsh\n to create a new surface mesh for a PCB stripline\n   with thickness \nT\n\n\n\n\n\n\nruns \nscuff-static\n to compute the capacitance matrix for this thickness\n\n\n\n\n\n\nextracts the data from the \n.CapMatrix\n file output and writes \n   it together with \nT\n to an overall output file.\n\n\n\n\n\n\nAccording to \nthis memo\n, the \ncapacitance per unit length (CPUL)\nof a stripline trace with the geometry shown above is\n\n\n\n\n \\texttt{CPUL} = \n   \\frac{1}{25.4}\\cdot\\frac{0.67(\\epsilon_r + 1.41)}\n                           {\\ln \\left[5.98H/(0.8W + T)\\right]}\n   \\qquad \\text{pf/mm}\n\n\nwhere \n\\epsilon_r\n is the relative dielectric constant\nand \nT=0\n for an infinitesimally thin trace.\n(The factor 1/25.4 converts units from pf/inch to pf/mm).", 
            "title": "Capacitance of a PCB stripline trace"
        }, 
        {
            "location": "/examples/StriplineCapacitor/StriplineCapacitor/#gmsh-and-scuff-em-geometry-files", 
            "text": "Due to the presence of  multi-material junctions \n(points at which three or more material regions meet, which in the \nfigure above occur along the edges of the metal trace and the\nground plane), the geometry cannot be described as a collection\nof 3D volumes bounded by closed surfaces, and instead requires\na more sophisticated geometry description in terms of regions  and  surfaces . More specifically, there\nare only two regions in the problem (the exterior vacuum region\nand the dielectric), but there are three distinct surfaces:\n  (1)  the metal trace,  (2)  the dielectric-air interface, \nand  (3)  the ground plane.\nTo define a  scuff-em  geometry description\nfor this case, we need separate meshes for each of these\nthree surfaces. The following picture shows these three surface\nmeshes, displaced for clarity from their positions in the actual\ngeometry:   Here's a  gmsh  geometry file\ndefining the various surfaces we need; note that this file makes\nthree  Physical Surface  statements to define surfaces  (1) ,  (2) , \nand  (3)  above.    StriplineCapacitor.geo   This file contains user-specifiable parameters W ,  L ,  T , and  B  corresponding to the geometric quantities \nlabeled in the figure above, as well as a user-specifiable parameter  N \nsetting the number of triangles per unit length. I generate surface\nmeshes at two different resolutions like this:  % gmsh -2 -setnumber N 2 StriplineCapacitor.geo\n% gmsh -2 -setnumber N 4 StriplineCapacitor.geo  These produce  .msh  files containing respectively 1948 and 7856\ninner triangle edges (you can get this information by running scuff-analyze --mesh StriplineCapacitor.msh ), so I rename them\nto  StriplineCapacitor_1948.msh  and  StriplineCapacitor_7856.msh.  Next I write a  scuff-em  geometry file \nfor each meshing resolution. This file defines the two regions and\nthe three surfaces defined above, specifying that the meshes for\neach surface\nare to be read from the  .msh  file with the appropriate  Physical Surface \ntag.\nFor the coarser-resolution mesh the file is called\n  StriplineCapacitor_1948.scuffgeo ,\nand it looks like this:  REGION Exterior   MATERIAL Vacuum\nREGION Dielectric MATERIAL CONST_EPS_4\n\nOBJECT Trace\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 1\nENDOBJECT\n\nSURFACE RightBoundary\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 2\n    REGIONS Exterior Dielectric\nENDSURFACE\n\nSURFACE LeftBoundary\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 2\n    ROTATED 180 ABOUT 0 0 1\n    REGIONS Exterior Dielectric\nENDSURFACE\n\nOBJECT GroundPlane\n    MESHFILE StriplineCapacitor_1948.msh\n    MESHTAG 3\nENDOBJECT  Some notes on this geometry description:    Since the default material for an  OBJECT  or  SURFACE \nis PEC ( P erfectly  E lectrically  C onducting), I\ndon't need to include a  Material  specification for the\ntrace or the ground plane.    I have broken up surface 2 (dielectric--vacuum interface)\n into two halves, described by identical surface meshes \n with one rotated 180 degrees around the  z  axis. This is \nnot necessary, but it saves a little time in the matrix \nassembly, as the diagonal matrix blocks corresponding to the\ntwo half-surfaces are identical and thus only need to be \ncomputed once.    This geometry specification is perfectly adequate for\nelectrostatic problems, but would be not quite right for\nfinite-frequency problems. For such problems I would \ninstead want to define the trace and ground plane \nas regions of (in this case, infinite) surface conductivity\non a closed dielectric boundary surface.    Having written this  .scuffgeo  file for the coarser of my two\nsurface meshes, I can obtain one for the finer mesh by going like\nthis:     BASE=StriplineCapacitor\n sed 's/1948/7856/g' ${BASE}_1948.scuffgeo   ${BASE}_7856.scuffgeo", 
            "title": "gmsh and scuff-em geometry files"
        }, 
        {
            "location": "/examples/StriplineCapacitor/StriplineCapacitor/#calculation-of-capacitance-matrix", 
            "text": "To compute the capacitance matrices for the two mesh resolutions,\ngo like this from the shell command line:  for N in 1948 7856 \ndo\n GEOM=StriplineCapacitor_${N}\n scuff-static --geometry ${GEOM}.scuffgeo --CapFile ${GEOM}.CapMatrix\ndone  This produces files StripLineCapacitor_1948.CapMatrix \nand  StripLineCapacitor_7856.CapMatrix \nreporting capacitance-matrix entries.  These files look something like this:  # scuff-static run on hikari (02/18/17::18:46:43)# indices of conducting surfaces: # data file columns: \n# 0 Trace\n# 1 GroundPlane\n# 01: C_{0,0} \n# 02: C_{0,1} \n# 03: C_{1,1} \n3.644861e+01 -3.080723e+01 1.142077e+02   The three numbers reported here are the capacitance-matrix\nentries  C_{11} ,  C_{12} ,  C_{22}  divided by  \\epsilon_0. \nThe capacitance from trace to ground plane is \n \\begin{array}{lcl} \n C &=& \\displaystyle{\n        \\frac{1}{\\frac{1}{C_{11}} + \\frac{1}{C_{22}} - \\frac{2}{C_{12}}}\n                    }\n\\\\[5pt]\n   &=& \\displaystyle{\n         \\frac{1}{   \\frac{1}{\\texttt{36.45}}\n                   + \\frac{1}{\\texttt{114.2}}\n                   + \\frac{2}{\\texttt{30.81}}\n                 }  }\n       \\cdot \\texttt{8.85e-12}\n\\\\[5pt]\n   &=& 0.89 \\texttt{pf}\n \\end{array}", 
            "title": "Calculation of capacitance matrix"
        }, 
        {
            "location": "/examples/StriplineCapacitor/StriplineCapacitor/#field-visualization", 
            "text": "Here's a cross-sectional plot of electrostatic potential\nwith the trace and ground plane maintained at potentials\nof 1 and 0 volt respectively:   This plot is generated as follows:  ARGS= \nARGS= ${ARGS} --geometry StriplineCapacitor_7876.scuffgeo \nARGS= ${ARGS} --PotFile MyPotentialFile \nARGS= ${ARGS} --FVMesh FVMesh.msh \nscuff-static ${ARGS}  Here  MyPotentialFile  is a text file \nspecifying the conductor potentials and  FVMesh.msh  is a \nfield-visualization screen mesh produced by  gmsh  from \nthe file  FVMesh.geo .", 
            "title": "Field visualization"
        }, 
        {
            "location": "/examples/StriplineCapacitor/StriplineCapacitor/#capacitance-vs-pcb-thickness", 
            "text": "Here's a  bash  script that computes capacitance vs. PCB\nthickness:   CapVsT.sh   For each thickness value  T  in the file  TFile, \nthis script    runs  gmsh  to create a new surface mesh for a PCB stripline\n   with thickness  T    runs  scuff-static  to compute the capacitance matrix for this thickness    extracts the data from the  .CapMatrix  file output and writes \n   it together with  T  to an overall output file.    According to  this memo , the \ncapacitance per unit length (CPUL)\nof a stripline trace with the geometry shown above is    \\texttt{CPUL} = \n   \\frac{1}{25.4}\\cdot\\frac{0.67(\\epsilon_r + 1.41)}\n                           {\\ln \\left[5.98H/(0.8W + T)\\right]}\n   \\qquad \\text{pf/mm} \nwhere  \\epsilon_r  is the relative dielectric constant\nand  T=0  for an infinitesimally thin trace.\n(The factor 1/25.4 converts units from pf/inch to pf/mm).", 
            "title": "Capacitance vs. PCB thickness"
        }, 
        {
            "location": "/examples/ImplicitSubstrate/ImplicitSubstrate/", 
            "text": "Implicit treatment of layered dielectric substrates in \nscuff-static\n\n\nIn this example, we exploit \nscuff-static\n's ability to\nhandle multilayered material substrates \nimplicitly\n---with\nno explicit meshing of substrate layers required---to allow \nhighly efficient modeling of the electrostatics of\ncomplex-shaped metallic traces on printed circuit boards.\n\n\nThe input files for the calculations discussed here\nmay be\nfound in the \nshare/scuff-em/examples/ImplicitSubstrate\n subdirectory\nof your \nscuff-em\n installation.\n\n\nAlso, the mathematical techniques involved are discussed\nin \nthis memo\n.\n\n\n\n\nLayered substrates in \nscuff-em\n: The \n.substrate\n file\n\n\nLayered substrates in \nscuff-em\n consist of zero or\nmore planar material layers, of arbitrary user-specified\nthicknesses and permittivities, optionally terminated\nby a perfectly-conducting ground plane. All layers are\ninfinitely extended in the \nx\n and \ny\n directions.\n\n\n\n\nAs is clear from this figure, an \nN\n-layered substrate is fully specified\nby giving, for layers \nn=1,2,...,N\n,\n\n\n\n\n\n\nz_n\n, the \nz\n-coordinate of the upper surface of the \nn\nth layer\n\n\n\n\n\\epsilon_n\n, the permittivity of the \nn\nth layer\n\n\n\n\ntogether with\n\n\n\n\nan optional specification of the \nz\n-coordinate of the terminating\n  ground plane, if present\n\n\nan optional specification of the dielectric function \n  \n\\epsilon_A\n of\n  the ambient (or \"above\") medium, if it is not vacuum.\n\n\n\n\nThis information is specified to \nscuff-em\n in the form\nof a simple text file conventionally given the file extension \n.substrate.\n\nEach line of this file [blank lines and comments (lines beginning with \n#\n)\nare ignored] describes one of the following items:\n\n\n(a)\n a single layer in a multilayered substrate, specified by the\n\nz\n-coordinate of its upper surface and a \n\nscuff-em\n material designation\n, or\n\n\n(b)\n the permittivity of the ambient (above) medium (if not\nvacuum) specified by the keyword \nMEDIUM\n followed by a\n\nscuff-em\n material designation\n, or\n\n\n(c)\n the \nz\n-coordinate of the optional ground plane followed by \nthe keyword \nGROUNDPLANE.\n\n\nExamples of \n.substrate\n files\n\n\n\n\nAn infinite dielectric half-space of relative permittivity \n\\epsilon\n=10\noccupying the region \nz<0\n:\n\n\n\n\n0.0 CONST_EPS_10\n\n\n\n\n\n\nA finite-thickness (1 length unit) slab of \n\\epsilon=10\n suspended in space with vacuum\nabove and below:\n\n\n\n\n 0.0 CONST_EPS_10\n-1.0 VACUUM\n\n\n\n\n\n\nA finite-thickness (1 length unit) slab of \n\\epsilon=10\n terminated below\nby a ground plane:\n\n\n\n\n 0.0 CONST_EPS_10\n-1.0 GROUNDPLANE\n\n\n\n\n\n\nAn alternating stack of silicon dioxide and silicon layers above \nan infinitely-thick slab of silicon:\n\n\n\n\n 0.0 SIO2\n-0.1 SILICON\n-0.2 SIO2\n-0.3 SILICON\n\n\n\n\nRunning \nscuff-static\n calculations with implicit substrates: The \n--substrate\n option\n\n\nTo run electrostatics calculations in the presence of a multilayer\ndielectric substrate described by the file \nMySubstrate.substrate\n,\nsimply add the option \n--substrate MySubstrate.substrate\n\nto the \nscuff-static\n command line.\n\n\nYou may set the environment variable \nSCUFF_SUBSTRATE_PATH\n\nto define a colon-separated list of directories in which\nto search for \n.substrate\n files. (The current working\ndirectory is always searched first.)\n\n\nFirst computational example: Electric fields near a charged metallic plate\n\n\nIn this simple example, I consider a small finite-size metallic plate\nmaintained at a constant potential of +1V in the vicinity of\n\n\n(a)\n no substrate\n\n\n(b)\n an infinite dielectric half-space of relative permittivity\n        \n\\epsilon_r=10\n filling the lower half-space \nz\\lt 0\n\n\n\n\n(c)\n a finite-thickness (thickness one length unit)\n        slab of relative permittivity \n\\epsilon_r=10\n\n        filling the lower half-space \nz\\lt 0\n\n\n\n\n(d)\n a finite-thickness slab of \n\\epsilon_r=10\n lying atop a ground plane.\n\n\nInput files for this example may be\nfound in the \nshare/scuff-em/examples/ImplicitSubstrate\n subdirectory\nof your \nscuff-em\n installation.\n.\n\n\nThe \nbash\n script I use to run this example is \n\nRunScript\n: \n\n\n#!/bin/bash\n\nCODE=scuff-static\n\nARGS=\n\nARGS=\n${ARGS} --geometry       Square_40.scuffgeo\n\nARGS=\n${ARGS} --potentialfile  PotentialFile\n\nARGS=\n${ARGS} --EPFile         EPFile.Fields\n\n\n\n${CODE} ${ARGS} --filebase None\n\nfor SUBSTRATE in E10HalfSpace E10SlabGP E10Slab\ndo\n  ${CODE} ${ARGS} --substrate ${SUBSTRATE}.substrate --filebase ${SUBSTRATE}\ndone\n\n\n\n\n\nThis computes the electrostatic potential and fields along a line\nof evaluation points at fixed \nx,y\n coordinates running from \n\nz=2\n (above the plate) to \nz=-1\n (the ground plane) \nand passing through the plate at \nz=1\n and the dielectric interface\nat \nz=0\n.\nThe results are plotted in \n\ngnuplot\n by saying \nload Plotter.Fields\n,\nwhere \nPlotter.Fields\n is \nthis script\n.\n\n\n\n\nTake-home messages:\n\n\n\n\n\n\nThe potential rises to \n\\phi=1\n at the location of the plate (\nz=1\n).\n\n\n\n\n\n\nIn the presence of the \n\\epsilon=10\n substrate, the potential exhibits\n  a kink at the air-substrate interface (\nz=0\n) that is absent for the\n  \"No substrate\" curve.\n\n\n\n\n\n\nIn the presence of the implicit ground plane at \nz=-1\n, \n  the potential properly tends to zero at \nz=-1\n (yellow curve).\n\n\n\n\n\n\nSecond computational example: Capacitance of metallic pad on grounded PCB", 
            "title": "Implicit handling of multilayer dielectric substrates"
        }, 
        {
            "location": "/examples/ImplicitSubstrate/ImplicitSubstrate/#layered-substrates-in-scuff-em-the-substrate-file", 
            "text": "Layered substrates in  scuff-em  consist of zero or\nmore planar material layers, of arbitrary user-specified\nthicknesses and permittivities, optionally terminated\nby a perfectly-conducting ground plane. All layers are\ninfinitely extended in the  x  and  y  directions.   As is clear from this figure, an  N -layered substrate is fully specified\nby giving, for layers  n=1,2,...,N ,    z_n , the  z -coordinate of the upper surface of the  n th layer   \\epsilon_n , the permittivity of the  n th layer   together with   an optional specification of the  z -coordinate of the terminating\n  ground plane, if present  an optional specification of the dielectric function \n   \\epsilon_A  of\n  the ambient (or \"above\") medium, if it is not vacuum.   This information is specified to  scuff-em  in the form\nof a simple text file conventionally given the file extension  .substrate. \nEach line of this file [blank lines and comments (lines beginning with  # )\nare ignored] describes one of the following items:  (a)  a single layer in a multilayered substrate, specified by the z -coordinate of its upper surface and a  scuff-em  material designation , or  (b)  the permittivity of the ambient (above) medium (if not\nvacuum) specified by the keyword  MEDIUM  followed by a scuff-em  material designation , or  (c)  the  z -coordinate of the optional ground plane followed by \nthe keyword  GROUNDPLANE.", 
            "title": "Layered substrates in scuff-em: The .substrate file"
        }, 
        {
            "location": "/examples/ImplicitSubstrate/ImplicitSubstrate/#examples-of-substrate-files", 
            "text": "An infinite dielectric half-space of relative permittivity  \\epsilon =10\noccupying the region  z<0 :   0.0 CONST_EPS_10   A finite-thickness (1 length unit) slab of  \\epsilon=10  suspended in space with vacuum\nabove and below:    0.0 CONST_EPS_10\n-1.0 VACUUM   A finite-thickness (1 length unit) slab of  \\epsilon=10  terminated below\nby a ground plane:    0.0 CONST_EPS_10\n-1.0 GROUNDPLANE   An alternating stack of silicon dioxide and silicon layers above \nan infinitely-thick slab of silicon:    0.0 SIO2\n-0.1 SILICON\n-0.2 SIO2\n-0.3 SILICON", 
            "title": "Examples of .substrate files"
        }, 
        {
            "location": "/examples/ImplicitSubstrate/ImplicitSubstrate/#running-scuff-static-calculations-with-implicit-substrates-the-substrate-option", 
            "text": "To run electrostatics calculations in the presence of a multilayer\ndielectric substrate described by the file  MySubstrate.substrate ,\nsimply add the option  --substrate MySubstrate.substrate \nto the  scuff-static  command line.  You may set the environment variable  SCUFF_SUBSTRATE_PATH \nto define a colon-separated list of directories in which\nto search for  .substrate  files. (The current working\ndirectory is always searched first.)", 
            "title": "Running scuff-static calculations with implicit substrates: The --substrate option"
        }, 
        {
            "location": "/examples/ImplicitSubstrate/ImplicitSubstrate/#first-computational-example-electric-fields-near-a-charged-metallic-plate", 
            "text": "In this simple example, I consider a small finite-size metallic plate\nmaintained at a constant potential of +1V in the vicinity of  (a)  no substrate  (b)  an infinite dielectric half-space of relative permittivity\n         \\epsilon_r=10  filling the lower half-space  z\\lt 0   (c)  a finite-thickness (thickness one length unit)\n        slab of relative permittivity  \\epsilon_r=10 \n        filling the lower half-space  z\\lt 0   (d)  a finite-thickness slab of  \\epsilon_r=10  lying atop a ground plane.  Input files for this example may be\nfound in the  share/scuff-em/examples/ImplicitSubstrate  subdirectory\nof your  scuff-em  installation. .  The  bash  script I use to run this example is  RunScript :   #!/bin/bash\n\nCODE=scuff-static\n\nARGS= \nARGS= ${ARGS} --geometry       Square_40.scuffgeo \nARGS= ${ARGS} --potentialfile  PotentialFile \nARGS= ${ARGS} --EPFile         EPFile.Fields \n\n\n${CODE} ${ARGS} --filebase None\n\nfor SUBSTRATE in E10HalfSpace E10SlabGP E10Slab\ndo\n  ${CODE} ${ARGS} --substrate ${SUBSTRATE}.substrate --filebase ${SUBSTRATE}\ndone  This computes the electrostatic potential and fields along a line\nof evaluation points at fixed  x,y  coordinates running from  z=2  (above the plate) to  z=-1  (the ground plane) \nand passing through the plate at  z=1  and the dielectric interface\nat  z=0 .\nThe results are plotted in  gnuplot  by saying  load Plotter.Fields ,\nwhere  Plotter.Fields  is  this script .   Take-home messages:    The potential rises to  \\phi=1  at the location of the plate ( z=1 ).    In the presence of the  \\epsilon=10  substrate, the potential exhibits\n  a kink at the air-substrate interface ( z=0 ) that is absent for the\n  \"No substrate\" curve.    In the presence of the implicit ground plane at  z=-1 , \n  the potential properly tends to zero at  z=-1  (yellow curve).", 
            "title": "First computational example: Electric fields near a charged metallic plate"
        }, 
        {
            "location": "/examples/ImplicitSubstrate/ImplicitSubstrate/#second-computational-example-capacitance-of-metallic-pad-on-grounded-pcb", 
            "text": "", 
            "title": "Second computational example: Capacitance of metallic pad on grounded PCB"
        }, 
        {
            "location": "/examples/pythonCapacitance/pythonCapacitance/", 
            "text": "Studying finite-size effects in metal-on-substrate capacitors using data fitting in python\n\n\nIn this example, we use the \npython\n interface to\n\nscuff-em\n---specifically, to the\n\nscuff-em\n electrostatics module\n---to\nstudy finite-size effects in capacitors formed by metal traces on \n(infinite-area) dielectric substrates with and without ground planes.\n\n\nOur calculation will exploit \nscuff-em\n's capability for\n\nimplicit treatment of layered dielectric substrates\n,\neliminating the need to mesh substrate layers or ground planes\nand greatly reducing computational cost. \n\n\nOur goal will be to estimate the capacitance per unit length or area\nfor infinite-size capacitors of various shapes.\nWe will do this by using the \n\npython\n interface to \nscuff-em\n\nto fit numerical data for several finite values of\nthe length \nL\n or area \nA\n to a functional form in \nL\n or \nA\n, then \ntaking the limits \nL,A\\to \\infty\n.\n\n\nLayout of input files\n\n\nThe input files for the calculations discussed here may be\nfound in the \nshare/scuff-em/examples/pythonCapacitance\n subdirectory\nof your \nscuff-em\n installation.\nThe various files here are organized into the following subdirectories:\n\n\n\n\ngeoFiles\n: \ngmsh\n geometry files\n\n\nmshFiles\n: \ngmsh\n mesh files\n\n\nscuffgeoFiles\n: \nscuff-em\n geometry files\n\n\nsubstrateFiles\n: \nscuff-em\n substrate-definition files\n\n\n\n\nCustomizable \ngmsh\n geometry for rectangular plates\n\n\nThe \ngeoFiles\n subdirectory contains a \ngmsh\n geometry file named\n\nRectangle.geo\n which we will use to produce\nsurface meshes describing infinitesimally thin metallic traces of\nvarious thicknesses. This file contains adjustable parameters\nto allow the dimensions and meshing fineness to be specified on the\n\ngmsh\n command line. Here are two examples:\n\n\n# square of side length 10 with 4 triangles per unit area:\n\n% gmsh -2 Rectangle.geo -o Square.msh \\\n       -setnumber Lx 10 -setnumber Ly 10 -setnumber N 4\n\n# center conductor for coplanar transmission line: width 1, length 10\n\n% gmsh -2 Rectangle.geo -o Center.msh \\\n       -setnumber Lx 1 -setnumber Ly 10 -setnumber N 4\n\n\n\n\nImplicit substrate definition files\n\n\nThe geometries we consider will consist of one or more metal\nplates lying on the upper surface of an infinite-area dielectric\nsubstrate, possibly with a perfectly-conducting ground\nplane underneath.\nThe substrate, which will be handled implicitly by \nscuff-em\n\nusing the method described \nin this memo\n\nand demonstrated \nin this example\n,\nis described by a \nsimple text file\n.\nWe will consider two substrate files: one describing a\nfreestanding finite-thickness layer of silicon \n(relative permittivity \n\\epsilon=11.7\n):\n\n\n0.0   CONST_EPS_11.7\n-1.0  VACUUM\n\n\n\n\nand one describing the same layer but now with a ground plane \nunderneath:\n\n\n0.0   CONST_EPS_11.7\n-1.0  GROUNDPLANE\n\n\n\n\nThese two files are named \nSilicon.substrate\n and \nSiliconGP.substrate\n\nand live in the \nsubstrateFiles\n subdirectory of the \npythonCapacitance\n example folder.\n\n\nParallel-plate capacitor\n\n\nOur first calculation will be for a parallel-plate capacitor consisting\nof a metal square of side length \nL\n and area \nA=L^2\n on a dielectric\nsubstrate of height \nh\n and relative permittivity \n\\epsilon\n\nlying atop a perfectly-conducting ground plane.\nNeglecting finite-size effects, the capacitance\nper unit area (in units of \n1/\\epsilon_0\n, the permittivity of free space)\nshould be\n\n \\lim_{A\\to \\infty} \\frac{C(L)}{\\epsilon_0 L^2} = \\frac{\\epsilon_r}{h}.\n\n\n\n\nFor the substrate described by the file \nSiliconGP.substrate\n \n(\nh=1, \\epsilon_r=11.7\n) we expect to find the numerical value\n\n\\lim_{L\\to \\infty} \\frac{C(L)}{\\epsilon_0 L^2} = 11.7 \\qquad\\textbf{(1)}\n\n\n\n\nHowever, the finite size of the upper plate will cause calculated\nvalues to deviate from this prediction by an amount which (for fixed \nh\n)\n\nwe expect to scale asymptotically like \n\\frac{1}{L}\n:\n\n\n \\text{for finite } L: \\,\\,\n   \\frac{C}{\\epsilon_0 L^2} = \\frac{\\epsilon_r}{h} + \\frac{\\beta}{L}\n   +\\text{higher-order terms}\n   \\qquad \\textbf{(2)}\n\n\nwhere \n\\beta\n is a constant.\nThus we will use \nscuff-em\n to compute the capacitance per\nunit area for various finite values of \nL\n, fit these data\nto the functional form \nC_0+\\beta/L\n, and identify the\nconstant \nC_0\n in the fit as the \nL\\to\\infty\n value of \nthe capacitance per unit area.\n\n\nHere's the \npython\n code named \nPPCapacitance.py\n\nthat does this. For a set of\n\nL\n values, this script \n(1)\n invokes \ngmsh\n to produce\na surface mesh for an \nL\\times L\n square, \n(2)\n calls routines\nin the \nscuff-em\n \npython\n module to get the capacitance \nmatrix for the resulting geometry. (Since the geometry only \nhas one conductor, the capacitance matrix is a \n1\\times 1\n matrix.) \nThen we use the \ncurve_fit\n\nroutine provided by \nscipy\n to fit the data to the functional\nform \n(2)\n and extract our estimate of the capacitance per\nunit area in the \nL\\to\\infty\n limit.\n\n\n##################################################\n# python code for studying finite-size capacitors in scuff-em\n# Homer Reid 20170515\n##################################################\nimport os;\nimport numpy;\nfrom scipy.optimize import curve_fit;\nimport subprocess;\nimport scuff;\n\n###################################################\n# set some environment variables so that SCUFF-EM knows where\n# to look for input files\n# (this assumes we are running from the share/examples/pythonCapacitance\n#  directory of the scuff-em installation, so that e.g.\n#  geoFiles and mshFiles are subdirectories of the current\n#  working directory; this assumption is also made by the\n#  gmsh shell commands below)\n###################################################\nos.environ[\nSCUFF_MESH_PATH\n]=\nmshFiles\n\nos.environ[\nSCUFF_GEO_PATH\n]=\nscuffgeoFiles\n\nos.environ[\nSCUFF_SUBSTRATE_PATH\n]=\nsubstrateFiles\n\n\nFineness = 3      # meshing fineness (triangle edges per unit length)\n\n###################################################\n# loop over square side lengths L\n###################################################\nLMin     = 10\nLMax     = 20\nLPoints  = 11\nLVector=[]\nCPUAVector=[]   # 'capacitance per unit area'\nDataFile = open('PPCapacitor.CvsL','w')\nDataFile.truncate();\nfor L in numpy.linspace(LMin, LMax, LPoints).tolist():\n#\n    #--------------------------------------------------\n    # run gmsh to generate mesh file for square of side L\n    #--------------------------------------------------\n    subprocess.call(['gmsh', '-2', 'geoFiles/Rectangle.geo',\n                     '-setnumber', 'LX', str(L),\n                     '-setnumber', 'LY', str(L),\n                     '-setnumber', 'N',  str(Fineness),\n                     '-o', 'mshFiles/PPCapacitor.msh'])\n#\n    #--------------------------------------------------\n    # use scuff-em to compute capacitance\n    #--------------------------------------------------\n    print \nComputing capacitance at L=\n, format(L)\n    Solver=scuff.SSSolver(\nPPCapacitor.scuffgeo\n, \nSiliconGP.substrate\n);\n    CMatrix=Solver.GetCapacitanceMatrix()\n    CPUA=CMatrix[0,0] / (L*L)\n    LVector.append(L)\n    CPUAVector.append(CPUA)\n    DataFile.write('%-10s %-10s\\n' % (format(L), format(CPUA)));\n    DataFile.flush()\n\nDataFile.close()\n\n###################################################\n# fit CPUA versus L data to the form\n#  C(L) = CInfinity + Beta/L\n###################################################\ndef FunctionalForm(L, CInf, Beta):\n    return CInf + Beta/L\n\nCInfBeta = curve_fit(FunctionalForm, LVector, CPUAVector)[0]\nCInf=CInfBeta[0]\n\nprint \n\\n*\\n*\\n\n\nprint \nCapacitance per unit area, extracted to L=infinity limit = \n, format(CInf)\n\n\n\n\n\nResults\n\n\nRunning the python script from the command line produces, eventually,\nthe following output:\n\n\n% python PPCapacitor.py\n...\n...\n...\nCapacitance per unit area, extracted to L=infinity limit =  11.764354485\n\n\n\n\nComparing against equation \n(1)\n, we see that we recover the\ncorrect theoretical value to 3 decimal places.\n\n\nAlso produced is a file named \nPPCapacitor.CvsL\n, which\ntabulates the finite-\nL\n values of the capacitance. Here's\na plot of these data, together with the fitting function\nand the \nL\\to\\infty\n extrapolation:\n\n\n\n\n(Here's the \ngnuplot\n script\n\nthat produces this plot).\n\n\nTake-home messages:\n\n\n\n\n\n\nThe \nL\\to\\infty\n extrapolation recovers the correct infinite-area \nresult to an accuracy of better than 1%.\n\n\n\n\n\n\nWithout\n this extrapolation, we would incur much more severe\nerrors. For example, if we were to approximate the \nL\\to\\infty\n\ncapacitance by the capacitance computed for the largest\nvalue of \nL\n considered here (\nL=20\n), we would incur an error\nof 9.8%, some 20\n greater than the error in the infinite-\nL\n\nextrapolation.", 
            "title": "Finite-size effects in stripline capacitors"
        }, 
        {
            "location": "/examples/pythonCapacitance/pythonCapacitance/#layout-of-input-files", 
            "text": "The input files for the calculations discussed here may be\nfound in the  share/scuff-em/examples/pythonCapacitance  subdirectory\nof your  scuff-em  installation.\nThe various files here are organized into the following subdirectories:   geoFiles :  gmsh  geometry files  mshFiles :  gmsh  mesh files  scuffgeoFiles :  scuff-em  geometry files  substrateFiles :  scuff-em  substrate-definition files", 
            "title": "Layout of input files"
        }, 
        {
            "location": "/examples/pythonCapacitance/pythonCapacitance/#customizable-gmsh-geometry-for-rectangular-plates", 
            "text": "The  geoFiles  subdirectory contains a  gmsh  geometry file named Rectangle.geo  which we will use to produce\nsurface meshes describing infinitesimally thin metallic traces of\nvarious thicknesses. This file contains adjustable parameters\nto allow the dimensions and meshing fineness to be specified on the gmsh  command line. Here are two examples:  # square of side length 10 with 4 triangles per unit area:\n\n% gmsh -2 Rectangle.geo -o Square.msh \\\n       -setnumber Lx 10 -setnumber Ly 10 -setnumber N 4\n\n# center conductor for coplanar transmission line: width 1, length 10\n\n% gmsh -2 Rectangle.geo -o Center.msh \\\n       -setnumber Lx 1 -setnumber Ly 10 -setnumber N 4", 
            "title": "Customizable gmsh geometry for rectangular plates"
        }, 
        {
            "location": "/examples/pythonCapacitance/pythonCapacitance/#implicit-substrate-definition-files", 
            "text": "The geometries we consider will consist of one or more metal\nplates lying on the upper surface of an infinite-area dielectric\nsubstrate, possibly with a perfectly-conducting ground\nplane underneath.\nThe substrate, which will be handled implicitly by  scuff-em \nusing the method described  in this memo \nand demonstrated  in this example ,\nis described by a  simple text file .\nWe will consider two substrate files: one describing a\nfreestanding finite-thickness layer of silicon \n(relative permittivity  \\epsilon=11.7 ):  0.0   CONST_EPS_11.7\n-1.0  VACUUM  and one describing the same layer but now with a ground plane \nunderneath:  0.0   CONST_EPS_11.7\n-1.0  GROUNDPLANE  These two files are named  Silicon.substrate  and  SiliconGP.substrate \nand live in the  substrateFiles  subdirectory of the  pythonCapacitance  example folder.", 
            "title": "Implicit substrate definition files"
        }, 
        {
            "location": "/examples/pythonCapacitance/pythonCapacitance/#parallel-plate-capacitor", 
            "text": "Our first calculation will be for a parallel-plate capacitor consisting\nof a metal square of side length  L  and area  A=L^2  on a dielectric\nsubstrate of height  h  and relative permittivity  \\epsilon \nlying atop a perfectly-conducting ground plane.\nNeglecting finite-size effects, the capacitance\nper unit area (in units of  1/\\epsilon_0 , the permittivity of free space)\nshould be  \\lim_{A\\to \\infty} \\frac{C(L)}{\\epsilon_0 L^2} = \\frac{\\epsilon_r}{h}.   For the substrate described by the file  SiliconGP.substrate  \n( h=1, \\epsilon_r=11.7 ) we expect to find the numerical value \\lim_{L\\to \\infty} \\frac{C(L)}{\\epsilon_0 L^2} = 11.7 \\qquad\\textbf{(1)}   However, the finite size of the upper plate will cause calculated\nvalues to deviate from this prediction by an amount which (for fixed  h ) we expect to scale asymptotically like  \\frac{1}{L} :   \\text{for finite } L: \\,\\,\n   \\frac{C}{\\epsilon_0 L^2} = \\frac{\\epsilon_r}{h} + \\frac{\\beta}{L}\n   +\\text{higher-order terms}\n   \\qquad \\textbf{(2)} \nwhere  \\beta  is a constant.\nThus we will use  scuff-em  to compute the capacitance per\nunit area for various finite values of  L , fit these data\nto the functional form  C_0+\\beta/L , and identify the\nconstant  C_0  in the fit as the  L\\to\\infty  value of \nthe capacitance per unit area.  Here's the  python  code named  PPCapacitance.py \nthat does this. For a set of L  values, this script  (1)  invokes  gmsh  to produce\na surface mesh for an  L\\times L  square,  (2)  calls routines\nin the  scuff-em   python  module to get the capacitance \nmatrix for the resulting geometry. (Since the geometry only \nhas one conductor, the capacitance matrix is a  1\\times 1  matrix.) \nThen we use the  curve_fit \nroutine provided by  scipy  to fit the data to the functional\nform  (2)  and extract our estimate of the capacitance per\nunit area in the  L\\to\\infty  limit.  ##################################################\n# python code for studying finite-size capacitors in scuff-em\n# Homer Reid 20170515\n##################################################\nimport os;\nimport numpy;\nfrom scipy.optimize import curve_fit;\nimport subprocess;\nimport scuff;\n\n###################################################\n# set some environment variables so that SCUFF-EM knows where\n# to look for input files\n# (this assumes we are running from the share/examples/pythonCapacitance\n#  directory of the scuff-em installation, so that e.g.\n#  geoFiles and mshFiles are subdirectories of the current\n#  working directory; this assumption is also made by the\n#  gmsh shell commands below)\n###################################################\nos.environ[ SCUFF_MESH_PATH ]= mshFiles \nos.environ[ SCUFF_GEO_PATH ]= scuffgeoFiles \nos.environ[ SCUFF_SUBSTRATE_PATH ]= substrateFiles \n\nFineness = 3      # meshing fineness (triangle edges per unit length)\n\n###################################################\n# loop over square side lengths L\n###################################################\nLMin     = 10\nLMax     = 20\nLPoints  = 11\nLVector=[]\nCPUAVector=[]   # 'capacitance per unit area'\nDataFile = open('PPCapacitor.CvsL','w')\nDataFile.truncate();\nfor L in numpy.linspace(LMin, LMax, LPoints).tolist():\n#\n    #--------------------------------------------------\n    # run gmsh to generate mesh file for square of side L\n    #--------------------------------------------------\n    subprocess.call(['gmsh', '-2', 'geoFiles/Rectangle.geo',\n                     '-setnumber', 'LX', str(L),\n                     '-setnumber', 'LY', str(L),\n                     '-setnumber', 'N',  str(Fineness),\n                     '-o', 'mshFiles/PPCapacitor.msh'])\n#\n    #--------------------------------------------------\n    # use scuff-em to compute capacitance\n    #--------------------------------------------------\n    print  Computing capacitance at L= , format(L)\n    Solver=scuff.SSSolver( PPCapacitor.scuffgeo ,  SiliconGP.substrate );\n    CMatrix=Solver.GetCapacitanceMatrix()\n    CPUA=CMatrix[0,0] / (L*L)\n    LVector.append(L)\n    CPUAVector.append(CPUA)\n    DataFile.write('%-10s %-10s\\n' % (format(L), format(CPUA)));\n    DataFile.flush()\n\nDataFile.close()\n\n###################################################\n# fit CPUA versus L data to the form\n#  C(L) = CInfinity + Beta/L\n###################################################\ndef FunctionalForm(L, CInf, Beta):\n    return CInf + Beta/L\n\nCInfBeta = curve_fit(FunctionalForm, LVector, CPUAVector)[0]\nCInf=CInfBeta[0]\n\nprint  \\n*\\n*\\n \nprint  Capacitance per unit area, extracted to L=infinity limit =  , format(CInf)", 
            "title": "Parallel-plate capacitor"
        }, 
        {
            "location": "/examples/pythonCapacitance/pythonCapacitance/#results", 
            "text": "Running the python script from the command line produces, eventually,\nthe following output:  % python PPCapacitor.py\n...\n...\n...\nCapacitance per unit area, extracted to L=infinity limit =  11.764354485  Comparing against equation  (1) , we see that we recover the\ncorrect theoretical value to 3 decimal places.  Also produced is a file named  PPCapacitor.CvsL , which\ntabulates the finite- L  values of the capacitance. Here's\na plot of these data, together with the fitting function\nand the  L\\to\\infty  extrapolation:   (Here's the  gnuplot  script \nthat produces this plot).  Take-home messages:    The  L\\to\\infty  extrapolation recovers the correct infinite-area \nresult to an accuracy of better than 1%.    Without  this extrapolation, we would incur much more severe\nerrors. For example, if we were to approximate the  L\\to\\infty \ncapacitance by the capacitance computed for the largest\nvalue of  L  considered here ( L=20 ), we would incur an error\nof 9.8%, some 20  greater than the error in the infinite- L \nextrapolation.", 
            "title": "Results"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/", 
            "text": "Electrostatic fields of an electrode array\n\n\n\nIn this example we use \nscuff-static\n to compute the electrostatic\nfields in the vicinity of a complicated electrode array with the\nvarious electrodes held at various external potentials.\n\n\nMore specifically, the calculation will proceed in two stages:\n\n\n\n\n\n\nFirst, for each of the \nN\n electrodes in the device\n   we will compute the fields produced by maintaining that\n   electrode at a potential of 1 volt, with all other electrodes \n   grounded.\n   This will produce \nN\n separate datasets, each reporting\n   the electrostatic potential and \nE\n-field components\n   at our desired evaluation points.\n   The \n   \nstructure of the boundary-element-method (BEM) solver implemented by \nscuff-static\n\n   ensures that this calculation is fast, even for large \nN\n:\n   once we have assembled and factorized the BEM matrix\n   for a given geometry, we can solve any number of electrostatic\n   problems involving different excitations of that geometry essentially\n   \"for free.\"\n\n\n\n\n\n\nThen we will run a second calculation in which all electrodes\n   are maintained at specific voltages and---in addition---an\n   externally-sourced electrostatic field is present. For\n   this case we will generate graphic visualization files\n   illustrating the fields in the vicinity of the device.\n\n\n\n\n\n\nThe geometry considered in this example is a model of a\n\nPaul trap\n;\nI am grateful to Anton Grounds for suggesting this\napplication and for providing the sophisticated\nparameterized \ngmsh\n file describing the geometry.\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/PaulTrap\n subdirectory\nof your \nscuff-em\n installation.\n\n\ngmsh\n geometry and mesh files\n\n\nThe \ngmsh\n\ngeometry file \nTrap.geo\n describes\na collection of conductor surfaces constituting a Paul trap.\nThis file contains a user-specifiable parameter \nELCNT\n\nthat may be used to set the number of electrodes; to create\na mesh for a 8-electrode geometry, we say\n\n\n% gmsh -2 -setnumber ELCNT 4 Trap.geo -o Trap_4.msh\n\n\n\n\n(Note that the total number of electrodes is twice the value\nspecified for \nELCNT\n).\nThis produces the \ngmsh\n mesh file \nTrap_4.msh\n, which we can\nopen in \ngmsh\n to visualize: \n\n\n% gmsh Trap_4.msh\n\n\n\n\n\n\nSimple \nscuff-em\n geometry file\n\n\nThe \ngmsh\n file \nTrap.geo\n is designed to ensure that\neach separate metallic strip in the geometry---including\neach of the 8 identically-shaped electrodes, plus each of \nthe 7 strips of varying thicknesses running down the center\nof the structure---is meshed as a separate\nentity and assigned a unique (integer) identifier. Thus, one way to\nwrite a \nscuff-em\n geometry file\n\nfor this geometry would be simply to include each of the 15\ndistinct surfaces in \nOBJECT...ENDOBJECT\n clauses, each clause\nreferencing a unique entity in the mesh. This strategy\nis pursued by the file \nTrap_4.scuffgeo\n,\nwhich looks like this:\n\n\nOBJECT GND\n    MESHFILE Trap_4.msh\n    MESHTAG 1\nENDOBJECT\n\nOBJECT Rot2\n    MESHFILE Trap_4.msh\n    MESHTAG 2\nENDOBJECT\n\nOBJECT Rot3\n    MESHFILE Trap_4.msh\n    MESHTAG 3\nENDOBJECT\n\nOBJECT RF\n    MESHFILE Trap_4.msh\n    MESHTAG 4\nENDOBJECT\n\nOBJECT Rot1\n    MESHFILE Trap_4.msh\n    MESHTAG 5\nENDOBJECT\n\nOBJECT Rot4\n    MESHFILE Trap_4.msh\n    MESHTAG 6\nENDOBJECT\n\nOBJECT UpperDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 7\nENDOBJECT\n\nOBJECT LowerDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 8\nENDOBJECT\n\nOBJECT UpperDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 9\nENDOBJECT\n\nOBJECT LowerDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 10\nENDOBJECT\n\nOBJECT UpperDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 11\nENDOBJECT\n\nOBJECT LowerDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 12\nENDOBJECT\n\nOBJECT UpperDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 13\nENDOBJECT\n\nOBJECT LowerDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 14\nENDOBJECT\n\n\n\n\nNote that, although each of the \nOBJECT\n clauses references\nthe same mesh file, the different values of the \nMESHTAG\n\nfield select distinct entities within that file, so that each\nof the 15 \nOBJECT\ns are treated by \nscuff-em\n as\n(The values of the \nMESHTAG\n identifiers are defined\nin \n.geo\n files by \ngmsh\n's \nPhysical Surface\n construct;\nsee \nTrap.geo\n for an example).\n\n\nImproved \nscuff-em\n geometry file\n\n\nThe file \nTrap_4.scuffgeo\n above defines a perfectly workable\n\nscuff-em\n geometry, and running calculations with this\nfile will yield results identical to those obtained below.\n\n\nHowever, the strategy pursued by \nTrap_4.scuffgeo\n is \nnot\n\nthe optimal way to define this geometry to \nscuff-em\n,\nbecause it ignores significant potential for computational\ncost savings afforded by the structure of the geometry.\nIndeed, as we see from the image above, the geometry\nhere contains many copies of \nidentical\n shapes that\nare simply rotated and/or translated with respect to one\nanother in space. For geometries of this sort, it\nis best \nnot\n to define separate mesh entities for each\nof the various identical copies of structures, but rather\nto inform \nscuff-em\n of the redundancies that are present\nso that the code can make maximal reuse of computations\ncarried out for identical structures.\n\n\nMore specifically, we will modify the above file as follows:\n\n\n\n\n\n\nInstead of defining each of the 8 electrodes to be a separate\nentity in the mesh, we will reference just \none\n of the electrode\nrectangles in the mesh file, together with \nDISPLACED\n statements\nindicating how identical copies of that entity are to be translated\nin space to define the 8 electrodes in the positions shown above.\n\n\n\n\n\n\nSimilarly, instead of defining separate meshed entities\nfor each of the long runners in the center of the geometry,\nwe will take advantage of the 180\n^\\circ\n rotational symmetry\nby referencing only one copy of each distinct shape\ntogether with \nROTATED\n statements indicating how identical\ncopies of that shape are to be rotated in space to define the\ndesired configuration of the runners.\n\n\n\n\n\n\nAs a result, \nscuff-em\n will need to read and store only\n5 distinct entities from the mesh file, together with\ninstructions for displacements and rotations. This is a major\nreduction in complexity from the 15 distinct mesh structures\ninvolved in the simple \n.scuffgeo\n file above. (The primary\ncomputational efficiency here is that identical mesh\nstructures--independent of displacement or rotation---contribute\nidentical diagonal blocks to the BEM system matrix; if\n\nscuff-em\n knows that an object in a geometry has 7 identical\nmates, then it need only compute the corresponding matrix\nblock \nonce\n instead of 8 times, yielding huge cost reductions.\n\nscuff-em\n also detects and exploits redundancies in \noff-diagonal\n\nmatrix blocks.)\n\n\nThe file that implements this improved strategy is \nTrap_4_Improved.scuffgeo\n,\nand it looks like this:\n\n\nOBJECT UpperDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 7\nENDOBJECT\n\nOBJECT LowerDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\nENDOBJECT\n\nOBJECT UpperDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 220 0 0 \nENDOBJECT\n\nOBJECT LowerDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\n    DISPLACED 220 0 0 \nENDOBJECT\n\nOBJECT UpperDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 440 0 0 \nENDOBJECT\n\nOBJECT LowerDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\n    DISPLACED 440 0 0 \nENDOBJECT\n\nOBJECT UpperDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 660 0 0 \nENDOBJECT\n\nOBJECT LowerDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\n    DISPLACED 660 0 0 \nENDOBJECT\n\nOBJECT GND\n    MESHFILE Trap_4.msh\n    MESHTAG 1\nENDOBJECT\n\nOBJECT Rot1\n    MESHFILE Trap_4.msh\n    MESHTAG 5\nENDOBJECT\n\nOBJECT Rot2\n    MESHFILE Trap_4.msh\n    MESHTAG 2\nENDOBJECT\n\nOBJECT Rot3\n    MESHFILE Trap_4.msh\n    MESHTAG 2\n    ROTATED 180 ABOUT 0 0 1\nENDOBJECT\n\nOBJECT Rot4\n    MESHFILE Trap_4.msh\n    MESHTAG 5\n    ROTATED 180 ABOUT 0 0 1\nENDOBJECT\n\nOBJECT RF\n    MESHFILE Trap_4.msh\n    MESHTAG 4\nENDOBJECT\n\n\n\n\nAs anticipated above, note that this file references\nonly 5 distinct \nMESHTAG\n values instead of the 15 distinct\nvalues referenced by the original \nTrap_4.scuffgeo\n file.\n\n\nVisually confirming the geometry description\n\n\nBefore proceeding, we should certainly pause to check\nthat the geometry defined by the improved geometry file\ndoes indeed look like what we want. We do this by\nrunning the \nscuff-analyze\n utility\nwith the \n--WriteGMSHFiles\n command-line option:\n\n\n% scuff-analyze --geometry Trap_4_Improved.scuffgeo --WriteGMSHFiles\n\n\n\n\nThis produces a file named \nTrap_4_Improved.pp\n, which we open\nin \ngmsh\n for visual confirmation:\n\n\n% gmsh Trap_4_Improved.pp\n\n\n\n\n\n\nPhase 1 calculation: Computing fields of individual conductors\n\n\nThe first phase of our calculation will be to determine the\nelectrostatic field configurations produced by holding each of the\nindividual electrodes at a potential of 1 V with all other electrodes\ngrounded. This will yield 8 distinct field configurations,\nwhich we can sample at an arbitrary set of evaluation points\nor visualize in graphical form; the electrostatic field\nobtained by driving all conductors with arbitrary specified\nvoltages will be a weighted linear combination of\nthese 8 configurations, so we can use the elemental fields\nto optimize a set of electrode voltages to yield a given\nfield profile (phase 2, below).\n\n\nRunning multiple calculations at once: The excitation file\n\n\nOne obvious way to do this calculation would be to run \nscuff-static\n\n8 times, each time using the \n--PotFile\n\ncommand-line option to define a different set of conductor potentials.\n\n\nHowever, such an approach would be inefficient given the structure\nof the \nboundary-element method (BEM) implemented by\n\nscuff-static\n. In BEM solvers, almost all of the\ncomputational cost goes into assembling and factorizing the\nsystem matrix, which knows only about the geometry itself\nand is \nindependent\n of any excitation that may furnish the\nstimulus in an electrostatics problem (such as externally-sourced\nfields or sets of prescribed conductor potentials).\nThus, in cases where we wish to consider the response of a\ngeometry to multiple stimuli, it is efficient to do the\ncalculations all at once; having paid the cost of forming and\nfactorizing the system matrix, we can solve electrostatics\nproblems for any number of distinct stimuli essentially \nfor free.\n\n\nTo allow this efficiency to be exploited in command-line calculations,\n\nscuff-static\n allows users to specify an\n\nexcitation file\n\ndescribing one or more stimuli to be applied to the geometry\nsequentially. For the purposes of our first calculation,\nthe excitation file will specify 8 separate stimuli, each\nconsisting of a choice of one conductor to be held at \na potential of \n1.0\n V (by default, any conductors not\nspecified are maintained at 0 V). This file is called \n\nPhase1.Excitations\n:\n\n\nEXCITATION UpperDC1\n    UpperDC1 1.0\nENDEXCITATION\n\nEXCITATION LowerDC1\n    LowerDC1 1.0\nENDEXCITATION\n\nEXCITATION UpperDC2\n    UpperDC2 1.0\nENDEXCITATION\n\nEXCITATION LowerDC2\n    LowerDC2 1.0\nENDEXCITATION\n\nEXCITATION UpperDC3\n    UpperDC3 1.0\nENDEXCITATION\n\nEXCITATION LowerDC3\n    LowerDC3 1.0\nENDEXCITATION\n\nEXCITATION UpperDC4\n    UpperDC4 1.0\nENDEXCITATION\n\nEXCITATION LowerDC4\n    LowerDC4 1.0\nENDEXCITATION\n\n\n\n\nThis file is passed to \nscuff-em\n via\nthe \n--ExcitationFile\n command-line option.\nNotice that each \nEXCITATION\n is labeled by an arbitrary user-defined\ntag, which will be used to identify the output produced under that\nexcitation.\n\n\nSpeaking of outputs, we will want to tell \nscuff-static\n what we'd\nlike it to compute for each excitation. In this case I'll ask for\ntwo types of output:\n\n\n\n\n\n\nnumerical values of the electrostatic potential and field at a set\nof evaluation points I choose; I will choose a line of points lying\nslightly above the structure and running down the center conductor.\nI put the coordinates of these points into a text file called \nMyEPFile\n\nand say \n--EPFile MyEPFile\n on the \nscuff-static\n\ncommand line.\n\n\n\n\n\n\ngraphical visualization files showing the distribution of surface charge\ninduced on the geometry by each exciting stimulus. (See below for a\ndifferent type of graphical visualization output.) To request\nthis I use the \n--PlotFile\n option to specify the visualization output\nfile name (here I call it \nMyPlotFile.pp\n).\n\n\n\n\n\n\nHere's a script \n(\nPhase1.RunScript\n)\n\nthat runs the phase-1 calculation:\n\n\n#!/bin/bash\n\nARGS=\n\nARGS=\n${ARGS} --geometry Trap_4_Improved.scuffgeo\n\nARGS=\n${ARGS} --ExcitationFile Phase1.Excitations\n\nARGS=\n${ARGS} --EPFile MyEPFile\n\nARGS=\n${ARGS} --PlotFile MyPlotFile.pp\n\nscuff-static ${ARGS}\n\n\n\n\nThis script takes about 3 seconds to run on my laptop.\nWhen it's finished, you have two new output files:\n\n\n\n\n\n\nTrap_4_Improved.MyEPFile.out\n is a text data file reporting\nvalues of the electrostatic potential and field components\nat each evaluation point in \nMyEPFile\n for each excitation.  \n\n\n\n\n\n\nMyPlotFile.pp\n is a \ngmsh\n visualization file plotting the \ninduced charge density for each of the 8 excitations. For example,\nhere's what it looks like when the electrode named \nLowerDC2\n is \ndriven:\n\n\n\n\n\n\n\n\nPhase 2 calculation: External sources and field visualization\n\n\nHaving determined the fields produced by each electrode in isolation,\nin practice we would now presumably do some sort of design calculation\nto identify the optimal voltages at which to drive each electrode\nfor our desired application. As a follow-up calculation, we'll\nnow do a run in which \n(a)\n each conductor is set to a nonzero\nvoltage, \n(b)\n additional external field sources are present, \n(c)\n\nwe wish to visualize the electrostatic fields over a region of \nspace.\n\n\nItems \n(a)\n and \n(b)\n are handled by writing an excitation\nfile \n(\nPhase2.Excitations\n)\n that specifies,\nin addition to prescribed conductor potentials, several\nexternal field sources that are also present in the geometry:\na point monopole, a point dipole, a constant electric field, and\nan arbitrary user-specified function.\n(Needless to say, this contrived assortment of sources is intended\nprimarily to illustrate the types of external-field sources\nthat may be specified in excitation files). \n\n\nEXCITATION KitchenSink\n\n# conductor potentials \n\n    UpperDC1   0.5\n    LowerDC1  -0.7\n    UpperDC2  -0.3\n    LowerDC2   0.5\n    UpperDC3   0.2\n    LowerDC3  -0.4\n    UpperDC4  -0.6\n    LowerDC4   1.0\n\n# point charge at X=(-400,1000,250) with charge -300\n    monopole -400.0 1000.0 250.0   -300\n\n# z-directed point dipole at X=(-400,-1000,-400)\n    dipole  -300.0 -1000.0 -400.0  0.0 0.0 10000.0\n\n# small constant background field in Z-direction\n    constant_field 0 0.0 1.0e-4\n\n# arbitrary user-specified function of x, y, z, r, Rho, Theta Phi\n        phi 1.0e-8*Rho*Rho*cos(2.0*Phi)\n\nENDEXCITATION\n\n\n\n\n\nItem \n(c)\n is handled by using \ngmsh\n to define a \nfield-visualization\nmesh\n---in essence, a screen on which we want an image of the electrostatic\nfield configuration, although it need not be planar---together with a\nset of [geometrical transformations] specifying how the screen is to\nbe moved throughout space to yield quasi-3D visual information on the \nfield configuration. In this case, the mesh is described by \nthe simple \ngmsh\n geometry file \nScreen.geo\n,\nwhich we turn into \nScreen.msh\n by running \ngmsh -2 Screen.geo\n,\nand the transformation file \nScreen.trans\n\nspecifies three geometrical transformations in which the screen\nis rotated and displaced to define the three walls of the diorama\nshown in the figure below.\n\n\nThe script that runs the calculation is \nPhase2.RunScript\n:\n\n\n#!/bin/bash\n\nARGS=\n\nARGS=\n${ARGS} --geometry Trap_4_Improved.scuffgeo\n\nARGS=\n${ARGS} --ExcitationFile Phase2.Excitations\n\nARGS=\n${ARGS} --FVMesh Screen.msh\n\nARGS=\n${ARGS} --FVMeshTransFile Screen.trans\n\nscuff-static ${ARGS}\n\n\n\n\nThis produces several files with extension \n.pp;\n we open them\nall simultaneously in \ngmsh\n together with the original geometry\nmesh to get some graphical insight into the spatial variation of the\nfields in our problem.\n\n\n % gmsh Trap_4*.pp Trap_4.msh\n\n\n\n\nClick the image below for higher resolution:", 
            "title": "Electrostatic fields of an electrode array"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/#simple-scuff-em-geometry-file", 
            "text": "The  gmsh  file  Trap.geo  is designed to ensure that\neach separate metallic strip in the geometry---including\neach of the 8 identically-shaped electrodes, plus each of \nthe 7 strips of varying thicknesses running down the center\nof the structure---is meshed as a separate\nentity and assigned a unique (integer) identifier. Thus, one way to\nwrite a  scuff-em  geometry file \nfor this geometry would be simply to include each of the 15\ndistinct surfaces in  OBJECT...ENDOBJECT  clauses, each clause\nreferencing a unique entity in the mesh. This strategy\nis pursued by the file  Trap_4.scuffgeo ,\nwhich looks like this:  OBJECT GND\n    MESHFILE Trap_4.msh\n    MESHTAG 1\nENDOBJECT\n\nOBJECT Rot2\n    MESHFILE Trap_4.msh\n    MESHTAG 2\nENDOBJECT\n\nOBJECT Rot3\n    MESHFILE Trap_4.msh\n    MESHTAG 3\nENDOBJECT\n\nOBJECT RF\n    MESHFILE Trap_4.msh\n    MESHTAG 4\nENDOBJECT\n\nOBJECT Rot1\n    MESHFILE Trap_4.msh\n    MESHTAG 5\nENDOBJECT\n\nOBJECT Rot4\n    MESHFILE Trap_4.msh\n    MESHTAG 6\nENDOBJECT\n\nOBJECT UpperDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 7\nENDOBJECT\n\nOBJECT LowerDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 8\nENDOBJECT\n\nOBJECT UpperDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 9\nENDOBJECT\n\nOBJECT LowerDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 10\nENDOBJECT\n\nOBJECT UpperDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 11\nENDOBJECT\n\nOBJECT LowerDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 12\nENDOBJECT\n\nOBJECT UpperDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 13\nENDOBJECT\n\nOBJECT LowerDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 14\nENDOBJECT  Note that, although each of the  OBJECT  clauses references\nthe same mesh file, the different values of the  MESHTAG \nfield select distinct entities within that file, so that each\nof the 15  OBJECT s are treated by  scuff-em  as\n(The values of the  MESHTAG  identifiers are defined\nin  .geo  files by  gmsh 's  Physical Surface  construct;\nsee  Trap.geo  for an example).", 
            "title": "Simple scuff-em geometry file"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/#improved-scuff-em-geometry-file", 
            "text": "The file  Trap_4.scuffgeo  above defines a perfectly workable scuff-em  geometry, and running calculations with this\nfile will yield results identical to those obtained below.  However, the strategy pursued by  Trap_4.scuffgeo  is  not \nthe optimal way to define this geometry to  scuff-em ,\nbecause it ignores significant potential for computational\ncost savings afforded by the structure of the geometry.\nIndeed, as we see from the image above, the geometry\nhere contains many copies of  identical  shapes that\nare simply rotated and/or translated with respect to one\nanother in space. For geometries of this sort, it\nis best  not  to define separate mesh entities for each\nof the various identical copies of structures, but rather\nto inform  scuff-em  of the redundancies that are present\nso that the code can make maximal reuse of computations\ncarried out for identical structures.  More specifically, we will modify the above file as follows:    Instead of defining each of the 8 electrodes to be a separate\nentity in the mesh, we will reference just  one  of the electrode\nrectangles in the mesh file, together with  DISPLACED  statements\nindicating how identical copies of that entity are to be translated\nin space to define the 8 electrodes in the positions shown above.    Similarly, instead of defining separate meshed entities\nfor each of the long runners in the center of the geometry,\nwe will take advantage of the 180 ^\\circ  rotational symmetry\nby referencing only one copy of each distinct shape\ntogether with  ROTATED  statements indicating how identical\ncopies of that shape are to be rotated in space to define the\ndesired configuration of the runners.    As a result,  scuff-em  will need to read and store only\n5 distinct entities from the mesh file, together with\ninstructions for displacements and rotations. This is a major\nreduction in complexity from the 15 distinct mesh structures\ninvolved in the simple  .scuffgeo  file above. (The primary\ncomputational efficiency here is that identical mesh\nstructures--independent of displacement or rotation---contribute\nidentical diagonal blocks to the BEM system matrix; if scuff-em  knows that an object in a geometry has 7 identical\nmates, then it need only compute the corresponding matrix\nblock  once  instead of 8 times, yielding huge cost reductions. scuff-em  also detects and exploits redundancies in  off-diagonal \nmatrix blocks.)  The file that implements this improved strategy is  Trap_4_Improved.scuffgeo ,\nand it looks like this:  OBJECT UpperDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 7\nENDOBJECT\n\nOBJECT LowerDC1\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\nENDOBJECT\n\nOBJECT UpperDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 220 0 0 \nENDOBJECT\n\nOBJECT LowerDC2\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\n    DISPLACED 220 0 0 \nENDOBJECT\n\nOBJECT UpperDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 440 0 0 \nENDOBJECT\n\nOBJECT LowerDC3\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\n    DISPLACED 440 0 0 \nENDOBJECT\n\nOBJECT UpperDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 660 0 0 \nENDOBJECT\n\nOBJECT LowerDC4\n    MESHFILE Trap_4.msh\n    MESHTAG 7\n    DISPLACED 0 -1656 0\n    DISPLACED 660 0 0 \nENDOBJECT\n\nOBJECT GND\n    MESHFILE Trap_4.msh\n    MESHTAG 1\nENDOBJECT\n\nOBJECT Rot1\n    MESHFILE Trap_4.msh\n    MESHTAG 5\nENDOBJECT\n\nOBJECT Rot2\n    MESHFILE Trap_4.msh\n    MESHTAG 2\nENDOBJECT\n\nOBJECT Rot3\n    MESHFILE Trap_4.msh\n    MESHTAG 2\n    ROTATED 180 ABOUT 0 0 1\nENDOBJECT\n\nOBJECT Rot4\n    MESHFILE Trap_4.msh\n    MESHTAG 5\n    ROTATED 180 ABOUT 0 0 1\nENDOBJECT\n\nOBJECT RF\n    MESHFILE Trap_4.msh\n    MESHTAG 4\nENDOBJECT  As anticipated above, note that this file references\nonly 5 distinct  MESHTAG  values instead of the 15 distinct\nvalues referenced by the original  Trap_4.scuffgeo  file.", 
            "title": "Improved scuff-em geometry file"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/#visually-confirming-the-geometry-description", 
            "text": "Before proceeding, we should certainly pause to check\nthat the geometry defined by the improved geometry file\ndoes indeed look like what we want. We do this by\nrunning the  scuff-analyze  utility\nwith the  --WriteGMSHFiles  command-line option:  % scuff-analyze --geometry Trap_4_Improved.scuffgeo --WriteGMSHFiles  This produces a file named  Trap_4_Improved.pp , which we open\nin  gmsh  for visual confirmation:  % gmsh Trap_4_Improved.pp", 
            "title": "Visually confirming the geometry description"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/#phase-1-calculation-computing-fields-of-individual-conductors", 
            "text": "The first phase of our calculation will be to determine the\nelectrostatic field configurations produced by holding each of the\nindividual electrodes at a potential of 1 V with all other electrodes\ngrounded. This will yield 8 distinct field configurations,\nwhich we can sample at an arbitrary set of evaluation points\nor visualize in graphical form; the electrostatic field\nobtained by driving all conductors with arbitrary specified\nvoltages will be a weighted linear combination of\nthese 8 configurations, so we can use the elemental fields\nto optimize a set of electrode voltages to yield a given\nfield profile (phase 2, below).", 
            "title": "Phase 1 calculation: Computing fields of individual conductors"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/#running-multiple-calculations-at-once-the-excitation-file", 
            "text": "One obvious way to do this calculation would be to run  scuff-static \n8 times, each time using the  --PotFile \ncommand-line option to define a different set of conductor potentials.  However, such an approach would be inefficient given the structure\nof the  boundary-element method (BEM) implemented by scuff-static . In BEM solvers, almost all of the\ncomputational cost goes into assembling and factorizing the\nsystem matrix, which knows only about the geometry itself\nand is  independent  of any excitation that may furnish the\nstimulus in an electrostatics problem (such as externally-sourced\nfields or sets of prescribed conductor potentials).\nThus, in cases where we wish to consider the response of a\ngeometry to multiple stimuli, it is efficient to do the\ncalculations all at once; having paid the cost of forming and\nfactorizing the system matrix, we can solve electrostatics\nproblems for any number of distinct stimuli essentially  for free.  To allow this efficiency to be exploited in command-line calculations, scuff-static  allows users to specify an excitation file \ndescribing one or more stimuli to be applied to the geometry\nsequentially. For the purposes of our first calculation,\nthe excitation file will specify 8 separate stimuli, each\nconsisting of a choice of one conductor to be held at \na potential of  1.0  V (by default, any conductors not\nspecified are maintained at 0 V). This file is called  Phase1.Excitations :  EXCITATION UpperDC1\n    UpperDC1 1.0\nENDEXCITATION\n\nEXCITATION LowerDC1\n    LowerDC1 1.0\nENDEXCITATION\n\nEXCITATION UpperDC2\n    UpperDC2 1.0\nENDEXCITATION\n\nEXCITATION LowerDC2\n    LowerDC2 1.0\nENDEXCITATION\n\nEXCITATION UpperDC3\n    UpperDC3 1.0\nENDEXCITATION\n\nEXCITATION LowerDC3\n    LowerDC3 1.0\nENDEXCITATION\n\nEXCITATION UpperDC4\n    UpperDC4 1.0\nENDEXCITATION\n\nEXCITATION LowerDC4\n    LowerDC4 1.0\nENDEXCITATION  This file is passed to  scuff-em  via\nthe  --ExcitationFile  command-line option.\nNotice that each  EXCITATION  is labeled by an arbitrary user-defined\ntag, which will be used to identify the output produced under that\nexcitation.  Speaking of outputs, we will want to tell  scuff-static  what we'd\nlike it to compute for each excitation. In this case I'll ask for\ntwo types of output:    numerical values of the electrostatic potential and field at a set\nof evaluation points I choose; I will choose a line of points lying\nslightly above the structure and running down the center conductor.\nI put the coordinates of these points into a text file called  MyEPFile \nand say  --EPFile MyEPFile  on the  scuff-static \ncommand line.    graphical visualization files showing the distribution of surface charge\ninduced on the geometry by each exciting stimulus. (See below for a\ndifferent type of graphical visualization output.) To request\nthis I use the  --PlotFile  option to specify the visualization output\nfile name (here I call it  MyPlotFile.pp ).    Here's a script  ( Phase1.RunScript ) \nthat runs the phase-1 calculation:  #!/bin/bash\n\nARGS= \nARGS= ${ARGS} --geometry Trap_4_Improved.scuffgeo \nARGS= ${ARGS} --ExcitationFile Phase1.Excitations \nARGS= ${ARGS} --EPFile MyEPFile \nARGS= ${ARGS} --PlotFile MyPlotFile.pp \nscuff-static ${ARGS}  This script takes about 3 seconds to run on my laptop.\nWhen it's finished, you have two new output files:    Trap_4_Improved.MyEPFile.out  is a text data file reporting\nvalues of the electrostatic potential and field components\nat each evaluation point in  MyEPFile  for each excitation.      MyPlotFile.pp  is a  gmsh  visualization file plotting the \ninduced charge density for each of the 8 excitations. For example,\nhere's what it looks like when the electrode named  LowerDC2  is \ndriven:", 
            "title": "Running multiple calculations at once: The excitation file"
        }, 
        {
            "location": "/examples/PaulTrap/PaulTrap/#phase-2-calculation-external-sources-and-field-visualization", 
            "text": "Having determined the fields produced by each electrode in isolation,\nin practice we would now presumably do some sort of design calculation\nto identify the optimal voltages at which to drive each electrode\nfor our desired application. As a follow-up calculation, we'll\nnow do a run in which  (a)  each conductor is set to a nonzero\nvoltage,  (b)  additional external field sources are present,  (c) \nwe wish to visualize the electrostatic fields over a region of \nspace.  Items  (a)  and  (b)  are handled by writing an excitation\nfile  ( Phase2.Excitations )  that specifies,\nin addition to prescribed conductor potentials, several\nexternal field sources that are also present in the geometry:\na point monopole, a point dipole, a constant electric field, and\nan arbitrary user-specified function.\n(Needless to say, this contrived assortment of sources is intended\nprimarily to illustrate the types of external-field sources\nthat may be specified in excitation files).   EXCITATION KitchenSink\n\n# conductor potentials \n\n    UpperDC1   0.5\n    LowerDC1  -0.7\n    UpperDC2  -0.3\n    LowerDC2   0.5\n    UpperDC3   0.2\n    LowerDC3  -0.4\n    UpperDC4  -0.6\n    LowerDC4   1.0\n\n# point charge at X=(-400,1000,250) with charge -300\n    monopole -400.0 1000.0 250.0   -300\n\n# z-directed point dipole at X=(-400,-1000,-400)\n    dipole  -300.0 -1000.0 -400.0  0.0 0.0 10000.0\n\n# small constant background field in Z-direction\n    constant_field 0 0.0 1.0e-4\n\n# arbitrary user-specified function of x, y, z, r, Rho, Theta Phi\n        phi 1.0e-8*Rho*Rho*cos(2.0*Phi)\n\nENDEXCITATION  Item  (c)  is handled by using  gmsh  to define a  field-visualization\nmesh ---in essence, a screen on which we want an image of the electrostatic\nfield configuration, although it need not be planar---together with a\nset of [geometrical transformations] specifying how the screen is to\nbe moved throughout space to yield quasi-3D visual information on the \nfield configuration. In this case, the mesh is described by \nthe simple  gmsh  geometry file  Screen.geo ,\nwhich we turn into  Screen.msh  by running  gmsh -2 Screen.geo ,\nand the transformation file  Screen.trans \nspecifies three geometrical transformations in which the screen\nis rotated and displaced to define the three walls of the diorama\nshown in the figure below.  The script that runs the calculation is  Phase2.RunScript :  #!/bin/bash\n\nARGS= \nARGS= ${ARGS} --geometry Trap_4_Improved.scuffgeo \nARGS= ${ARGS} --ExcitationFile Phase2.Excitations \nARGS= ${ARGS} --FVMesh Screen.msh \nARGS= ${ARGS} --FVMeshTransFile Screen.trans \nscuff-static ${ARGS}  This produces several files with extension  .pp;  we open them\nall simultaneously in  gmsh  together with the original geometry\nmesh to get some graphical insight into the spatial variation of the\nfields in our problem.   % gmsh Trap_4*.pp Trap_4.msh  Click the image below for higher resolution:", 
            "title": "Phase 2 calculation: External sources and field visualization"
        }, 
        {
            "location": "/reference/TopLevel/", 
            "text": "Top-level overview of \nscuff-em\n\n\nscuff-em\n is a free, open-source software \nimplementation of the boundary-element method (BEM)\n(or the \"method of moments\") of electromagnetic\nscattering. (More specifically, \nscuff-em\n\nimplements the EFIE and PMCHWT formulations\nof the BEM using RWG basis functions.)\n\n\nscuff-em\n originated as a specialized tool\nfor using BEM techniques to model\nfluctuation-induced electromagnetic phenomena---such as\n\nCasimir forces\n\nand\n\nradiative heat transfer\n---and \nsubsequently expanded into a general-purpose BEM solver targeting a\nvariety of applications in nanophotonics.\n\n\nscuff-em\n consists of a \ncore library\n,\nimplementing the basic BEM functionality, plus a large number \nof specialized \napplication modules\n \ndesigned for specific problems in science and engineering.\n\n\nscuff-em\n stands for \nS\nurface \nCU\nrrent/\nF\nield \nF\normulation of \n\nE\nlectro\nM\nagnetism. This is a reference to the underlying solution \nmethodology used by \nscuff-em\n and other BEM solvers, in which we solve \nfirst for surface currents [including both electric (\nK\n) and \nmagnetic (\nN\n) currents, as cartooned in the \nscuff-em\n logo], \nthen use these currents to compute the scattered fields or other \nquantities of interest.\n\n\nThe entire \nscuff-em\n suite is free software distributed \nunder the \nGNU GPL\n. The source code for \nscuff-em\n \nmay be downloaded from the \n\nscuff-em\n GitHub page\n. \n\nThe GitHub page is also the right place for questions, \nbug reports, feature requests, and other discussion of \nscuff-em\n.\n\n\nFor commercial support and consulting services\nrelated to \nscuff-em\n, please contact \n\nSIMPETUS Inc.\n\n\nInterfaces to \nscuff-em\n\n\nAccess to the \nscuff-em\n computational engine is available\nvia multiple interfaces.\n\n\nThe \ncommand-line interface\n consists of a large number\nof \ncommand-line applications\n for\nrunning various types of standard calculations in computational\nphysics. Using \nscuff-em\n in this way requires only\nthat you learn the basic command-line options\n\n\nThe \napplication programming interface\n consists of \n\nC++ and python APIs\n\nthat allow access to internal \nscuff-em\n data structures\nand methods for maximal flexibility in implementing your\nown custom-designed physics codes.\n\n\nInputs to \nscuff-em\n calculations\n\n\nTypical inputs to \nscuff-em\n calculations include\n\n\n\n\n\n\nA \ngeometry file\n describing the scattering geometry\n\n\n\n\n\n\nAn optional \nlist of geometric transformations\n \n  to be applied to the geometry, with calculations generally repeated\n  at each transformation\n\n\n\n\n\n\nSpecification of the frequencies (and, for extended geometries,\n  the Bloch vectors) at which you want to perform calculations\n\n\n\n\n\n\nFor scattering codes: a specification of the \n  [incident fields][IncidentFields.md].\n\n\n\n\n\n\nSpecifications of the output quantities you wish to get back: \n  field components at individual points in space, power/force/torque\n  information, Casimir quantities, heat-transfer rates, impedance \n  parameters, capacitances, polarizabilities, etc.\n\n\n\n\n\n\nOutputs from \nscuff-em\n calculations\n\n\nTypical outputs from \nscuff-em\n calculations include\n\n\n\n\n\n\ntext-based data files reporting output quantities\n\n\n\n\n\n\nVisualization files written in \n  \nGMSH\n post-processing\n  format.\n\n\n\n\n\n\n\n\nCommand-line Applications\n\n\nNanophotonics / electromagnetic scattering\n\n\n\n\n\n\nscuff-scatter\n\n\n\n\nA general-purpose solver forproblems involving\nAvailable outputs include: scattered and total fields\nat arbitrary points in space; visualization of fields \nand surface currents; absorbed and scattered power;\nforce and torque (radiation pressure); induced dipole\nor spherical multipole moments; and more.\n\n\n\n\n\n\n\n\n\nscuff-transmission\n\n\n\n\nA specialized solver for computing plane-wave transmission\nin 2D extended geometries: thin films, perforated screens,\nnanoparticle arrays, etc. \n\n\n\n\n\n\n\n\nscuff-tmatrix\n\n\n\n\nA specialized code for computing the\n\nT-matrices\n\nof arbitrary compact scatterers.\n\n\n\n\n\n\n\n\nFluctuation-induced interactions\n\n\n\n\n\n\nscuff-cas3D\n\n\n\n\nAn implementation of the \n[fluctuating-surface-current approach to equilibrium Casimir forces][FSCPaper] \nin compact or extended geometries.\n\n\n\n\n\n\n\n\nscuff-caspol\n\n\n\n\nA tool for computing Casimir-Polder potentials for\npolarizable molecules in the vicinity of compact or \nextended material bodies.\n\n\n\n\n\n\n\n\nscuff-neq\n\n\n\n\nAn implementation of the fluctuating-surface-current\napproach to non-equilibrium fluctuation-induced\ninteractions among compact objects.\nAvailable outputs include: frequency-resolved or \nfrequency-integrated rates of heat radiation or \nradiative heat transfer; non-equilibrium Casimir \nforces; self-propulsion and self-rotation of \nisolated bodies.\n\n\n\n\n\n\n\n\nRF / microwave engineering\n\n\n\n\nscuff-RF\n\n\nA tool for modeling the electromagnetic properties of \npassive RF devices such as antennas and inductors.\nAvailable outputs include: frequency-dependent\nS-parameters for arbitrarily-shaped objects;\nradiated field patterns for antennas or other objects\ndriven by user-specified currents.\n\n\n\n\n\n\n\n\nElectrostatics\n\n\n\n\n[\nscuff-static\n][scuff-static]\n\n\nAn electrostatic solver. \nAvailable outputs include: self- and mutual-capacitances\nof arbitrarily-shaped conductors ; DC polarizabilities of\nconducting and dielectric bodies; electrostatic fields\n(at user-specified evaluation points) in the presence \nof conducting surfaces held at user-specified potentials.\n\n\n\n\n\n\n\n\nCiting \nscuff-em\n\n\nIf you find \nscuff-em\n useful for generating\nresults included in publications, please consider citing both \n\n(a)\n one of the papers discussing the implementation of\n\nscuff-em\n, and \n\n(b)\n the URL for the code. For example, if you are writing\nin LaTeX, you might write something like this:\n\n\nNumerical computations were performed using {\\sc scuff-em}, a free,\nopen-source software implementation of the boundary-element \nmethod~\\cite{SCUFF1, SCUFF2}.\n\n\n\n\nHere the \nSCUFF1\n and \nSCUFF2\n\nreferences refer to the following \n.bibtex\n entries:\n\n\n@ARTICLE{SCUFF1,\nauthor = {{Homer Reid}, M.~T. and {Johnson}, S.~G.},\ntitle = \n{Efficient Computation of Power, Force, and Torque in \nBEM Scattering Calculations}\n,\njournal = {ArXiv e-prints},\narchivePrefix = \narXiv\n,\neprint = {1307.2966},\nprimaryClass = \nphysics.comp-ph\n,\nkeywords = {Physics - Computational Physics, Physics - Classical Physics},\nyear = 2013,\nmonth = jul,\n}\n\n@ARTICLE{SCUFF2,\nnote=\n\\texttt{http://github.com/homerreid/scuff-EM}\n\n}\n\n\n\n\n[scuff-static]              ../applications/scuff-static/scuff-static.md", 
            "title": "Top-level overview"
        }, 
        {
            "location": "/reference/TopLevel/#interfaces-to-scuff-em", 
            "text": "Access to the  scuff-em  computational engine is available\nvia multiple interfaces.  The  command-line interface  consists of a large number\nof  command-line applications  for\nrunning various types of standard calculations in computational\nphysics. Using  scuff-em  in this way requires only\nthat you learn the basic command-line options  The  application programming interface  consists of  C++ and python APIs \nthat allow access to internal  scuff-em  data structures\nand methods for maximal flexibility in implementing your\nown custom-designed physics codes.", 
            "title": "Interfaces to scuff-em"
        }, 
        {
            "location": "/reference/TopLevel/#inputs-to-scuff-em-calculations", 
            "text": "Typical inputs to  scuff-em  calculations include    A  geometry file  describing the scattering geometry    An optional  list of geometric transformations  \n  to be applied to the geometry, with calculations generally repeated\n  at each transformation    Specification of the frequencies (and, for extended geometries,\n  the Bloch vectors) at which you want to perform calculations    For scattering codes: a specification of the \n  [incident fields][IncidentFields.md].    Specifications of the output quantities you wish to get back: \n  field components at individual points in space, power/force/torque\n  information, Casimir quantities, heat-transfer rates, impedance \n  parameters, capacitances, polarizabilities, etc.", 
            "title": "Inputs to scuff-em calculations"
        }, 
        {
            "location": "/reference/TopLevel/#outputs-from-scuff-em-calculations", 
            "text": "Typical outputs from  scuff-em  calculations include    text-based data files reporting output quantities    Visualization files written in \n   GMSH  post-processing\n  format.", 
            "title": "Outputs from scuff-em calculations"
        }, 
        {
            "location": "/reference/TopLevel/#command-line-applications", 
            "text": "", 
            "title": "Command-line Applications"
        }, 
        {
            "location": "/reference/TopLevel/#nanophotonics-electromagnetic-scattering", 
            "text": "scuff-scatter   A general-purpose solver forproblems involving\nAvailable outputs include: scattered and total fields\nat arbitrary points in space; visualization of fields \nand surface currents; absorbed and scattered power;\nforce and torque (radiation pressure); induced dipole\nor spherical multipole moments; and more.     scuff-transmission   A specialized solver for computing plane-wave transmission\nin 2D extended geometries: thin films, perforated screens,\nnanoparticle arrays, etc.      scuff-tmatrix   A specialized code for computing the T-matrices \nof arbitrary compact scatterers.", 
            "title": "Nanophotonics / electromagnetic scattering"
        }, 
        {
            "location": "/reference/TopLevel/#fluctuation-induced-interactions", 
            "text": "scuff-cas3D   An implementation of the \n[fluctuating-surface-current approach to equilibrium Casimir forces][FSCPaper] \nin compact or extended geometries.     scuff-caspol   A tool for computing Casimir-Polder potentials for\npolarizable molecules in the vicinity of compact or \nextended material bodies.     scuff-neq   An implementation of the fluctuating-surface-current\napproach to non-equilibrium fluctuation-induced\ninteractions among compact objects.\nAvailable outputs include: frequency-resolved or \nfrequency-integrated rates of heat radiation or \nradiative heat transfer; non-equilibrium Casimir \nforces; self-propulsion and self-rotation of \nisolated bodies.", 
            "title": "Fluctuation-induced interactions"
        }, 
        {
            "location": "/reference/TopLevel/#rf-microwave-engineering", 
            "text": "scuff-RF  A tool for modeling the electromagnetic properties of \npassive RF devices such as antennas and inductors.\nAvailable outputs include: frequency-dependent\nS-parameters for arbitrarily-shaped objects;\nradiated field patterns for antennas or other objects\ndriven by user-specified currents.", 
            "title": "RF / microwave engineering"
        }, 
        {
            "location": "/reference/TopLevel/#electrostatics", 
            "text": "[ scuff-static ][scuff-static]  An electrostatic solver. \nAvailable outputs include: self- and mutual-capacitances\nof arbitrarily-shaped conductors ; DC polarizabilities of\nconducting and dielectric bodies; electrostatic fields\n(at user-specified evaluation points) in the presence \nof conducting surfaces held at user-specified potentials.", 
            "title": "Electrostatics"
        }, 
        {
            "location": "/reference/TopLevel/#citing-scuff-em", 
            "text": "If you find  scuff-em  useful for generating\nresults included in publications, please consider citing both  (a)  one of the papers discussing the implementation of scuff-em , and  (b)  the URL for the code. For example, if you are writing\nin LaTeX, you might write something like this:  Numerical computations were performed using {\\sc scuff-em}, a free,\nopen-source software implementation of the boundary-element \nmethod~\\cite{SCUFF1, SCUFF2}.  Here the  SCUFF1  and  SCUFF2 \nreferences refer to the following  .bibtex  entries:  @ARTICLE{SCUFF1,\nauthor = {{Homer Reid}, M.~T. and {Johnson}, S.~G.},\ntitle =  {Efficient Computation of Power, Force, and Torque in \nBEM Scattering Calculations} ,\njournal = {ArXiv e-prints},\narchivePrefix =  arXiv ,\neprint = {1307.2966},\nprimaryClass =  physics.comp-ph ,\nkeywords = {Physics - Computational Physics, Physics - Classical Physics},\nyear = 2013,\nmonth = jul,\n}\n\n@ARTICLE{SCUFF2,\nnote= \\texttt{http://github.com/homerreid/scuff-EM} \n}  [scuff-static]              ../applications/scuff-static/scuff-static.md", 
            "title": "Citing scuff-em"
        }, 
        {
            "location": "/reference/Installing/", 
            "text": "Installing \nscuff-em\n\n\n0. Try \nscuff-em\n online before installing anything!\n\n\nJohannes Feist\n has set up\nan interactive online notebook using \nMyBinder\n\nthat you can use to run some simple \nscuff-em\n calculations on\nthe cloud without having to install anything. This free service\noffers limited computing power, so you won't want to attempt any\nheavy calculations here, but you can follow Johannes' tutorial\nto observe the flow of a typical \nscuff-em\n calculation,\nplay around with your own calculations, and get a feel for what \nusing \nscuff-em\n will like once you have installed it on your \nmachine.\n\n\nHere's the link:\n\nhttp://mybinder.org/repo/jfeist/scuff-em-mybinder\n.\n\n\n1. External packages\n\n\nscuff-em\n relies on a small number of well-established free \nsoftware packages to implement certain non-essential functionality. \n\nscuff-em\n can be compiled and installed without any of these packages, \nbut in this case the code will be somewhat crippled.\n\n\n\n\n\n\nIf you actually want to solve scattering problems (instead of \n  just setting them up), you will need\n  \nLAPACK/BLAS\n.\n\n\n\n\n\n\nIf you want the capacity to write output files in the \n  standard HDF5 binary format, you will need\n  \nHDF5\n.\n\n\n\n\n\n\nIf you want to compile the \npython\n interface, you will need the\n  \npython\n development files.\n\n\n\n\n\n\nAlthough not required to install, compile, or use\n  \nscuff-em\n,\n  \ngmsh\n\n  is an extremely valuable open-source meshing and visualization\n  tool that is used throughout the\n  \nscuff-em\n documentation.\n\n\n\n\n\n\nOn Debian/Ubuntu Linux systems, you can fetch all of these packages by doing a \n\n\n% sudo apt-get install liblapack-dev libblas-dev libhdf5-serial-dev python-dev gmsh\n\n\n\n\n\n\nNote: In some cases it seems the \ngmsh\n package conflicts with \nthe \nlibhdf5-serial-dev\n package. In this case, just \nremove \ngmsh\n from the above \napt-get\n statement; you can \ninstall it by hand following the instructions\non the \nGMSH website\n.\n(Note that \ngmsh\n, though very useful, \nis not necessary to compile or run \nscuff-em\n.)\n\n\n\n\n2. Cloning the GitHub repository and building the code\n\n\nscuff-em\n is hosted on \nGitHub\n.\nThe current build status of the \nscuff-em\n master branch is:\n\n\n\n\nTo fetch and install the latest version of the \ncode, execute the following steps. (Replace the string\n\n/path/to/scuff-em-installation-directory\n\nwith your desired installation directory.)\n\n\n% git clone https://homerreid@github.com/HomerReid/scuff-em.git\n% cd scuff-em\n% sh autogen.sh --prefix=/path/to/scuff-em-installation-directory\n% make install\n\n\n\n\nIf this succeeds, the executable versions of the application\nprograms (such as \nscuff-scatter\n, \nscuff-rf\n, etc.) will be \ninstalled in the directory \nPREFIX/bin/\n \nand the demonstration examples for the various application programs \nwill be in \nPREFIX/share/scuff-em/examples\n\n(where \nPREFIX\n is the directory you specified using the \n\n--prefix\n option above).\n\n\nIf you have trouble installing \nscuff-em\n,\nplease file an issue on the \n\nscuff-em\n GitHub page\n.\n\n\nBuild options\n\n\nYou may specify options to the \nautogen.sh\n\n(or \nconfigure\n) command to guide the compilation process. \nFor a full list of available options,\ntype \nconfigure --help.\n Here we summarize some of the\nmore salient possibilities.\n\n\n\n\nMultithreading: \nopenmp\n vs. \npthreads\n\n\nThe \nscuff-em\n core library \nuses multithreading for all steps in the\n\nmain flow\n of\nthe BEM scattering procedure. You can use \nconfigure\n\noptions to select whether this multithreading is implemented\nusing \nopenmp\n or \npthreads\n. The former is the default,\nwhile the latter may be enabled like this:\n\n\n% ./configure --without-openmp --with-pthreads\n\n\n\n\nThe default \nopenmp\n\nmultithreading tends to play better with other multithreaded \nsoftware packages and is definitely the right choice if you \nwill be operating on a shared machine with some CPU cores \noccupied by other users. \n(You can monitor performance by inspecting\n\n.log\n files\n.\n\n\nSupport for \npthreads\n\nis a legacy feature that will be discontinued in future versions of \n\nscuff-em\n.\n\n\nNote: in some cases you may need to tweak certain environment \nvariables to achieve maximal \n\nopenmp\n performance.\nFor example, on my workstation (which has 8 CPU cores),\nin order to get \nopenmp\n codes\nto use all 8 cores I need to set the following environment\nvariable:\n\n\n% export GOMP_CPU_AFFINITY=0-7\n\n\n\n\n\n\nDisabling the python interface to speed the build process\n\n\nCompiling the python interface is slow---it accounts for\nmore than half of the build time on some systems.\nIf you don't need the python interface to \nscuff-em\n,\nuse the option \n--without-python\n when running \nconfigure\n\nto accelerate the build process.\n\n\n\n\nBuilding for debugging\n\n\nIf you would like to run \nscuff-em\n API codes in a debugger\nlike \ngdb\n,\nyou will want to modify the build options to \n(a)\n include\ndebugging symbols, \n(b)\n turn off optimization, \n(c)\n\ndisable \nopenmp\n multithreading, which does not play well\nwith \nGDB\n. \n\n\nHere is the script that works for me to achieve these goals:\n\n\n#!/bin/bash\n\nCC=\ngcc -ggdb -O0\n\nCXX=\ng++ -ggdb -O0\n\nexport CFLAGS=\n-O0\n\nexport CXXFLAGS=\n-O0\n\nsh autogen.sh --enable-debug --without-openmp --disable-shared\n\n\n\n\n(It shouldn't be necessary to have to add \n-O0\n to both the\nenvironment variables and the compiler command lines, but\nthis seems to be the only way things work for me.)\n\n\nAfter running this script to reconfigure for building with\ncompiling support, you will want to \nmake clean; make\n\nto rebuild everything with debugging support. Of course,\nafter you are finished debugging you will need to reconfigure\nwith debugging support removed and then re-do the \nclean build. Because this is time-consuming, I typically\nmaintain two separate copies of the code base, one for\ndebugging and one for running at full speed.\n\n\nOnce debugging support has been added, you can run \nthe code in \ngdb\n. Here's a sample session:\n\n\n % gdb /path/to/debug/repository/bin/scuff-ldos\n\n (gdb) set args \n scuff-ldos.args\n\n (gdb) break GetHalfSpaceDGFs\nBreakpoint 1 at 0x409626: file AnalyticalDGFs.cc, line 217.\n\n (gdb) run\n\nBreakpoint 1, GetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, \n    zp=0.10000000000000001, LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, \n    AbsTol=1e-10, MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:217\n\n217   double BZVolume=GetRLBasis(LBasis, RLBasis);\n\n(gdb) print Omega\n$1 = {_M_value = 0.10000000000000001 + 0 * I}\n\n(gdb) u 230\n\nGetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, zp=0.10000000000000001, \n    LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, AbsTol=1e-10, \n    MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:230\n\n230   cdouble Sum[18];\n\n(gdb) print Data-\nEpsilon\n$2 = {_M_value = -45765.335680436379 + 115960.58424811834 * I}\n\n\n\n\nNote\n: If you have a better debugging solution that \ndoes not require steps \n(b)\n and/or \n(c)\n above , please\nlet me know about it. It stinks to have to run the codes\nat greatly reduced speed when debugging, because often the\nproblem spots lie after expensive sections like BEM matrix\nassembly, and then it takes forever for the code to run\nin the debugger to get there.", 
            "title": "Installation"
        }, 
        {
            "location": "/reference/Installing/#0-try-scuff-em-online-before-installing-anything", 
            "text": "Johannes Feist  has set up\nan interactive online notebook using  MyBinder \nthat you can use to run some simple  scuff-em  calculations on\nthe cloud without having to install anything. This free service\noffers limited computing power, so you won't want to attempt any\nheavy calculations here, but you can follow Johannes' tutorial\nto observe the flow of a typical  scuff-em  calculation,\nplay around with your own calculations, and get a feel for what \nusing  scuff-em  will like once you have installed it on your \nmachine.  Here's the link: http://mybinder.org/repo/jfeist/scuff-em-mybinder .", 
            "title": "0. Try scuff-em online before installing anything!"
        }, 
        {
            "location": "/reference/Installing/#1-external-packages", 
            "text": "scuff-em  relies on a small number of well-established free \nsoftware packages to implement certain non-essential functionality.  scuff-em  can be compiled and installed without any of these packages, \nbut in this case the code will be somewhat crippled.    If you actually want to solve scattering problems (instead of \n  just setting them up), you will need\n   LAPACK/BLAS .    If you want the capacity to write output files in the \n  standard HDF5 binary format, you will need\n   HDF5 .    If you want to compile the  python  interface, you will need the\n   python  development files.    Although not required to install, compile, or use\n   scuff-em ,\n   gmsh \n  is an extremely valuable open-source meshing and visualization\n  tool that is used throughout the\n   scuff-em  documentation.    On Debian/Ubuntu Linux systems, you can fetch all of these packages by doing a   % sudo apt-get install liblapack-dev libblas-dev libhdf5-serial-dev python-dev gmsh   Note: In some cases it seems the  gmsh  package conflicts with \nthe  libhdf5-serial-dev  package. In this case, just \nremove  gmsh  from the above  apt-get  statement; you can \ninstall it by hand following the instructions\non the  GMSH website .\n(Note that  gmsh , though very useful, \nis not necessary to compile or run  scuff-em .)", 
            "title": "1. External packages"
        }, 
        {
            "location": "/reference/Installing/#2-cloning-the-github-repository-and-building-the-code", 
            "text": "scuff-em  is hosted on  GitHub .\nThe current build status of the  scuff-em  master branch is:   To fetch and install the latest version of the \ncode, execute the following steps. (Replace the string /path/to/scuff-em-installation-directory \nwith your desired installation directory.)  % git clone https://homerreid@github.com/HomerReid/scuff-em.git\n% cd scuff-em\n% sh autogen.sh --prefix=/path/to/scuff-em-installation-directory\n% make install  If this succeeds, the executable versions of the application\nprograms (such as  scuff-scatter ,  scuff-rf , etc.) will be \ninstalled in the directory  PREFIX/bin/  \nand the demonstration examples for the various application programs \nwill be in  PREFIX/share/scuff-em/examples \n(where  PREFIX  is the directory you specified using the  --prefix  option above).  If you have trouble installing  scuff-em ,\nplease file an issue on the  scuff-em  GitHub page .", 
            "title": "2. Cloning the GitHub repository and building the code"
        }, 
        {
            "location": "/reference/Installing/#build-options", 
            "text": "You may specify options to the  autogen.sh \n(or  configure ) command to guide the compilation process. \nFor a full list of available options,\ntype  configure --help.  Here we summarize some of the\nmore salient possibilities.", 
            "title": "Build options"
        }, 
        {
            "location": "/reference/Installing/#multithreading-openmp-vs-pthreads", 
            "text": "The  scuff-em  core library \nuses multithreading for all steps in the main flow  of\nthe BEM scattering procedure. You can use  configure \noptions to select whether this multithreading is implemented\nusing  openmp  or  pthreads . The former is the default,\nwhile the latter may be enabled like this:  % ./configure --without-openmp --with-pthreads  The default  openmp \nmultithreading tends to play better with other multithreaded \nsoftware packages and is definitely the right choice if you \nwill be operating on a shared machine with some CPU cores \noccupied by other users. \n(You can monitor performance by inspecting .log  files .  Support for  pthreads \nis a legacy feature that will be discontinued in future versions of  scuff-em .  Note: in some cases you may need to tweak certain environment \nvariables to achieve maximal  openmp  performance.\nFor example, on my workstation (which has 8 CPU cores),\nin order to get  openmp  codes\nto use all 8 cores I need to set the following environment\nvariable:  % export GOMP_CPU_AFFINITY=0-7", 
            "title": "Multithreading: openmp vs. pthreads"
        }, 
        {
            "location": "/reference/Installing/#disabling-the-python-interface-to-speed-the-build-process", 
            "text": "Compiling the python interface is slow---it accounts for\nmore than half of the build time on some systems.\nIf you don't need the python interface to  scuff-em ,\nuse the option  --without-python  when running  configure \nto accelerate the build process.", 
            "title": "Disabling the python interface to speed the build process"
        }, 
        {
            "location": "/reference/Installing/#building-for-debugging", 
            "text": "If you would like to run  scuff-em  API codes in a debugger\nlike  gdb ,\nyou will want to modify the build options to  (a)  include\ndebugging symbols,  (b)  turn off optimization,  (c) \ndisable  openmp  multithreading, which does not play well\nwith  GDB .   Here is the script that works for me to achieve these goals:  #!/bin/bash\n\nCC= gcc -ggdb -O0 \nCXX= g++ -ggdb -O0 \nexport CFLAGS= -O0 \nexport CXXFLAGS= -O0 \nsh autogen.sh --enable-debug --without-openmp --disable-shared  (It shouldn't be necessary to have to add  -O0  to both the\nenvironment variables and the compiler command lines, but\nthis seems to be the only way things work for me.)  After running this script to reconfigure for building with\ncompiling support, you will want to  make clean; make \nto rebuild everything with debugging support. Of course,\nafter you are finished debugging you will need to reconfigure\nwith debugging support removed and then re-do the \nclean build. Because this is time-consuming, I typically\nmaintain two separate copies of the code base, one for\ndebugging and one for running at full speed.  Once debugging support has been added, you can run \nthe code in  gdb . Here's a sample session:   % gdb /path/to/debug/repository/bin/scuff-ldos\n\n (gdb) set args   scuff-ldos.args\n\n (gdb) break GetHalfSpaceDGFs\nBreakpoint 1 at 0x409626: file AnalyticalDGFs.cc, line 217.\n\n (gdb) run\n\nBreakpoint 1, GetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, \n    zp=0.10000000000000001, LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, \n    AbsTol=1e-10, MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:217\n\n217   double BZVolume=GetRLBasis(LBasis, RLBasis);\n\n(gdb) print Omega\n$1 = {_M_value = 0.10000000000000001 + 0 * I}\n\n(gdb) u 230\n\nGetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, zp=0.10000000000000001, \n    LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, AbsTol=1e-10, \n    MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:230\n\n230   cdouble Sum[18];\n\n(gdb) print Data- Epsilon\n$2 = {_M_value = -45765.335680436379 + 115960.58424811834 * I}  Note : If you have a better debugging solution that \ndoes not require steps  (b)  and/or  (c)  above , please\nlet me know about it. It stinks to have to run the codes\nat greatly reduced speed when debugging, because often the\nproblem spots lie after expensive sections like BEM matrix\nassembly, and then it takes forever for the code to run\nin the debugger to get there.", 
            "title": "Building for debugging"
        }, 
        {
            "location": "/reference/Geometries/", 
            "text": "Geometry Descriptions in \nscuff-em\n\n\nGeometries in \nscuff-em\n are described by simple text files \nthat are conventionally given the file extension \n.scuffgeo.\n \nThe \n.scuffgeo\n file format supports a variety of options for \nspecifying scattering geometries.\n\n\nThe simplest case is one in which you have a collection of\ncompact homogeneous objects (which may be nested inside \none another). In this case, your \n.scuffgeo\n \nfile will simply specify mesh files representing the \nsurfaces of these objects, as well as optional material\nspecifications for the frequency-dependent electrical properties\nof the media inside.\n(A \nmesh\n is a collection of flat triangular panels that \napproximates a two-dimensional surface.\n\nscuff-em\n doesn't do the meshing for you;\nyou use external meshing software such as \n\nGMSH\n or \n\nCOMSOL\n\nfor that.)\n\n\nIn more complicated cases, it may not be possible to\ndescribe your geometry as a simple collection of\nobjects. This is true, for example, if your geometry \ncontains any \nmulti-material junctions\n---that is, \npoints at which three or more disparate media meet.\nIn this case your \n.scuffgeo\n file will specify \na series of three-dimensional \nregions\n and a set of \ntwo-dimensional meshed \nsurfaces\n lying between them.\n\n\nFinally, your geometry may be infinitely \nextended\n in \none or two directions. Examples of 1D extended geometries\ninclude this description of\n\nparallel silicon beams\n,\nwhile examples of 2D extended geometries include\na planar metamaterial array or an infinite square lattice\nof spheres. In this case, your \n.scuffgeo\n file will\nspecify \nlattice vectors\n together with a description\nof the objects, or the regions and surfaces, that constitute\njust the \nunit-cell\n geometry, which is then infinitely\nperiodically replicated to constitute the actual geometry.\n\n\nIn what follows we will see how to write \n.scuffgeo\n\nfiles that describe each of these types of geometries.\n\n\n\n\n\n\n\nGeometry Files in \nscuff-em\n\n\n\n\n\n \nSimple geometries: One or more compact objects (possibly nested)\n\n\n \nMore complex geometries: multi-material junctions\n\n\n \nExtended geometries: periodic boundary conditions\n\n\n \n.scuffgeo\n file syntax reference\n\n\n \nA compendium of \n.scuffgeo\n files\n\n\n\n\n\n\n \n\n\n1. Simple Geometries: One or more compact objects (possibly nested)\n\n\nThe simplest \nscuff-em\n geometries consist of \none or more \ncompact objects\n---that is, finite volumes of homogeneous media,\nbounded by closed 2D surfaces. In this case, all meshed surfaces in the geometry \nmust be \nclosed\n surfaces, and no two object surfaces may touch or overlap.\nEach surface is then associated with a single homogeneous material\nregion---namely, the region interior to that surface---and we collectively\nrefer to that material region and its closed surface as an \nobject.\n\n\nThe \n.scuffgeo\n file for geometries of this type consists simply \nof a sequence of \nobject declarations\n, one for each compact object \nin the geometry. A typical object declaration section looks something \nlike this:\n\n\nOBJECT UpperSphere\n    MESHFILE Sphere_458.msh\n    MATERIAL Gold\n    DISPLACED 0 0 3\n    ROTATED 45 ABOUT 0 0 1\nENDOBJECT\n\n\n\n\nThe string that follows the \nOBJECT\n keyword \n(\nUpperSphere\n in this case) is an arbitrary \nuser-specified label that you may attach to your object\nfor ease of identifying it in output files, etc. \n\n\nThe only keyword that is strictly required within the \n\nOBJECT...ENDOBJECT\n clause is \nMESHFILE.\n This specifies \na mesh file, generated by \ngmsh\n, \ncomsol\n, or other meshing \ntools, describing the surface of your object. \n\nscuff-em\n will look for this file in several places: \n\n\n\n\nthe current working directory\n\n\nthe directory specified by the \nSCUFF_MESH_PATH\n environment variable\n\n\nany search directories specified using the \nMESHPATH\n keyword in the \n.scuffgeo\n file.\n\n\n\n\nThe latter two options allow you to set up one or more common \nrepositories of mesh files which you can then re-use for \n\nscuff-em\n calculations launched from whatever directory you like.\n\n\nThe optional \nMATERIAL\n keyword is used to select a \n\nscuff-em\n material designation\n\n(in this case, \nGold\n) for the medium interior to \nyour object. The actual definition of the material \nGold\n\n(given by a \nMATERIAL...ENDMATERIAL\n clause)\nmay be present in the \n.scuffgeo\n file before the \n\nOBJECT\n specification, or may exist in a separate \nmaterial database file. If you don't specify a \nMATERIAL\n\nfor your object, it will be treated as a perfectly electrically \nconducting (PEC) body. \n\n\nThe optional \nDISPLACED\n and \nROTATED\n\nkeywords specify geometrical transformations \nthat are applied to the surface mesh after it is read in from \nthe mesh file. For example, if your mesh file describes a sphere \ncentered around the origin, and you include the line \n\nDISPLACED 0 0 3\n in your \nOBJECT...ENDOBJECT\n\nclause, then your geometry as interpreted by \n\nscuff-em\n will contain a sphere\ncentered around the point with cartesian coordinates \n(0,0,3). For more details, see the \n\nsyntax reference\n\nbelow.\n\n\nYour \n.scuffgeo\n file may contain any number of\n\nOBJECT...ENDOBJECT\n clauses.\nThe objects specified by these clauses may be \n\nnested\n,\ni.e. one object may be fully contained inside another \nobject; this will be autodetected by \nscuff-em\n.\n\n\n(However, this simple way of specifying geometries has \nthe constraint that no two object surfaces may touch or intersect. \nIf you find yourself needing to describe geometries involving \nobjects whose surface touch---thus defining \nmulti-material junctions\n---you\nyou have graduated to writing the \n\nslightly more complicated type of \n.scuffgeo\n file described below\n.)\n\n\nHere's an example of a simple \n.scuffgeo\n file describing \na smaller PEC sphere embedded inside a larger silicon dioxide\nsphere.\n\n\n# material specification for intrinsic silicon\nMATERIAL SILICON\nepsf = 1.035;      # \\epsilon_infinity\neps0 = 11.87;      # \\epsilon_0 \nwp = 6.6e15;       # \\plasmon frequency\nEps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\n\nOBJECT SiliconSphere \nMESHFILE Sphere_R1P0.msh\nMATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \nMESHFILE Sphere_R0P5.msh\nMATERIAL PEC\nENDOBJECT \n\n\n\n\n\n\nNote that the \nMATERIAL PEC\n specification for the \ninner sphere is actually superfluous---we could simply have \nomitted it, because PEC is the default material assumed for \n\nOBJECT\n clauses. On the other hand, if we had \ninstead said \nMATERIAL Vacuum\n, then we would be \ndescribing an \nvacuum\n sphere inside our larger \nsilicon sphere---that is, a spherical \nshell\n of silicon,\nas considered in \n[this \nscuff-scatter\n example][SphericalShellExample].\n\n\n\n\n2. More complex geometries: multi-material junctions\n\n\nThe attempt to describe a geometry simply as a collection of compact objects \nbreaks down for more complicated situations. For example, consider the composite \nsphere (or \"bihemisphere\") depicted in the figure below; this is a spherical\nobject formed by adjoining an upper hemisphere of material A to a lower \nhemisphere of material B. \n\n\nSchematic depiction of a Bihemisphere\n\n\n\n\nMesh representations of the three interface surfaces\n\n(shown displaced for clarity)\n\n\n\n\nOur first thought might be to think of the upper hemispherical volume as one \ncompact object, and the lower hemispherical volume as a second compact object.\nBut this doesn't work, because we can't assign a unique closed surface to each\ncompact object. Clearly the upper hemispherical surface \"belongs\" to object \n\nUpperHemisphere,\n and the lower hemispherical surface \"belongs\" to\nobject \nLowerHemisphere.\n But to which volume do we assign the surface \nof the equatorial plane?\n\n\nMore formally, the key aspect of the bihemisphere geometry that prevents \nit from being describable as a collection of compact objects is the presence\nof \nmulti-material junctions\n---that is, regions of the geometry \nat which three or more homogeneous material regions meet. The equator of \nthe bihemisphere is a multi-material junction. \n\n\n(A note on terminology: In \nscuff-em\n parlance,\na multi-material junction (MMJ) is a point or line \nat which \nthree or more\n homogeneous regions meet.\nOf course any meshed surface in a geometry---including \nthe closed surfaces used to describe simple compact-object \ngeometries above---lies at the junction of\nat least \ntwo\n regions, and is thus technically \na \"multi-material\" junction, but is not considered \nan MMJ for the purposes of the present discussion.)\n\n\nGeometries involving multi-material junctions are described in \n\nscuff-em\n by explicitly \nspecifying the various \nregions\n and \nsurfaces\n \nthat are present. Each \nregion\n is a contiguous volume \nthroughout which the material properties are spatially constant.\nEach \nsurface\n is a mesh describing a closed \nor open\n \n2D surface represented as a \nunion of flat triangular panels. Each surface must lie at the \ninterface between precisely two regions.\n\n\nFor example, in the bihemisphere geometry, there are three \nregions: \n\n\n\n\nThe exterior medium (vacuum).\n\n\nThe upper hemispherical volume (material A).\n\n\nThe lower hemispherical volume (material B).\n\n\n\n\nAnd there are three surfaces:\n\n\n\n\nThe upper hemispherical surface, which is an interface between regions 1 and 2.\n\n\nThe lower hemispherical surface, which is an interface between regions 1 and 3.\n\n\nThe surface of the equatorial plane, which is an interface between regions 2 and 3.\n\n\n\n\nThe \n.scuffgeo\n file for geometry described\nusing regions and surfaces will consist, unsurprisingly,\nof \nREGION\n lines and \n\nSURFACE...ENDSURFACE\n clauses.\n\n\nEach \nREGION\n line should look something like this:\n\n\nREGION UpperHemisphereVolume MATERIAL Gold\n\n\n\n\nThe string identifier following the \nREGION\n keyword is an \narbitrary label you may assign to your region. The string identifier\nfollowing the \nMATERIAL\n keyword is a \n\nscuff-em\n material designation\n\nspecifying the frequency-dependent material properties \nof the region.\n\n\nAll \nscuff-em\n geometries by default\nstart off with an implicitly defined region\nnamed \nExterior\n, of material \nVACUUM\n.\nIf you want to change the material properties of the \nexterior medium---for example, if your entire scattering geometry\nis embedded in ethanol---you can say something like \n\n\nREGION Exterior MATERIAL Ethanol\n\n\n\n\nOtherwise, you can refer freely to the region named \n\nExterior\n without defining it, as it will \nbe automatically present in all \nscuff-em\n\ngeometries.\n\n\nSurfaces in a regions-and-surfaces geometry are identified \nby \nSURFACE...ENDSURFACE\n clauses.\nThese are similar to \nOBJECT...ENDOBJECT\n \nclauses, but with a couple of differences. A typical \nexample looks like this:\n\n\nSURFACE UpperHemisphereSurface\n    MESHFILE UpperHemisphereSurface.msh\n    REGIONS Exterior UpperHemisphereVolume\nENDSURFACE\n\n\n\n\nThe string identifier following the \nSURFACE\n keyword\nis an arbitrary label you may assign to your surface to \nhelp identify it in output files, etc.\n\n\nThe mandatory \nMESHFILE\n keyword specifies the \nname of a file from which \nscuff-em\n\nwill attempt to read the surface mesh.\n\n\nThe mandatory \nREGIONS\n keyword identifies the two \nregions that lie on the two sides of the surface.\nThese should be regions that were previously declared using \n\nREGION\n statements (with the exception of the\nregion \nExteror\n, which is always implicitly \npresent.)\n\n\nThe \norder\n in which you specify surfaces is \nimportant for the internal workings of \nscuff-em\n,\nalthough most output quantities reported by most \n\nscuff-em\n codes will not depend on \nthis ordering.\n\n\nThe distinction is this: The surface normal vector is taken to \npoint \ninto\n the first region specified with the \n\nREGIONS\n keyword, and thus \naway from\n the second\nregion. What this means internally is that surface currents on \nthe surface contribute to the fields in the first region with a \n\npositive\n sign, and to the fields in the second region \nwith a \nnegative\n sign. Again, however, this is all handled \nconsistently within the internal workings of the code, so flipping\nthe order in the \nREGION\n specification should not\nlead to any differences in physically relevant output quantities.\n(If you flip the order of the regions, the currents on the surface\nchange sign, and their contributions to the fields in each region\nchange sign, so the fields don't change.)\n\n\nIn addition to the mandatory \nMESHFILE\n \nand \nREGIONS\n keyword, the \nSURFACE...ENDSURFACE\n\nmay also include \nDISPLACED\n and/or \nROTATED\n\nstatements to apply geometrical transforms to your surface,\nas is possible in \nOBJECT...ENDOBJECT\n clauses.\n\n\nNote that any geometry that may be represented in the simpler\nform discussed above (as a sequence of \nOBJECT...ENDOBJECT\n\nclauses) may also be represented in the regions-and-surfaces \nlanguage. \nA compact object consists of a single region (the interior of \nthe object) and a single surface (lying at the interface between\nthe interior and exterior regions). Thus, if the meshfile \n\nMySphere.msh\n represents a meshed sphere, then the \nfollowing two \n.scuffgeo\n files are equivalent:\n\n\nREGION SphereInterior MATERIAL Gold\n\nSURFACE TheSphere\nMESHFILE Sphere.msh\nREGIONS  Exterior SphereInterior\nENDSURFACE\n\n\n\n\nOBJECT TheSphere\nMESHFILE Sphere.msh\nMATERIAL Gold\nENDSURFACE\n\n\n\n\n(And see \nbelow\n for an example of how to \nrewrite the nested-spheres example from above\nin the regions-and-surfaces language.)\n\n\nIn some cases it may be convenient to write a single meshfile\nthat contains mesh descriptions for multiple surfaces \nin your geometry. This may be done by including a\n\nMESHTAG\n specification in your \n\nSURFACE...ENDSURFACE\n clause:\n\n\nSURFACE MySurface\n    MESHFILE MyMeshFile.msh\n    MESHTAG 12\n    REGIONS MyRegion1 MyRegion2\nENDSURFACE\n\n\n\n\nWhat this does is to instruct \nscuff-em\n to\nread from \nMyMeshFile.msh\n only those triangular panels\nthat have been tagged by the meshing program as belonging \nto entity 12. \n(Different meshing programs have different ways of tagging mesh \nentities. In \ngmsh\n, the tag corresponds to\nwhat \ngmsh\n calls the \"physical region;\"\nit is the argument that enters statements\nsuch as \nPhysical Surface(12)={...}\n in the \n.geo\n\nfile, and it is the number printed as the \nphysical-number\n\nfield in the \n.msh\n output file.)\n\n\nAs an example, here's a \n.scuffgeo\n file for the bihemisphere \ngeometry described above. The meshfile \nBiHemisphere_126.msh\n\nwas produced by a \ngmsh\n file named \n[BiHemisphere.geo](BiHemisphere.geo};\nnote that the three separate interface surfaces\nare created with three separate \nPhysical Surface\n\ncommands, each specifying a different tag, which is then used \nin the \n.scuffgeo\n file below to distinguish different \nentities in the \n.msh\n file.\n\n\nREGION Exterior        MATERIAL VACUUM\nREGION UpperHemisphere MATERIAL CONST_EPS_20\nREGION LowerHemisphere MATERIAL CONST_EPS_2\n\nSURFACE LowerHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 1\n    REGIONS Exterior LowerHemisphere\nENDSURFACE\n\nSURFACE UpperHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 2\n    REGIONS Exterior UpperHemisphere\nENDSURFACE\n\nSURFACE EquatorialPlane\n    MESHFILE BiHemisphere_126.msh\n    PHYSICAL_REGION 3\n    REGIONS UpperHemisphere LowerHemisphere\nENDSURFACE\n\n\n\n\n3. Extended geometries: periodic boundary conditions\n\n\nscuff-em\n can handle geometries that are\ninfinitely extended (that is, periodically repeated) in one or two\ndimensions using Bloch-periodic boundary conditions. In this case,\nyour \n.scuffgeo\n file will contain a specification of \nthe objects, or the surfaces and regions, that constitute the \n\nunit-cell\n geometry, together with a specification of the \n\nlattice vectors\n that describe how the unit cell is periodically\nrepeated.\n\n\n\n\nNote\n: The current version of \nscuff-em\n \nrequires that 2D lattice basis vectors have vanishing \nz\n\ncomponent and that 1D lattice basis vectors have vanishing\n\ny\n and \nz\n components. In other words, for 2D periodicity\nthe lattice vectors must live in the \nxy\n plane, while\nfor 1D periodicity the lattice vector must be aligned \nwith the \nx\n axis. This places no restriction on the \nactual geometric configurations that may be treated, but \nmay be inconvenient for some users who are accustomed to \nsetting up their periodic geometries in a different way.\n(For example, if you are studying thin films, and you are \nused to having the film surfaces parallel to the \nyz\n\nplane with the film thickness in the \nx\n direction, you will\nneed to rotate your coordinate system so that the surfaces \nre parallel to the \nxy\n plane and the thickness is in \nthe \nz\n direction.) This limitation may be lifted in \na future code release.\n\n\nNote\n: An additional restriction in the current version\nof \nscuff-em\n is that 2D lattices must be \nrectangular\n \nlattices: the first \nLATTICE\n vector must have only its \n\nx\n component nonzero, while the second \nLATTICE\n vector \nmust have only its \ny\n component nonzero (although the two \nvectors may have different lengths).\n. This actually \ndoes\n place restrictions on \nthe geometries that may be treated (for example, it \nexcludes hexagonal lattices), and it will be remedied\nas soon as somebody wants to run calculations on a \nnon-square-lattice geometry and is willing to help me\ntest the new feature.\n\n\n\n\nThe lattice is specified using a \nLATTICE...ENDLATTICE\n\nsection. For example, a square lattice with lattice constant \nof 1 \n\\mu\nm would look like this: \n\n\nLATTICE\nVECTOR 1 0 \nVECTOR 0 1 \nENDLATTICE \n\n\n\n\nEach \nVECTOR xx yy\n statement adds a new lattice vector\nwith cartesian components of \n(xx,yy)\n length units.\n\n\nYou may specify one or two \nVECTOR\n statements.\nIf you specify a single \nVECTOR\n, your unit-cell\ngeometry will be periodically repeated in just that one direction.\nIf you specify two \nVECTOR\n statements, your unit-cell\ngeometry will be periodically repeated in a two-dimensional lattice\npattern.\n\n\nHaving specified the lattice vectors, the remainder of your \n\n.scuffgeo\n file just consists of a specification of \nthe unit-cell geometry as if it were a standalone compact \ngeometry. For example, you may include \nOBJECT...ENDOBJECT\n \nsections to describe any compact objects that exist inside \nthe unit cell, or \nREGION\n statements and \nSURFACE...ENDSURFACE\n\nsections to describe more complicated unit-cell geometries.\n\n\nCompact objects fully contained in the unit cell\n\n\nThe simplest case is that in which your geometry is simply \nan array of isolated compact objects (with \"isolated\" here meaning \nthat each object does not touch its periodically repeated images.)\nIn this case, you will want to make sure that the objects \nlie entirely within the unit cell (not straddling its boundaries),\n\n\nFor example, here's a \n.scuffgeo\n file describing\na square lattice of cubical nanoparticles:\n\n\n The unit cell geometry \n\n\n\n\n The innermost 25 cells of the full geometry \n\n\n\n\n The \n.scuffgeo\n file \n \n\n\nLATTICE\nVECTOR 0.5  0\nVECTOR 0.0  0.5\nENDLATTICE \n\nOBJECT CubicalNanoparticle\nMESHFILE Cube.msh\nMATERIAL Silicon\nENDOBJECT\n\n\n\n\nSurfaces that straddle the unit-cell boundary\n\n\nMore generally, your unit-cell geometry may include surfaces \nthat straddle the unit-cell boundary. (This will be the case \nwhenever the infinite surfaces you are describing are \n\nconnected\n, as opposed to the isolated arrays of objects\nconsidered above). For example, here's a \n.scuffgeo\n\nfile representing a thin metallic film perforated by an \narray of holes. The parameters here are chosen to mimic \nthe geometry studied by \n\nMartin-Moreno et al, \nPhysical Review Letters\n \n86\n 1114 (2001).\n\n\n The unit cell geometry\n\n\n\n\nThe innermost 25 cells of the full geometry\n\n\n\n\n The \n.scuffgeo\n file\n\n\nLATTICE\nVECTOR 0.75  0\nVECTOR 0.0   0.75\nENDLATTICE \n\nOBJECT UnitCellMesh\nMESHFILE PFT_794.msh\nMATERIAL Gold\nENDOBJECT\n\n\n\n\nMeshing constraints for surfaces that straddle the unit-cell boundary\n\n\nThere is an important constraint on the surface meshes that may be\n\nused to define the unit-cell geometry for problems involving continuous symmetries.\n\n\nThe constraint is this: \n\nFor any panel edge that lies on a unit-cell \nboundary, there must be an identical edge lying on the opposite \nside of the unit-cell boundary.\n One way to think about this is \nthat the periodically-repeated images of the unit-cell geometry must \nall fit together \"nicely\" at the unit-cell boundaries, as indicated \nin the right panel of the figure above.\n\n\n\n\n4. Syntax reference for the \n.scuffgeo\n file format\n\n\nA \n.scuffgeo\n file consists of one or more multiline\n\nsections\n (delimited by starting and ending keywords)\nplus zero or more single-line \nstatements\n.\n\n\nBlank lines and comments (lines beginning with a \n#\n symbol)\nare ignored in \n.scuffgeo\n files.\n\n\nMESHPATH\n statement\n\n\n\n\n\n \n Keyword \n \n\n Description \n \n\n\n\n\n \n\n \nMESHPATH\n \nmy-mesh-path\n\n\n Adds the directory \nmy-mesh-path\n\n     to the path searched by \nscuff-em\n \n     for mesh files.\n\n\n\n \n\n\n\n\nREGION\n statement\n\n\n\n\n\n \n Keyword \n \n\n Description \n \n\n\n\n\n \n\n \nREGION\n \nName\n\n     \nMATERIAL\n \nMaterial\n\n\n\n\n \n     Adds a new homogeneous material region\n     to the geometry with name \nName\n\n     and material properties described by the     \n     \nscuff-em\n \n     material designation \nMaterial\n.\n\n     As discussed above, \nREGION\n\n     statements are \nnot needed\n\n     for geometries consisting of compact homogeneous\n     bodies described by \nOBJECT\n sections.\n     (Each \nOBJECT\n section automatically\n     adds a new region to the problem for the interior\n     of the object in question.) \nREGION\n\n     statements are generally only necessary when your \n     geometry contains \n     \nmulti-material junctions.\n\n\n\n\n\n \n\n\n\n\nOBJECT...ENDOBJECT\n sections\n\n\n\n\n\n \n Keyword \n \n\n Description \n \n\n\n\n\n \n\n \nOBJECT\n \nobject label\n \n\n\n Begins an object declaration for an object with the specified\nlabel.\n\n\n\n \n\n\n \n\n \nMESHFILE\n \nMyFile.msh\n \n\n\n Specifies the mesh file that defines the closed surface\n     of the object.\n\n\n\n \n\n\n \n\n \nMESHTAG \n \nxx\n \n\n\n Specifies that only panels tagged in the mesh\n     file with tag \nxx\n are to be considered \n     part of the surface of this object. This allows a\n     single \n.msh\n file to contain multiple\n     closed surfaces each defining distinct objects.\n\n\n\n \n\n\n \n\n \nMATERIAL \n \nMyMaterial\n \n\n\n Specifies a \nscuff-em\n\n     material designation for the homogeneous medium\n     interior to the object.\n\n\n\n \n\n\n \n\n \nDISPLACED\n \nxx yy zz\n \n\n\n Indicates that the contents of the specified mesh \nfile are to be translated through a displacement vector with \ncartesian components (\nxx, yy, zz\nbefore\ninclusion in the geometry.\n\n\n\n\n\n\n \n\n \nROTATED\n \ndd\n \nABOUT\n \nnx ny nz\n \n\n\n Indicates that the contents of the specified mesh \nfile are to be rotated through an angle of \ndd\n\ndegrees (\ndegrees, not radians\n) about an axis passing \nthrough the origin and through the point with cartesian coordinates\n(\nnx, ny, nz/\nbefore inclusion in the geometry.\n\n\n\n \n\n\n \n\n \nENDOBJECT\n\n\n Ends the object declaration.\n\n\n\n \n\n\n\n\nSURFACE...ENDSURFACE\n sections\n\n\nLATTICE...ENDLATTICE\n sections\n\n\nMATERIAL...ENDMATERIAL\n sections\n\n\n\n\nFor details on how to write a \nMATERIAL\n section,\nsee \nhere\n.\n\n\n\n\n \n\n\n5. A compendium of sample \n.scuffgeo\n files\n\n\nThe images corresponding to the \n.scuffgeo\n files below were \nobtained using the \nscuff-analyze\n utility distributed with \nthe \nscuff-em\n suite, like this:\n\n\n% scuff-analyze --geometry MyGeometry.scuffgeo --WriteGMSHFiles\n\n\n\n\nThis produces a \ngmsh\n post-processing file \nnamed \nMyGeometry.pp\n that you can open in \n\ngmsh\n to visualize your geometry and\nmake sure \nscuff-em\n interpreted your \n\n.scuffgeo\n file as you intended.\nThis is generally a good thing to do before launching any serious\ncalculations.\n\n\n\n\nA single perfectly electrically conducting (PEC) sphere\n\n\nThis is perhaps the simplest imaginable \nscuff-em\n\ngeometry.\n\n\nOBJECT PECSphere \n    MESHFILE Sphere.msh\nENDOBJECT \n\n\n\n\n\n\n\n\n\n\nA gold sphere and a silicon sphere\n\n\nThis example illustrates the use of the \nDISPLACED\n\nkeyword to displace a surface mesh relative to its positioning \nin the mesh file. Note in particular that this keyword allows\nus to use the same mesh file to describe two different spheres,\nwhich speeds things up by allowing \nscuff-em\n \nto reuse certain parts of the calculation, thus eliminating\nredundant numerical work. (Without the \nDISPLACED\n \nkeyword in this example, the two spheres would be sitting on \ntop of one another.)\n\n\nMATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nMATERIAL GOLD\n  wp = 1.37e16; \n  gamma = 5.32e13;\n  Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nMESHPATH /home/homer/work/MeshFiles\n\nOBJECT GoldSphere\n  MESHFILE Sphere.msh\n  MATERIAL Gold\n  DISPLACED 0 0 3\nENDOBJECT \n\nOBJECT SiliconSphere\n  MESHFILE Sphere.msh\n  MATERIAL Silicon\nENDOBJECT \n\n\n\n\n\n\n\n\n\n\nA small gold sphere inside a larger silicon dioxide sphere\n\n\nMATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT SiliconSphere \n  MESHFILE Sphere_R1P0.msh\n  MATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \n  MESHFILE Sphere_R0P5.msh\n  MATERIAL PEC\nENDOBJECT", 
            "title": "Geometry descriptions"
        }, 
        {
            "location": "/reference/Geometries/#1-simple-geometries-one-or-more-compact-objects-possibly-nested", 
            "text": "The simplest  scuff-em  geometries consist of \none or more  compact objects ---that is, finite volumes of homogeneous media,\nbounded by closed 2D surfaces. In this case, all meshed surfaces in the geometry \nmust be  closed  surfaces, and no two object surfaces may touch or overlap.\nEach surface is then associated with a single homogeneous material\nregion---namely, the region interior to that surface---and we collectively\nrefer to that material region and its closed surface as an  object.  The  .scuffgeo  file for geometries of this type consists simply \nof a sequence of  object declarations , one for each compact object \nin the geometry. A typical object declaration section looks something \nlike this:  OBJECT UpperSphere\n    MESHFILE Sphere_458.msh\n    MATERIAL Gold\n    DISPLACED 0 0 3\n    ROTATED 45 ABOUT 0 0 1\nENDOBJECT  The string that follows the  OBJECT  keyword \n( UpperSphere  in this case) is an arbitrary \nuser-specified label that you may attach to your object\nfor ease of identifying it in output files, etc.   The only keyword that is strictly required within the  OBJECT...ENDOBJECT  clause is  MESHFILE.  This specifies \na mesh file, generated by  gmsh ,  comsol , or other meshing \ntools, describing the surface of your object.  scuff-em  will look for this file in several places:    the current working directory  the directory specified by the  SCUFF_MESH_PATH  environment variable  any search directories specified using the  MESHPATH  keyword in the  .scuffgeo  file.   The latter two options allow you to set up one or more common \nrepositories of mesh files which you can then re-use for  scuff-em  calculations launched from whatever directory you like.  The optional  MATERIAL  keyword is used to select a  scuff-em  material designation \n(in this case,  Gold ) for the medium interior to \nyour object. The actual definition of the material  Gold \n(given by a  MATERIAL...ENDMATERIAL  clause)\nmay be present in the  .scuffgeo  file before the  OBJECT  specification, or may exist in a separate \nmaterial database file. If you don't specify a  MATERIAL \nfor your object, it will be treated as a perfectly electrically \nconducting (PEC) body.   The optional  DISPLACED  and  ROTATED \nkeywords specify geometrical transformations \nthat are applied to the surface mesh after it is read in from \nthe mesh file. For example, if your mesh file describes a sphere \ncentered around the origin, and you include the line  DISPLACED 0 0 3  in your  OBJECT...ENDOBJECT \nclause, then your geometry as interpreted by  scuff-em  will contain a sphere\ncentered around the point with cartesian coordinates \n(0,0,3). For more details, see the  syntax reference \nbelow.  Your  .scuffgeo  file may contain any number of OBJECT...ENDOBJECT  clauses.\nThe objects specified by these clauses may be  nested ,\ni.e. one object may be fully contained inside another \nobject; this will be autodetected by  scuff-em .  (However, this simple way of specifying geometries has \nthe constraint that no two object surfaces may touch or intersect. \nIf you find yourself needing to describe geometries involving \nobjects whose surface touch---thus defining  multi-material junctions ---you\nyou have graduated to writing the  slightly more complicated type of  .scuffgeo  file described below .)  Here's an example of a simple  .scuffgeo  file describing \na smaller PEC sphere embedded inside a larger silicon dioxide\nsphere.  # material specification for intrinsic silicon\nMATERIAL SILICON\nepsf = 1.035;      # \\epsilon_infinity\neps0 = 11.87;      # \\epsilon_0 \nwp = 6.6e15;       # \\plasmon frequency\nEps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\n\nOBJECT SiliconSphere \nMESHFILE Sphere_R1P0.msh\nMATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \nMESHFILE Sphere_R0P5.msh\nMATERIAL PEC\nENDOBJECT    Note that the  MATERIAL PEC  specification for the \ninner sphere is actually superfluous---we could simply have \nomitted it, because PEC is the default material assumed for  OBJECT  clauses. On the other hand, if we had \ninstead said  MATERIAL Vacuum , then we would be \ndescribing an  vacuum  sphere inside our larger \nsilicon sphere---that is, a spherical  shell  of silicon,\nas considered in \n[this  scuff-scatter  example][SphericalShellExample].", 
            "title": "1. Simple Geometries: One or more compact objects (possibly nested)"
        }, 
        {
            "location": "/reference/Geometries/#2-more-complex-geometries-multi-material-junctions", 
            "text": "The attempt to describe a geometry simply as a collection of compact objects \nbreaks down for more complicated situations. For example, consider the composite \nsphere (or \"bihemisphere\") depicted in the figure below; this is a spherical\nobject formed by adjoining an upper hemisphere of material A to a lower \nhemisphere of material B.   Schematic depiction of a Bihemisphere   Mesh representations of the three interface surfaces \n(shown displaced for clarity)   Our first thought might be to think of the upper hemispherical volume as one \ncompact object, and the lower hemispherical volume as a second compact object.\nBut this doesn't work, because we can't assign a unique closed surface to each\ncompact object. Clearly the upper hemispherical surface \"belongs\" to object  UpperHemisphere,  and the lower hemispherical surface \"belongs\" to\nobject  LowerHemisphere.  But to which volume do we assign the surface \nof the equatorial plane?  More formally, the key aspect of the bihemisphere geometry that prevents \nit from being describable as a collection of compact objects is the presence\nof  multi-material junctions ---that is, regions of the geometry \nat which three or more homogeneous material regions meet. The equator of \nthe bihemisphere is a multi-material junction.   (A note on terminology: In  scuff-em  parlance,\na multi-material junction (MMJ) is a point or line \nat which  three or more  homogeneous regions meet.\nOf course any meshed surface in a geometry---including \nthe closed surfaces used to describe simple compact-object \ngeometries above---lies at the junction of\nat least  two  regions, and is thus technically \na \"multi-material\" junction, but is not considered \nan MMJ for the purposes of the present discussion.)  Geometries involving multi-material junctions are described in  scuff-em  by explicitly \nspecifying the various  regions  and  surfaces  \nthat are present. Each  region  is a contiguous volume \nthroughout which the material properties are spatially constant.\nEach  surface  is a mesh describing a closed  or open  \n2D surface represented as a \nunion of flat triangular panels. Each surface must lie at the \ninterface between precisely two regions.  For example, in the bihemisphere geometry, there are three \nregions:    The exterior medium (vacuum).  The upper hemispherical volume (material A).  The lower hemispherical volume (material B).   And there are three surfaces:   The upper hemispherical surface, which is an interface between regions 1 and 2.  The lower hemispherical surface, which is an interface between regions 1 and 3.  The surface of the equatorial plane, which is an interface between regions 2 and 3.   The  .scuffgeo  file for geometry described\nusing regions and surfaces will consist, unsurprisingly,\nof  REGION  lines and  SURFACE...ENDSURFACE  clauses.  Each  REGION  line should look something like this:  REGION UpperHemisphereVolume MATERIAL Gold  The string identifier following the  REGION  keyword is an \narbitrary label you may assign to your region. The string identifier\nfollowing the  MATERIAL  keyword is a  scuff-em  material designation \nspecifying the frequency-dependent material properties \nof the region.  All  scuff-em  geometries by default\nstart off with an implicitly defined region\nnamed  Exterior , of material  VACUUM .\nIf you want to change the material properties of the \nexterior medium---for example, if your entire scattering geometry\nis embedded in ethanol---you can say something like   REGION Exterior MATERIAL Ethanol  Otherwise, you can refer freely to the region named  Exterior  without defining it, as it will \nbe automatically present in all  scuff-em \ngeometries.  Surfaces in a regions-and-surfaces geometry are identified \nby  SURFACE...ENDSURFACE  clauses.\nThese are similar to  OBJECT...ENDOBJECT  \nclauses, but with a couple of differences. A typical \nexample looks like this:  SURFACE UpperHemisphereSurface\n    MESHFILE UpperHemisphereSurface.msh\n    REGIONS Exterior UpperHemisphereVolume\nENDSURFACE  The string identifier following the  SURFACE  keyword\nis an arbitrary label you may assign to your surface to \nhelp identify it in output files, etc.  The mandatory  MESHFILE  keyword specifies the \nname of a file from which  scuff-em \nwill attempt to read the surface mesh.  The mandatory  REGIONS  keyword identifies the two \nregions that lie on the two sides of the surface.\nThese should be regions that were previously declared using  REGION  statements (with the exception of the\nregion  Exteror , which is always implicitly \npresent.)  The  order  in which you specify surfaces is \nimportant for the internal workings of  scuff-em ,\nalthough most output quantities reported by most  scuff-em  codes will not depend on \nthis ordering.  The distinction is this: The surface normal vector is taken to \npoint  into  the first region specified with the  REGIONS  keyword, and thus  away from  the second\nregion. What this means internally is that surface currents on \nthe surface contribute to the fields in the first region with a  positive  sign, and to the fields in the second region \nwith a  negative  sign. Again, however, this is all handled \nconsistently within the internal workings of the code, so flipping\nthe order in the  REGION  specification should not\nlead to any differences in physically relevant output quantities.\n(If you flip the order of the regions, the currents on the surface\nchange sign, and their contributions to the fields in each region\nchange sign, so the fields don't change.)  In addition to the mandatory  MESHFILE  \nand  REGIONS  keyword, the  SURFACE...ENDSURFACE \nmay also include  DISPLACED  and/or  ROTATED \nstatements to apply geometrical transforms to your surface,\nas is possible in  OBJECT...ENDOBJECT  clauses.  Note that any geometry that may be represented in the simpler\nform discussed above (as a sequence of  OBJECT...ENDOBJECT \nclauses) may also be represented in the regions-and-surfaces \nlanguage. \nA compact object consists of a single region (the interior of \nthe object) and a single surface (lying at the interface between\nthe interior and exterior regions). Thus, if the meshfile  MySphere.msh  represents a meshed sphere, then the \nfollowing two  .scuffgeo  files are equivalent:  REGION SphereInterior MATERIAL Gold\n\nSURFACE TheSphere\nMESHFILE Sphere.msh\nREGIONS  Exterior SphereInterior\nENDSURFACE  OBJECT TheSphere\nMESHFILE Sphere.msh\nMATERIAL Gold\nENDSURFACE  (And see  below  for an example of how to \nrewrite the nested-spheres example from above\nin the regions-and-surfaces language.)  In some cases it may be convenient to write a single meshfile\nthat contains mesh descriptions for multiple surfaces \nin your geometry. This may be done by including a MESHTAG  specification in your  SURFACE...ENDSURFACE  clause:  SURFACE MySurface\n    MESHFILE MyMeshFile.msh\n    MESHTAG 12\n    REGIONS MyRegion1 MyRegion2\nENDSURFACE  What this does is to instruct  scuff-em  to\nread from  MyMeshFile.msh  only those triangular panels\nthat have been tagged by the meshing program as belonging \nto entity 12. \n(Different meshing programs have different ways of tagging mesh \nentities. In  gmsh , the tag corresponds to\nwhat  gmsh  calls the \"physical region;\"\nit is the argument that enters statements\nsuch as  Physical Surface(12)={...}  in the  .geo \nfile, and it is the number printed as the  physical-number \nfield in the  .msh  output file.)  As an example, here's a  .scuffgeo  file for the bihemisphere \ngeometry described above. The meshfile  BiHemisphere_126.msh \nwas produced by a  gmsh  file named \n[BiHemisphere.geo](BiHemisphere.geo};\nnote that the three separate interface surfaces\nare created with three separate  Physical Surface \ncommands, each specifying a different tag, which is then used \nin the  .scuffgeo  file below to distinguish different \nentities in the  .msh  file.  REGION Exterior        MATERIAL VACUUM\nREGION UpperHemisphere MATERIAL CONST_EPS_20\nREGION LowerHemisphere MATERIAL CONST_EPS_2\n\nSURFACE LowerHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 1\n    REGIONS Exterior LowerHemisphere\nENDSURFACE\n\nSURFACE UpperHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 2\n    REGIONS Exterior UpperHemisphere\nENDSURFACE\n\nSURFACE EquatorialPlane\n    MESHFILE BiHemisphere_126.msh\n    PHYSICAL_REGION 3\n    REGIONS UpperHemisphere LowerHemisphere\nENDSURFACE", 
            "title": "2. More complex geometries: multi-material junctions"
        }, 
        {
            "location": "/reference/Geometries/#3-extended-geometries-periodic-boundary-conditions", 
            "text": "scuff-em  can handle geometries that are\ninfinitely extended (that is, periodically repeated) in one or two\ndimensions using Bloch-periodic boundary conditions. In this case,\nyour  .scuffgeo  file will contain a specification of \nthe objects, or the surfaces and regions, that constitute the  unit-cell  geometry, together with a specification of the  lattice vectors  that describe how the unit cell is periodically\nrepeated.   Note : The current version of  scuff-em  \nrequires that 2D lattice basis vectors have vanishing  z \ncomponent and that 1D lattice basis vectors have vanishing y  and  z  components. In other words, for 2D periodicity\nthe lattice vectors must live in the  xy  plane, while\nfor 1D periodicity the lattice vector must be aligned \nwith the  x  axis. This places no restriction on the \nactual geometric configurations that may be treated, but \nmay be inconvenient for some users who are accustomed to \nsetting up their periodic geometries in a different way.\n(For example, if you are studying thin films, and you are \nused to having the film surfaces parallel to the  yz \nplane with the film thickness in the  x  direction, you will\nneed to rotate your coordinate system so that the surfaces \nre parallel to the  xy  plane and the thickness is in \nthe  z  direction.) This limitation may be lifted in \na future code release.  Note : An additional restriction in the current version\nof  scuff-em  is that 2D lattices must be  rectangular  \nlattices: the first  LATTICE  vector must have only its  x  component nonzero, while the second  LATTICE  vector \nmust have only its  y  component nonzero (although the two \nvectors may have different lengths).\n. This actually  does  place restrictions on \nthe geometries that may be treated (for example, it \nexcludes hexagonal lattices), and it will be remedied\nas soon as somebody wants to run calculations on a \nnon-square-lattice geometry and is willing to help me\ntest the new feature.   The lattice is specified using a  LATTICE...ENDLATTICE \nsection. For example, a square lattice with lattice constant \nof 1  \\mu m would look like this:   LATTICE\nVECTOR 1 0 \nVECTOR 0 1 \nENDLATTICE   Each  VECTOR xx yy  statement adds a new lattice vector\nwith cartesian components of  (xx,yy)  length units.  You may specify one or two  VECTOR  statements.\nIf you specify a single  VECTOR , your unit-cell\ngeometry will be periodically repeated in just that one direction.\nIf you specify two  VECTOR  statements, your unit-cell\ngeometry will be periodically repeated in a two-dimensional lattice\npattern.  Having specified the lattice vectors, the remainder of your  .scuffgeo  file just consists of a specification of \nthe unit-cell geometry as if it were a standalone compact \ngeometry. For example, you may include  OBJECT...ENDOBJECT  \nsections to describe any compact objects that exist inside \nthe unit cell, or  REGION  statements and  SURFACE...ENDSURFACE \nsections to describe more complicated unit-cell geometries.", 
            "title": "3. Extended geometries: periodic boundary conditions"
        }, 
        {
            "location": "/reference/Geometries/#compact-objects-fully-contained-in-the-unit-cell", 
            "text": "The simplest case is that in which your geometry is simply \nan array of isolated compact objects (with \"isolated\" here meaning \nthat each object does not touch its periodically repeated images.)\nIn this case, you will want to make sure that the objects \nlie entirely within the unit cell (not straddling its boundaries),  For example, here's a  .scuffgeo  file describing\na square lattice of cubical nanoparticles:   The unit cell geometry     The innermost 25 cells of the full geometry     The  .scuffgeo  file     LATTICE\nVECTOR 0.5  0\nVECTOR 0.0  0.5\nENDLATTICE \n\nOBJECT CubicalNanoparticle\nMESHFILE Cube.msh\nMATERIAL Silicon\nENDOBJECT", 
            "title": "Compact objects fully contained in the unit cell"
        }, 
        {
            "location": "/reference/Geometries/#surfaces-that-straddle-the-unit-cell-boundary", 
            "text": "More generally, your unit-cell geometry may include surfaces \nthat straddle the unit-cell boundary. (This will be the case \nwhenever the infinite surfaces you are describing are  connected , as opposed to the isolated arrays of objects\nconsidered above). For example, here's a  .scuffgeo \nfile representing a thin metallic film perforated by an \narray of holes. The parameters here are chosen to mimic \nthe geometry studied by  Martin-Moreno et al,  Physical Review Letters   86  1114 (2001).   The unit cell geometry   The innermost 25 cells of the full geometry    The  .scuffgeo  file  LATTICE\nVECTOR 0.75  0\nVECTOR 0.0   0.75\nENDLATTICE \n\nOBJECT UnitCellMesh\nMESHFILE PFT_794.msh\nMATERIAL Gold\nENDOBJECT", 
            "title": "Surfaces that straddle the unit-cell boundary"
        }, 
        {
            "location": "/reference/Geometries/#meshing-constraints-for-surfaces-that-straddle-the-unit-cell-boundary", 
            "text": "There is an important constraint on the surface meshes that may be \nused to define the unit-cell geometry for problems involving continuous symmetries.  The constraint is this:  For any panel edge that lies on a unit-cell \nboundary, there must be an identical edge lying on the opposite \nside of the unit-cell boundary.  One way to think about this is \nthat the periodically-repeated images of the unit-cell geometry must \nall fit together \"nicely\" at the unit-cell boundaries, as indicated \nin the right panel of the figure above.", 
            "title": "Meshing constraints for surfaces that straddle the unit-cell boundary"
        }, 
        {
            "location": "/reference/Geometries/#4-syntax-reference-for-the-scuffgeo-file-format", 
            "text": "A  .scuffgeo  file consists of one or more multiline sections  (delimited by starting and ending keywords)\nplus zero or more single-line  statements .  Blank lines and comments (lines beginning with a  #  symbol)\nare ignored in  .scuffgeo  files.", 
            "title": "4. Syntax reference for the .scuffgeo file format"
        }, 
        {
            "location": "/reference/Geometries/#meshpath-statement", 
            "text": "Keyword     Description         MESHPATH   my-mesh-path   Adds the directory  my-mesh-path \n     to the path searched by  scuff-em  \n     for mesh files.", 
            "title": "MESHPATH statement"
        }, 
        {
            "location": "/reference/Geometries/#region-statement", 
            "text": "Keyword     Description         REGION   Name \n      MATERIAL   Material    \n     Adds a new homogeneous material region\n     to the geometry with name  Name \n     and material properties described by the     \n      scuff-em  \n     material designation  Material .\n\n     As discussed above,  REGION \n     statements are  not needed \n     for geometries consisting of compact homogeneous\n     bodies described by  OBJECT  sections.\n     (Each  OBJECT  section automatically\n     adds a new region to the problem for the interior\n     of the object in question.)  REGION \n     statements are generally only necessary when your \n     geometry contains \n      multi-material junctions.", 
            "title": "REGION statement"
        }, 
        {
            "location": "/reference/Geometries/#objectendobject-sections", 
            "text": "Keyword     Description         OBJECT   object label     Begins an object declaration for an object with the specified\nlabel.        MESHFILE   MyFile.msh     Specifies the mesh file that defines the closed surface\n     of the object.        MESHTAG    xx     Specifies that only panels tagged in the mesh\n     file with tag  xx  are to be considered \n     part of the surface of this object. This allows a\n     single  .msh  file to contain multiple\n     closed surfaces each defining distinct objects.        MATERIAL    MyMaterial     Specifies a  scuff-em \n     material designation for the homogeneous medium\n     interior to the object.        DISPLACED   xx yy zz     Indicates that the contents of the specified mesh \nfile are to be translated through a displacement vector with \ncartesian components ( xx, yy, zz before\ninclusion in the geometry.       ROTATED   dd   ABOUT   nx ny nz     Indicates that the contents of the specified mesh \nfile are to be rotated through an angle of  dd \ndegrees ( degrees, not radians ) about an axis passing \nthrough the origin and through the point with cartesian coordinates\n( nx, ny, nz/ before inclusion in the geometry.        ENDOBJECT   Ends the object declaration.", 
            "title": "OBJECT...ENDOBJECT sections"
        }, 
        {
            "location": "/reference/Geometries/#surfaceendsurface-sections", 
            "text": "", 
            "title": "SURFACE...ENDSURFACE sections"
        }, 
        {
            "location": "/reference/Geometries/#latticeendlattice-sections", 
            "text": "", 
            "title": "LATTICE...ENDLATTICE sections"
        }, 
        {
            "location": "/reference/Geometries/#materialendmaterial-sections", 
            "text": "For details on how to write a  MATERIAL  section,\nsee  here .", 
            "title": "MATERIAL...ENDMATERIAL sections"
        }, 
        {
            "location": "/reference/Geometries/#5-a-compendium-of-sample-scuffgeo-files", 
            "text": "The images corresponding to the  .scuffgeo  files below were \nobtained using the  scuff-analyze  utility distributed with \nthe  scuff-em  suite, like this:  % scuff-analyze --geometry MyGeometry.scuffgeo --WriteGMSHFiles  This produces a  gmsh  post-processing file \nnamed  MyGeometry.pp  that you can open in  gmsh  to visualize your geometry and\nmake sure  scuff-em  interpreted your  .scuffgeo  file as you intended.\nThis is generally a good thing to do before launching any serious\ncalculations.   A single perfectly electrically conducting (PEC) sphere  This is perhaps the simplest imaginable  scuff-em \ngeometry.  OBJECT PECSphere \n    MESHFILE Sphere.msh\nENDOBJECT      A gold sphere and a silicon sphere  This example illustrates the use of the  DISPLACED \nkeyword to displace a surface mesh relative to its positioning \nin the mesh file. Note in particular that this keyword allows\nus to use the same mesh file to describe two different spheres,\nwhich speeds things up by allowing  scuff-em  \nto reuse certain parts of the calculation, thus eliminating\nredundant numerical work. (Without the  DISPLACED  \nkeyword in this example, the two spheres would be sitting on \ntop of one another.)  MATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nMATERIAL GOLD\n  wp = 1.37e16; \n  gamma = 5.32e13;\n  Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nMESHPATH /home/homer/work/MeshFiles\n\nOBJECT GoldSphere\n  MESHFILE Sphere.msh\n  MATERIAL Gold\n  DISPLACED 0 0 3\nENDOBJECT \n\nOBJECT SiliconSphere\n  MESHFILE Sphere.msh\n  MATERIAL Silicon\nENDOBJECT      A small gold sphere inside a larger silicon dioxide sphere  MATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT SiliconSphere \n  MESHFILE Sphere_R1P0.msh\n  MATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \n  MESHFILE Sphere_R0P5.msh\n  MATERIAL PEC\nENDOBJECT", 
            "title": "5. A compendium of sample .scuffgeo files"
        }, 
        {
            "location": "/reference/Materials/", 
            "text": "Material descriptions in \nscuff-em\n\n\nscuff-em\n allows the\nfrequency-dependent electrical properties (dielectric\npermittivity and magnetic permeability) of materials to be \nspecified in one of several ways:\n\n\n\n\nYou can use a \nbuilt-in\n material like \nPEC\n or \nVacuum.\n  \n\n\nYou can specify a material with \nconstant\n (frequency-independent) \npermittivity and permeability.\n\n\nYou can specify a data file containing tabulated \npermittivity and permeability values over a range of \nfrequencies; in this case, \nscuff-em\n\nwill interpolate between values in your file to estimate\nmaterial properties at arbitrary frequencies.\n\n\nYou can define your own material with \narbitrary frequency-dependent material properties,\nspecified using mathematical expressions.\n\n\n\n\nMaterials are generally specified to\n\nscuff-em\n by including a line like \n\n\nMATERIAL MyMaterialName\n\n\n\n\nin the \n\n.scuffgeo\n file\n;\nhere \nMyMaterialName\n is a string constructed in different\nways depending on which of the above types of material specification\nyou have in mind, as detailed below.\n\n\nNote that material specification in \nscuff-em\n are \n\ncase-insensitive.\n The strings \nTEFLON,\n \nTeflon,\n and \nteflon\n all \nrefer to the same material.\n\n\nNote also that the values of the permittivity and permeability\ndescribed by \nscuff-em\n material designations are always\nthe dimensionless \nrelative\n permittivity and permeability,\nwith values of 1 in vacuum.\n\n\n\n\n\n\n \n Material specifications in \nscuff-em\n\n\n\n\n \n \nBuilt-in materials\n\n \n \nFrequency-independent materials\n\n \n \nMaterials specified using tabulated data\n\n \n \nUser-defined materials\n\n \n \n\n       \nscuff-plotepseu:\n A command-line \n       utility for verifying material properties\n\n\n\n\n\n\n\n\n\n1. Built-In Materials\n\n\nThe two built-in materials are \nVacuum\n and \n\nPEC\n. The former describes a material with \n\n\\epsilon=\\mu=1\n at all frequencies, while the latter describes \na \nP\nerfect \nE\nlectrical \nC\nonductor.\n\n\n\n\n\n\n2. Frequency-independent materials\n\n\nFor a non-magnetic material with frequency-independent permittivity\n\n\\epsilon\n, you can use a material specification of the form \n\n\nMATERIAL CONST_EPS_11.8\n\n\n\n\nwhere you would replace \n11.8\n with the constant value \nof the permittivity. (Note that \nCONST_EPS_11.8\n \nis all one word, with no spaces.)\n\n\nFor a material with frequency-independent permittivity \n\\epsilon\n\n\nand\n frequency-independent permeability \n\\mu\\ne1\n, you can \nuse a material-property designation of the form \n\n\nMATERIAL CONST_EPS_11.8_MU_0.8\n\n\n\n\nwhere you would replace \n0.8\n with the constant value \nof the permeability. (Again, all one word, no spaces.)\n\n\nYou can also specify materials with negative and/or complex \npermittivity: \n\n\nMATERIAL CONST_EPS_-54+46i\n\n\n\n\nOf course, a dielectric function with a frequency-independent \nimaginary part is unphysical, but no problems will arise as long \nas you are only doing computations at a single frequency.\n\n\n\n\n\n\n3. Materials specified using tabulated data\n\n\nIf you have tabulated frequency data for the permittivity and/or permeability\nof your material, you can specify this to \nscuff-em\n using a material \nspecification of the form\n\n\nMATERIAL FILE_MyDataFile.dat\n\n\n\n\nwhere the \nFILE_\n part of the string is fixed, and the \nremainder is the name of your data file (which is of course case-sensitive.)\nAgain, note that the material property specification is all one word with\nno spaces.\n\n\nThe data file is interpreted by \nscuff-em\n\nin the following way:\n\n\n\n\nBlank lines and comments (lines beginning with \n#\n) are ignored.\n\n\nAll other lines must contain either two or three space-separated \nstrings, which are interpreted as\n\n\n\n\n\n\nOmega\n \nEpsilon(Omega)\n  [\nMu(Omega)\n]\n\n\n\n\nwhere \nOmega\n is an angular frequency, \nEpsilon(Omega)\n \nis the relative permittivity at that frequency, and the optional\n\nMu(Omega)\n is the relative permeability.\n\n\nThe values specified for \nEps\n and \nMu\n may be\n\ncomplex numbers.\n.\n\n\nNote that \n\\omega\n values in material data files are always specified\nin units of radians per second, \nnot\n the specialized frequency\nunits that are used in \nscuff-em\n application codes.\n For \nexample, an angular frequency of \n3\\cdot 10^{14}\n rad/sec would\nbe specified as \n1.0\n in (for example) the \n--omega\n argument\nto \nscuff-scatter\n, but as \n3.0e14\n in a material data file.\n\n\nFor example, suppose you have tabulated data for the \nfrequency-dependent permittivity of silver over a finite\nrange of frequencies. Put those data into a text file\ncalled (for example) \nSilver.dat\n\nwith the angular frequencies (in radians per second)\non the first column, and the complex relative permittivity\non the second column, so that the data file looks something\nlike this:\n\n\n2.5133e15 -28.832+0.39369i\n2.6180e15 -26.235+0.35815i\n...\n5.2360e15 -2.3459+0.23547i\n5.3855e15 -1.7349+0.24727i\n\n\n\n\nThis says that, for example, at angular frequency\n\n\\omega=2.5133\\cdot 10^{15}\\hbox{ rad/sec}\n we have \nrelative permittivity \n\n\\epsilon(\\omega)=-28.832 + 0.39369i.\n\n\n\n\nThen your \n.scuffgeo\n file may refer to a material\nnamed \nFILE_Silver.dat,\n whose dielectric function at\narbitrary frequencies \n\\omega\n will be obtained by\ninterpolating the data specified in your data file.\nFor example, to describe a sphere made of this material\nyour ``.scuffgeo'' file could contain a section like\n\n\nOBJECT SilverSphere\n    MESHFILE Sphere.msh\n    MATERIAL FILE_Silver.dat\nENDOBJECT\n\n\n\n\nNote: If you are doing calculations at \nimaginary\n frequencies\n(in \nscuff-cas3d\n, \nscuff-caspol\n, or \nscuff-scatter\n with\nan imaginary value specified for \n--omega\n)\nand you have tabulated data for the relative permittivity\non the imaginary frequency axis, you can play exactly the \nsame game described above, except that now the \n\\omega\n\nvalues on the first column of the data file will be \npure imaginary (they will end in \ni\n or \nI\n).\n(Also, on physical grounds the relative permittivity at\neach frequency should be real-valued and positive in this \ncase).\n\n\n\n\n\n\n4. User-defined materials\n\n\nFor more general materials, you will want to define your own\nfrequency-dependent material designations. You do this by \nfirst creating an entry in a database file that describes \nyour material, and then referring back to that entry in \n\n.scuffgeo\n files and anywhere else you need to \nspecify a material property designation. (Alternatively, \nyou can define the material on-the-fly inside a \n\nMATERIAL...ENDMATERIAL\n section in your \n.scuffgeo\n file. \nSee \nhere\n for more details.\n\n\n\n\nThe location of the database file\n\n\nlibmatprop\n looks in the following three places for its \ndatabase file:\n\n\n\n\n\n\nThe file \n${HOME}/.matprop.dat\n (i.e. a file \nnamed \n.matprop.dat\n in the top-level directory\nfor your user account.)\n\n\n\n\n\n\nThe file named by the environment variable \nSCUFF_MATPROPFILE.\n \n\n\n\n\n\n\nA file named \nmatprop.dat\n in the current working\ndirectory. (Note the absence of a leading period as compared\nwith the previous item.)\n\n\n\n\n\n\nPersonally, I think the first or second of these options is the most\nconvenient; they allow you to create and maintain a single database\nfile that contains all the common materials you will ever need to use.\n\n\nEntries in the database file\n\n\nA typical entry in the database file looks like this:\n\n\nMATERIAL SiliconCarbide\n\n  EpsInf = 6.7;\n  a0     = -3.32377e28;\n  a1     = +8.93329e11;\n  b0     = -2.21677e28;\n  b1     = 8.93329e11;\n\n  Eps(w) = EpsInf * ( w^2 + a1*i*w + a0 ) / ( w^2 + b1*i*w + b0);\n\nENDMATERIAL\n\n\n\n\nThe first line defines the name of the material (the name you\nwould supply as an argument to the \nMATERIAL\n keyword \nin a \n.scuffgeo\n file, for example).\n\n\nThe next few lines define some constants. These constant\ndefinitions are specific to this particular \nMATERIAL\n;\ntwo different \nMATERIAL\n sections in the database \nfile may define the same constant to have two different values.\n\n\nThe line \nEps(w) = ...\n defines the \nfrequency-dependent relative permittivity of your material.\nThe expression to the right of the \n=\n sign is \nparsed and interpreted as a function\nof the single variable \nw,\n the angular frequency.\nThe expression may refer to any of the constants you have defined \nfor the present material; it may also use the symbols\n\ni\n and \nI\n to denote the imaginary unit.\n\n\nAgain, \n\\omega\n values in material property specifications are \nalways interpreted in units of radians per second, \nnot\n the \nspecialized angular-frequency units that are used in some of the \n\nscuff-em\n application codes.\n\n\nIf your material has \n\\mu\\ne 1\n, you may optionally also include a line \nof the form\n\n\nMu(w) = some-function(w)\n\n\n\n\nA Sample Database File\n\n\nHere is a sample database file:\nmatprop.dat\n.\nI recommend you rename this file to \n${HOME}/.matprop.dat\n and \naugment it as necessary for your applications.\n\n\n\n\n \n\n\n5. \nscuff-plotEpsMu:\n A command-line utility for verifying material properties\n\n\nThe \nscuff-em\n distribution comes with an application program named \n\nscuff-plotEpsMu\n that you\ncan use to make sure that a material property designation is \ninterpreted the way you intended. You can run this command with \nno arguments to get usage information:\n\n\n% scuff-plotEpsMu \n\nerror: --material option is mandatory (aborting)\n\nusage: scuff-plotEpsMu [options]\n\noptions: \n\n--material xx  (name of material)\n--OmegaMin xx  (minimum angular frequency)\n--OmegaMax xx  (maximum angular frequency)\n--gnuplot      (use GNUPLOT to plot results)\n--geometry xx  (.scuffgeo file containing material definition)\n\n\n\n\nRunning \nscuff-plotEpsMu --material MyMaterial\n\nwill produce an output file name \nMyMaterial.epsmu\n,\nwhich will contain 7 columns of data, representing the \npermittivity and permeability of your material at various \nangular frequencies on both the real and imaginary \n \naxes:\n\n\n\n\n\n\n \n\n Column   \n\n\n 1 \n \n 2 \n \n 3 \n \n 4 \n \n\n 5 \n \n 6 \n \n 7 \n\n\n \n\n \n\n Quantity \n\n\n \n \n\n\n Re \n(\n)  \n\n\n Im \n(\n)  \n\n\n Re \n(\n)  \n\n\n Im \n(\n)  \n\n\n \n(i\n) \n\n\n \n(i\n) \n\n\n \n\n\n\n\n\n\nIf \ngnuplot\n is installed on your system,\nthen you can use the \n--GnuPlot\n option to generate pop-up \nplots of \n\\epsilon(\\omega)\n and \n\\mu(\\omega)\n vs. \n\\omega\n\nfor your material.\n\n\nYou can use \n--OmegaMin/--OmegaMax\n to set the\nrange of angular frequencies over which material properties \nwill be plotted. The defaults are equivalent to specifying \n\n--OmegaMin 1e8\n and \n--OmegaMax 1e16\n, \nrespectively.\n\n\nIf your material is defined on-the-fly in a \n.scuffgeo\n \nfile, you can pass that file to \nscuff-plotEpsMu\n using \nthe \n--geometry\n option. (If your material is defined\nin a \nmaterial database file\n\nthen this option is not needed.)\n\n\nFor example, in \n\nthis example\n\nwe used a material named \nSiliconCarbide,\n which was defined\nin a geometry file named \nSiCSphere.scuffgeo.\n To check the\nthe frequency-dependent permittivity of this material, we can say\n\n\n% scuff-plotEpsMu --material SiliconCarbide --geometry SiCSphere.scuffgeo --gnuplot\n\n\n\n\nThis will pop up four graphs, of which one looks something like this:", 
            "title": "Material designations"
        }, 
        {
            "location": "/reference/Materials/#1-built-in-materials", 
            "text": "The two built-in materials are  Vacuum  and  PEC . The former describes a material with  \\epsilon=\\mu=1  at all frequencies, while the latter describes \na  P erfect  E lectrical  C onductor.", 
            "title": "1. Built-In Materials"
        }, 
        {
            "location": "/reference/Materials/#2-frequency-independent-materials", 
            "text": "For a non-magnetic material with frequency-independent permittivity \\epsilon , you can use a material specification of the form   MATERIAL CONST_EPS_11.8  where you would replace  11.8  with the constant value \nof the permittivity. (Note that  CONST_EPS_11.8  \nis all one word, with no spaces.)  For a material with frequency-independent permittivity  \\epsilon  and  frequency-independent permeability  \\mu\\ne1 , you can \nuse a material-property designation of the form   MATERIAL CONST_EPS_11.8_MU_0.8  where you would replace  0.8  with the constant value \nof the permeability. (Again, all one word, no spaces.)  You can also specify materials with negative and/or complex \npermittivity:   MATERIAL CONST_EPS_-54+46i  Of course, a dielectric function with a frequency-independent \nimaginary part is unphysical, but no problems will arise as long \nas you are only doing computations at a single frequency.", 
            "title": "2. Frequency-independent materials"
        }, 
        {
            "location": "/reference/Materials/#3-materials-specified-using-tabulated-data", 
            "text": "If you have tabulated frequency data for the permittivity and/or permeability\nof your material, you can specify this to  scuff-em  using a material \nspecification of the form  MATERIAL FILE_MyDataFile.dat  where the  FILE_  part of the string is fixed, and the \nremainder is the name of your data file (which is of course case-sensitive.)\nAgain, note that the material property specification is all one word with\nno spaces.  The data file is interpreted by  scuff-em \nin the following way:   Blank lines and comments (lines beginning with  # ) are ignored.  All other lines must contain either two or three space-separated \nstrings, which are interpreted as    Omega   Epsilon(Omega)   [ Mu(Omega) ]   where  Omega  is an angular frequency,  Epsilon(Omega)  \nis the relative permittivity at that frequency, and the optional Mu(Omega)  is the relative permeability.  The values specified for  Eps  and  Mu  may be complex numbers. .  Note that  \\omega  values in material data files are always specified\nin units of radians per second,  not  the specialized frequency\nunits that are used in  scuff-em  application codes.  For \nexample, an angular frequency of  3\\cdot 10^{14}  rad/sec would\nbe specified as  1.0  in (for example) the  --omega  argument\nto  scuff-scatter , but as  3.0e14  in a material data file.  For example, suppose you have tabulated data for the \nfrequency-dependent permittivity of silver over a finite\nrange of frequencies. Put those data into a text file\ncalled (for example)  Silver.dat \nwith the angular frequencies (in radians per second)\non the first column, and the complex relative permittivity\non the second column, so that the data file looks something\nlike this:  2.5133e15 -28.832+0.39369i\n2.6180e15 -26.235+0.35815i\n...\n5.2360e15 -2.3459+0.23547i\n5.3855e15 -1.7349+0.24727i  This says that, for example, at angular frequency \\omega=2.5133\\cdot 10^{15}\\hbox{ rad/sec}  we have \nrelative permittivity  \\epsilon(\\omega)=-28.832 + 0.39369i.   Then your  .scuffgeo  file may refer to a material\nnamed  FILE_Silver.dat,  whose dielectric function at\narbitrary frequencies  \\omega  will be obtained by\ninterpolating the data specified in your data file.\nFor example, to describe a sphere made of this material\nyour ``.scuffgeo'' file could contain a section like  OBJECT SilverSphere\n    MESHFILE Sphere.msh\n    MATERIAL FILE_Silver.dat\nENDOBJECT  Note: If you are doing calculations at  imaginary  frequencies\n(in  scuff-cas3d ,  scuff-caspol , or  scuff-scatter  with\nan imaginary value specified for  --omega )\nand you have tabulated data for the relative permittivity\non the imaginary frequency axis, you can play exactly the \nsame game described above, except that now the  \\omega \nvalues on the first column of the data file will be \npure imaginary (they will end in  i  or  I ).\n(Also, on physical grounds the relative permittivity at\neach frequency should be real-valued and positive in this \ncase).", 
            "title": "3. Materials specified using tabulated data"
        }, 
        {
            "location": "/reference/Materials/#4-user-defined-materials", 
            "text": "For more general materials, you will want to define your own\nfrequency-dependent material designations. You do this by \nfirst creating an entry in a database file that describes \nyour material, and then referring back to that entry in  .scuffgeo  files and anywhere else you need to \nspecify a material property designation. (Alternatively, \nyou can define the material on-the-fly inside a  MATERIAL...ENDMATERIAL  section in your  .scuffgeo  file. \nSee  here  for more details.", 
            "title": "4. User-defined materials"
        }, 
        {
            "location": "/reference/Materials/#the-location-of-the-database-file", 
            "text": "libmatprop  looks in the following three places for its \ndatabase file:    The file  ${HOME}/.matprop.dat  (i.e. a file \nnamed  .matprop.dat  in the top-level directory\nfor your user account.)    The file named by the environment variable  SCUFF_MATPROPFILE.      A file named  matprop.dat  in the current working\ndirectory. (Note the absence of a leading period as compared\nwith the previous item.)    Personally, I think the first or second of these options is the most\nconvenient; they allow you to create and maintain a single database\nfile that contains all the common materials you will ever need to use.", 
            "title": "The location of the database file"
        }, 
        {
            "location": "/reference/Materials/#entries-in-the-database-file", 
            "text": "A typical entry in the database file looks like this:  MATERIAL SiliconCarbide\n\n  EpsInf = 6.7;\n  a0     = -3.32377e28;\n  a1     = +8.93329e11;\n  b0     = -2.21677e28;\n  b1     = 8.93329e11;\n\n  Eps(w) = EpsInf * ( w^2 + a1*i*w + a0 ) / ( w^2 + b1*i*w + b0);\n\nENDMATERIAL  The first line defines the name of the material (the name you\nwould supply as an argument to the  MATERIAL  keyword \nin a  .scuffgeo  file, for example).  The next few lines define some constants. These constant\ndefinitions are specific to this particular  MATERIAL ;\ntwo different  MATERIAL  sections in the database \nfile may define the same constant to have two different values.  The line  Eps(w) = ...  defines the \nfrequency-dependent relative permittivity of your material.\nThe expression to the right of the  =  sign is \nparsed and interpreted as a function\nof the single variable  w,  the angular frequency.\nThe expression may refer to any of the constants you have defined \nfor the present material; it may also use the symbols i  and  I  to denote the imaginary unit.  Again,  \\omega  values in material property specifications are \nalways interpreted in units of radians per second,  not  the \nspecialized angular-frequency units that are used in some of the  scuff-em  application codes.  If your material has  \\mu\\ne 1 , you may optionally also include a line \nof the form  Mu(w) = some-function(w)", 
            "title": "Entries in the database file"
        }, 
        {
            "location": "/reference/Materials/#a-sample-database-file", 
            "text": "Here is a sample database file: matprop.dat .\nI recommend you rename this file to  ${HOME}/.matprop.dat  and \naugment it as necessary for your applications.", 
            "title": "A Sample Database File"
        }, 
        {
            "location": "/reference/Materials/#5-scuff-plotepsmu-a-command-line-utility-for-verifying-material-properties", 
            "text": "The  scuff-em  distribution comes with an application program named  scuff-plotEpsMu  that you\ncan use to make sure that a material property designation is \ninterpreted the way you intended. You can run this command with \nno arguments to get usage information:  % scuff-plotEpsMu \n\nerror: --material option is mandatory (aborting)\n\nusage: scuff-plotEpsMu [options]\n\noptions: \n\n--material xx  (name of material)\n--OmegaMin xx  (minimum angular frequency)\n--OmegaMax xx  (maximum angular frequency)\n--gnuplot      (use GNUPLOT to plot results)\n--geometry xx  (.scuffgeo file containing material definition)  Running  scuff-plotEpsMu --material MyMaterial \nwill produce an output file name  MyMaterial.epsmu ,\nwhich will contain 7 columns of data, representing the \npermittivity and permeability of your material at various \nangular frequencies on both the real and imaginary   \naxes:       Column      1     2     3     4     5     6     7        Quantity         Re  ( )     Im  ( )     Re  ( )     Im  ( )      (i )     (i )       If  gnuplot  is installed on your system,\nthen you can use the  --GnuPlot  option to generate pop-up \nplots of  \\epsilon(\\omega)  and  \\mu(\\omega)  vs.  \\omega \nfor your material.  You can use  --OmegaMin/--OmegaMax  to set the\nrange of angular frequencies over which material properties \nwill be plotted. The defaults are equivalent to specifying  --OmegaMin 1e8  and  --OmegaMax 1e16 , \nrespectively.  If your material is defined on-the-fly in a  .scuffgeo  \nfile, you can pass that file to  scuff-plotEpsMu  using \nthe  --geometry  option. (If your material is defined\nin a  material database file \nthen this option is not needed.)  For example, in  this example \nwe used a material named  SiliconCarbide,  which was defined\nin a geometry file named  SiCSphere.scuffgeo.  To check the\nthe frequency-dependent permittivity of this material, we can say  % scuff-plotEpsMu --material SiliconCarbide --geometry SiCSphere.scuffgeo --gnuplot  This will pop up four graphs, of which one looks something like this:", 
            "title": "5. scuff-plotEpsMu: A command-line utility for verifying material properties"
        }, 
        {
            "location": "/reference/Transformations/", 
            "text": "Geometrical transformations in \nscuff-em\n\n\nFor some of the physical problems handled by codes in the \n\nscuff-em\n suite, it is of interest\nto consider the effect of \ngeometrical transformations\n---namely, \nrigid displacements and rotations of the objects in a geometry with \nrespect to one another.\n\n\nFor example, if you are investigating the Casimir force between \ntwo nanoparticles of some exotic shape, you will probably want\nto carry out the calculation for many (let's say 25) different \nvalues of the interparticle separation and obtain the full \nforce-vs-separation \ncurve\n, not just the force on a single\nconfiguration.\n\n\nOf course, one way to handle this situation would be simply to\ncreate 25 different \n.scuffgeo\n files, each describing\nthe nanoparticles at different separation distances, and then run \n\nscuff-cas3d\n \n25 separate times. However, such a procedure would not only be a major\nhassle, but would also fail to exploit some significant \ncomputational redundancies.\n\n\nFor example, in a geometry consisting of two nanoparticles,\nthe diagonal blocks of the \n\nBEM matrix\n\nare \nindependent of the interparticle separation\n and hence \nneed only be assembled once per frequency, after which they \ncan be \nreused\n for all 25 interparticle separations.\nThis can save a lot of time as compared to the cost of \nrunning 25 independent calculations.\n\n\nTo facilitate this type of calculation, several of the \nstandalone applications in the \n\nscuff-em\n \nsuite offer the option of specifying a \ntransformation list.\n\nThis is a file describing a sequence of geometrical transformations\nto be carried out on the base geometry described by your \n\n.scuffgeo\n file. Each output quantity that you\nrequest (be it the \ny-\ndirected Casimir force, the \ntotal heat transfer, or what have you) will then be computed\nand reported separately for each of the transformations you \nspecified.\n\n\nAn important caveat is that \n\ngeometrical transformations may not change the \nnesting topology\n of a \n\nscuff-em\n geometry.\n This is discussed in more detail\n\nbelow\n.\n\n\n\n\n\n \n \n\n Geometrical Transformations in\n                      \nscuff-em\n\n                 \n\n\n\n\n \n \nSyntax of the \n.trans\n file\n\n \n \nAn example of a \n.trans\n file\n\n \n \nVisualizing the effect of the transformations you specified\n\n \n \nTransformations may not change the nesting topology\n\n\n\n\n\n\n\n1. Syntax of the \n.trans\n file\n\n\nYou will list your geometrical transformations in a file \nwhose name conventionally has file extension \n.trans\n.\nThis is the file you will specify using the \n\n--transfile\n option to \n\nscuff-cas3d\n \nand other codes.\n\n\nThe \n.trans\n file may contain any number of \ntransformations. \nEach transformation will specify \nwhich\n objects in your\ngeometry are to be transformed, and \nhow\n those objects \nwill be displaced or rotated. \n\n\nEach transformation will be specified by a section of the file\nthat looks something like this:\n\n\n\n\nTRANSFORMATION\n \nname-of-transformation\n\n\n \n \n \nOBJECT\n \nFirstObjectLabel\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n ...\n\n\n \n \n \nOBJECT\n \nSecondObjectLabel\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n ...\n\n\nENDTRANSFORMATION\n\n\n\n\nThe \nname-of-transformation\n field after the \n\nTRANSFORMATION\n keyword specifies a mandatory label\nassigned to this transformation, which will be used\nin output files to identify quantities computed under this\ntransformation. \n\n\nThe \nFirstObjectLabel\n field should be the label of\nan object in your geometry (as assigned using the \nOBJECT\n\nkeyword in a \n.scuffgeo\n file\n.\nDisplacements and rotations specified after this line will apply to the\nobject named on this line, until the next \nOBJECT\n line is \nencountered.\n\n\nEach \ndisplacement-or-rotation\n line should look either like\nthis:\n\n\n\n\n\n\nDISPLACED\n   \nxx yy zz\n\n\n\n\n\n\nor like this:\n\n\n\n\n\n\nROTATED\n \ndd\n \nABOUT\n \nnx ny nz\n\n\n\n\n\n\nThe former case specifies that the object in question is to be displaced\nthrough a displacement vector with cartesian coordinates \n\n(xx,yy,zz)\n.\n\n\nThe latter case specifies that the object in question is to be rotated\nthrough \ndd\n degrees about an axis passing through the origin\nand through the point with cartesian coordinates \n(xx,yy,zz).\n\nNote that \nABOUT\n is a fixed keyword that must be repeated\nverbatim.\n\n(Note that the rotation angle is specified in \ndegrees, not radians.)\n\n\nYou may specify any number of \nDISPLACEMENT\n and \n\nROTATION\n statements to be applied to each object.\nThese statements will be applied in the order they are \nspecified in the \n.trans\n file.\n\n\nNote that \nTRANSFORMATION...ENDTRANSFORMATION\n\nsections are not cumulative; two consecutive such sections do not \nbuild on each other, but instead describe distinct transformations\napplied to the geometry starting in its original state as described \nin the \n.scuffgeo\n file.\n\n\n(However, if your \n.scuffgeo\n included any \n\nDISPLACED\n or \nROTATED\n statements to\ntransform object meshes prior to their inclusion in the\ngeometry, then the transformations in a \n.trans\n\nfile \nare\n cumulative with respect to those, as any\nsuch transformations are considered to be included\ninto the base default configuration of the geometry.)\n\n\nBlank lines and comments (lines beginning with \n#\n) in\n\n.trans\n files are ignored.\n\n\nAbbreviated Syntax\n\n\nFor simple transformations you may use the following\nabbreviated one-line syntax in place of an entire\n\nTRANSFORMATION...ENDTRANSFORMATION\n section:\n\n\n\n\nTRANS\n \nname\n \nOBJECT\n \nLabel\n   \ndisplacement-or-rotation\n\n\n\n\nThis differs from the syntax outlined above in the following\nways: \n\n\n\n\nThe entire transformation is specified on a single line.\n\n\nThe line begins with the shortened keyword \nTRANS\n, and there is no terminating keyword.\n\n\n\n\nEmpty Transformations\n\n\nThe following transformations are perfectly legal:\n\n\nTRANSFORMATION Nothing\nENDTRANSFORMATION\n\n\n\n\nTRANS Default\n\n\n\n\nThese define \ntransformations\n that actually leave the geometry\nuntouched from the configuration specified in the \n.scuffgeo\n\nfile. You may name these transformations anything you please, just\nas with any other transformations. This is sometimes useful for\ncarrying out computations on a sequence of geometric configurations\nof which one is the unmodified configuration of the \n.scuffgeo\n\nfile.\n\n\n\n\n2. An example of a \n.trans\n file\n\n\nHere's an example of a \n.trans\n file designed to \nbe used with \nthis geometry file\n,\nwhich contains two objects with\nuser-assigned labels \nTheSphere\n and \nTheCube\n.\n\n\nNote that, in the \n.scuffgeo\n file, the cube is \ndisplaced 3 units in the positive \nz\n direction relative \nto the configuration of its mesh file; as noted above,\ntransformations in the \n.trans\n are \ncarried out starting from that displaced configuration.\n\n\nThis file declares three separate transformations:\n\n\n\n\n\n\nThe first (labeled \n2.0\n) displaces the sphere 2.0 \nlength units in the \ny\n direction, while simultaneously \ndisplacing the cube 2.0 units in the \nx\n direction.  \n\n\n\n\n\n\nThe second (labeled \n2.0R\n) is the same as the \nfirst, but with the cube first rotated 45 degrees \n(\n/4 radians) about the \nz\n axis before it is \ndisplaced.  \n\n\n\n\n\n\nThe third (labeled \n-3.0\n) displaces the sphere \nnegative 3.0 length units in the \ny\n direction, while\nleaving the cube untouched.\n\n\n\n\n\n\n# a transformation in which both cube and sphere are displaced \nTRANSFORMATION 2.0\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# similar to the above, but now the square is rotated before it is displaced\nTRANSFORMATION 2.0R\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nROTATED      45 ABOUT 0 0 1 \nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# in this transformation, only the sphere is affected, so we can use the abbreviated syntax\nTRANS -3.0 OBJECT TheSphere DISP 0.0 -3.0 0.0\n\n\n\n\n\n\n3. Visualizing the effect of the transformations you specified\n\n\nBefore running a full calculation using a \n.trans\n\nfile, you will generally want to double-check to make sure \nthat the geometrical transformations as interpreted by \n\nscuff-em\n are actually what \nyou intended. \n\n\nA simple way to do this is to use the \n\nscuff-analyze\n\nutility application that comes with the \nscuff-em\n distribution. \nInvoking this utility\nwith the \n--geometry\n and \n--transfile\n\noptions to specify your \n.scuffgeo\n and \n\n.trans\n files will produce an output file \ncalled \nMyGeometry.transformed.pp\n \n(where \nMyGeometry.scuffgeo\n was the name of the \nyour geometry file) which you can open in \n\ngmsh\n.\n\n\nFor example, to visualize the impact of the transformations \nin the example above, we could proceed as follows.\n(All the files needed to execute this example may be found\nin the \nexamples/SphereCube\n directory of the \n\nscuff-em\n source distribution.)\n\n\n% scuff-analyze --geometry SphereCube.scuffgeo --transfile SphereCube.trans\n\n\n\n\nThis will generate a file named \nSphereCube.transformed.pp\n\nthat you can open in \ngmsh\n:\n\n\n% gmsh SphereCube.transformed.pp\n\n\n\n\n\n\n\n\n\n\nNote that the items in the \ngmsh\n\nmenu here are labeled using the strings you assigned to each\ntransformation in your \n.trans\n file (the\n\nname-of-transformation\n field in the syntax \ndescription above).\n\n\n\n\n4. Geometrical transformations may not change the nesting topology\n\n\nAn important restriction on the use of geometrical transformations \nin \nscuff-em\n is that transformations \nmay not change the \nnesting topology\n of a \n\nscuff-em\n geometry -- that is, the \ncontainership relations that classify which objects are \nembedded inside which other objects. This is because \n\nscuff-em\n autodetects the nesting \ntopology when it first reads in the \n.scuffgeo\n\nfile and cannot subsequently redefine it.\n\n\nFor example, perhaps your \n.scuffgeo\n file describes \na geometry consisting of a big sphere (perhaps filled with a dielectric \nliquid like water) and a smaller sphere (perhaps a ball of silicon) \ninside this sphere. In this case, you can use geometrical \ntransformations to move the smaller sphere around \nwithin\n the \nlarger sphere, but you may not write a geometrical transformation\nthat displaces the smaller sphere all the way \noutside\n \nthe larger sphere. If you want to run simulations in which the \nsmaller sphere lies outside the larger sphere, you will need to \nwrite a new \n.scuffgeo\n file in which that condition \nis satisfied from the start.\n\n\n(Also, you may not write a geometrical transformation that \ndisplaces the smaller sphere in such a way that its surface\nintersects the surface of the larger sphere -- in that case,\nyour geometry would contain a\n\nmulti-material junction\n\nand would require a \n.scuffgeo\n description in terms of \n\nREGIONS\n and \nSURFACES\n instead of the simpler \ndescription in terms of \nOBJECTS\n\nthat suffices for fully-embedded geometries.)\n\n\nAs another example, suppose you want to compute the Casimir force \nbetween two identical dielectric objects over a range of separations. \nIn this case, you might be tempted to write a \n.scuffgeo\n \nfile in which the two objects start out lying on top of each other,\nand then displace them using geometrical transformations in the\nactual force computation. However, this won't work: when \n\nscuff-em\n first processes the \n\n.scuffgeo\n file, it will be confused by the appearance\nof two objects appearing to coexist in the same physical space,\nand the nesting topology will be incorrectly characterized.\nInstead, you will want to start out with a \n.scuffgeo\n\nfile in which the objects are displaced from one another; you can,\nof course, subsequently rotate or displace them further to your\nheart's content using geometrical transformations.", 
            "title": "Geometric transformations"
        }, 
        {
            "location": "/reference/Transformations/#1-syntax-of-the-trans-file", 
            "text": "You will list your geometrical transformations in a file \nwhose name conventionally has file extension  .trans .\nThis is the file you will specify using the  --transfile  option to  scuff-cas3d  \nand other codes.  The  .trans  file may contain any number of \ntransformations. \nEach transformation will specify  which  objects in your\ngeometry are to be transformed, and  how  those objects \nwill be displaced or rotated.   Each transformation will be specified by a section of the file\nthat looks something like this:   TRANSFORMATION   name-of-transformation        OBJECT   FirstObjectLabel              displacement-or-rotation              displacement-or-rotation             ...        OBJECT   SecondObjectLabel              displacement-or-rotation              displacement-or-rotation             ...  ENDTRANSFORMATION   The  name-of-transformation  field after the  TRANSFORMATION  keyword specifies a mandatory label\nassigned to this transformation, which will be used\nin output files to identify quantities computed under this\ntransformation.   The  FirstObjectLabel  field should be the label of\nan object in your geometry (as assigned using the  OBJECT \nkeyword in a  .scuffgeo  file .\nDisplacements and rotations specified after this line will apply to the\nobject named on this line, until the next  OBJECT  line is \nencountered.  Each  displacement-or-rotation  line should look either like\nthis:    DISPLACED     xx yy zz    or like this:    ROTATED   dd   ABOUT   nx ny nz    The former case specifies that the object in question is to be displaced\nthrough a displacement vector with cartesian coordinates  (xx,yy,zz) .  The latter case specifies that the object in question is to be rotated\nthrough  dd  degrees about an axis passing through the origin\nand through the point with cartesian coordinates  (xx,yy,zz). \nNote that  ABOUT  is a fixed keyword that must be repeated\nverbatim. (Note that the rotation angle is specified in \ndegrees, not radians.)  You may specify any number of  DISPLACEMENT  and  ROTATION  statements to be applied to each object.\nThese statements will be applied in the order they are \nspecified in the  .trans  file.  Note that  TRANSFORMATION...ENDTRANSFORMATION \nsections are not cumulative; two consecutive such sections do not \nbuild on each other, but instead describe distinct transformations\napplied to the geometry starting in its original state as described \nin the  .scuffgeo  file.  (However, if your  .scuffgeo  included any  DISPLACED  or  ROTATED  statements to\ntransform object meshes prior to their inclusion in the\ngeometry, then the transformations in a  .trans \nfile  are  cumulative with respect to those, as any\nsuch transformations are considered to be included\ninto the base default configuration of the geometry.)  Blank lines and comments (lines beginning with  # ) in .trans  files are ignored.", 
            "title": "1. Syntax of the .trans file"
        }, 
        {
            "location": "/reference/Transformations/#abbreviated-syntax", 
            "text": "For simple transformations you may use the following\nabbreviated one-line syntax in place of an entire TRANSFORMATION...ENDTRANSFORMATION  section:   TRANS   name   OBJECT   Label     displacement-or-rotation   This differs from the syntax outlined above in the following\nways:    The entire transformation is specified on a single line.  The line begins with the shortened keyword  TRANS , and there is no terminating keyword.", 
            "title": "Abbreviated Syntax"
        }, 
        {
            "location": "/reference/Transformations/#empty-transformations", 
            "text": "The following transformations are perfectly legal:  TRANSFORMATION Nothing\nENDTRANSFORMATION  TRANS Default  These define  transformations  that actually leave the geometry\nuntouched from the configuration specified in the  .scuffgeo \nfile. You may name these transformations anything you please, just\nas with any other transformations. This is sometimes useful for\ncarrying out computations on a sequence of geometric configurations\nof which one is the unmodified configuration of the  .scuffgeo \nfile.", 
            "title": "Empty Transformations"
        }, 
        {
            "location": "/reference/Transformations/#2-an-example-of-a-trans-file", 
            "text": "Here's an example of a  .trans  file designed to \nbe used with  this geometry file ,\nwhich contains two objects with\nuser-assigned labels  TheSphere  and  TheCube .  Note that, in the  .scuffgeo  file, the cube is \ndisplaced 3 units in the positive  z  direction relative \nto the configuration of its mesh file; as noted above,\ntransformations in the  .trans  are \ncarried out starting from that displaced configuration.  This file declares three separate transformations:    The first (labeled  2.0 ) displaces the sphere 2.0 \nlength units in the  y  direction, while simultaneously \ndisplacing the cube 2.0 units in the  x  direction.      The second (labeled  2.0R ) is the same as the \nfirst, but with the cube first rotated 45 degrees \n( /4 radians) about the  z  axis before it is \ndisplaced.      The third (labeled  -3.0 ) displaces the sphere \nnegative 3.0 length units in the  y  direction, while\nleaving the cube untouched.    # a transformation in which both cube and sphere are displaced \nTRANSFORMATION 2.0\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# similar to the above, but now the square is rotated before it is displaced\nTRANSFORMATION 2.0R\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nROTATED      45 ABOUT 0 0 1 \nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# in this transformation, only the sphere is affected, so we can use the abbreviated syntax\nTRANS -3.0 OBJECT TheSphere DISP 0.0 -3.0 0.0", 
            "title": "2. An example of a .trans file"
        }, 
        {
            "location": "/reference/Transformations/#3-visualizing-the-effect-of-the-transformations-you-specified", 
            "text": "Before running a full calculation using a  .trans \nfile, you will generally want to double-check to make sure \nthat the geometrical transformations as interpreted by  scuff-em  are actually what \nyou intended.   A simple way to do this is to use the  scuff-analyze \nutility application that comes with the  scuff-em  distribution. \nInvoking this utility\nwith the  --geometry  and  --transfile \noptions to specify your  .scuffgeo  and  .trans  files will produce an output file \ncalled  MyGeometry.transformed.pp  \n(where  MyGeometry.scuffgeo  was the name of the \nyour geometry file) which you can open in  gmsh .  For example, to visualize the impact of the transformations \nin the example above, we could proceed as follows.\n(All the files needed to execute this example may be found\nin the  examples/SphereCube  directory of the  scuff-em  source distribution.)  % scuff-analyze --geometry SphereCube.scuffgeo --transfile SphereCube.trans  This will generate a file named  SphereCube.transformed.pp \nthat you can open in  gmsh :  % gmsh SphereCube.transformed.pp     Note that the items in the  gmsh \nmenu here are labeled using the strings you assigned to each\ntransformation in your  .trans  file (the name-of-transformation  field in the syntax \ndescription above).", 
            "title": "3. Visualizing the effect of the transformations you specified"
        }, 
        {
            "location": "/reference/Transformations/#4-geometrical-transformations-may-not-change-the-nesting-topology", 
            "text": "An important restriction on the use of geometrical transformations \nin  scuff-em  is that transformations \nmay not change the  nesting topology  of a  scuff-em  geometry -- that is, the \ncontainership relations that classify which objects are \nembedded inside which other objects. This is because  scuff-em  autodetects the nesting \ntopology when it first reads in the  .scuffgeo \nfile and cannot subsequently redefine it.  For example, perhaps your  .scuffgeo  file describes \na geometry consisting of a big sphere (perhaps filled with a dielectric \nliquid like water) and a smaller sphere (perhaps a ball of silicon) \ninside this sphere. In this case, you can use geometrical \ntransformations to move the smaller sphere around  within  the \nlarger sphere, but you may not write a geometrical transformation\nthat displaces the smaller sphere all the way  outside  \nthe larger sphere. If you want to run simulations in which the \nsmaller sphere lies outside the larger sphere, you will need to \nwrite a new  .scuffgeo  file in which that condition \nis satisfied from the start.  (Also, you may not write a geometrical transformation that \ndisplaces the smaller sphere in such a way that its surface\nintersects the surface of the larger sphere -- in that case,\nyour geometry would contain a multi-material junction \nand would require a  .scuffgeo  description in terms of  REGIONS  and  SURFACES  instead of the simpler \ndescription in terms of  OBJECTS \nthat suffices for fully-embedded geometries.)  As another example, suppose you want to compute the Casimir force \nbetween two identical dielectric objects over a range of separations. \nIn this case, you might be tempted to write a  .scuffgeo  \nfile in which the two objects start out lying on top of each other,\nand then displace them using geometrical transformations in the\nactual force computation. However, this won't work: when  scuff-em  first processes the  .scuffgeo  file, it will be confused by the appearance\nof two objects appearing to coexist in the same physical space,\nand the nesting topology will be incorrectly characterized.\nInstead, you will want to start out with a  .scuffgeo \nfile in which the objects are displaced from one another; you can,\nof course, subsequently rotate or displace them further to your\nheart's content using geometrical transformations.", 
            "title": "4. Geometrical transformations may not change the nesting topology"
        }, 
        {
            "location": "/reference/IncidentFields/", 
            "text": "Incident fields in \nscuff-em\n\n\nFor the classical scattering problems solved by\n\nscuff-scatter\n\nor by C++ or python codes using the\n\nscuff-em\n API\n,\nyou will want to specify the incident fields that\nscatter from your geometry.\n\n\nThe default \nscuff-em\n distribution offers three\nbuilt-in types of incident fields:\n\n\n\n\nPlane waves\n\n\nGaussian beams\n\n\nThe fields of \npoint electric or magnetic dipole sources.\n\n\n\n\nIf you only need to run scattering calculations with a single\ntype of incident field, you can just specify that field on\nthe command line, as described in the sections below. If you\nwant to run scattering calculations with multiple types of\nincident field (for example, perhaps at each frequency you\nwant to consider two different plane-wave polarizations,\nor three different point-source locations) you will want\nto write an \n\nincident-field file\n describing an entire \nlist\n\nof incident fields.\n\n\nTable of Contents\n\n\nIncident fields in \nscuff-em\n\n\nBuilt-in types of incident field\n\n\nPlane waves\n\n\nGaussian beams\n\n\nPoint sources\n\n\n\n\n\n\nSpecifying an entire list of incident fields\n\n\nExample of an incident-field file\n\n\n\n\n\n\nUsing incident fields in API programs\n\n\n\n\n\n\nIt is also easy to \ndefine your own custom incident fields\n\nfor use in API programs.\n\n\nBuilt-in types of incident field\n\n\n\n\nPlane waves\n\n\nscuff-scatter\n command-line syntax:\n\n\n--pwDirection nx ny nz\n--pwPolarization Ex Ey Ez \n\n\n\n\nC++ code:\n\n\n  double  nHat[3] = {nx, ny, nz};\n  cdouble E0[3]   = {Ex, Ey, Ez};\n  PlaneWave *PW=new PlaneWave(E0, nHat);\n\n\n\n\nSelects the incident field to be a plane wave, with propagation vector \n\nn\n=\n(nx,ny,nz)\n and \nE\n-field polarization vector \nE\n=\n(Ex,Ey,Ez).\n\n\nMore specifically, the fields of a plane wave are\n\n\n\n\nwhere the components of the vectors \n\\mathbf{\\hat n}\n \nand \n\n\\mathbf{E}_0\n\nare what you specify with the \n--pwDirection\n and \n\n--pwPolarization\n options to \nscuff-scatter\n. (The frequency \n\n\\omega\n is specified elsewhere, for example using \ncommand-line options like \n--omega.\n The\nquantities \n\\epsilon\n and \n\\mu\n are the material properties of\nthe exterior medium at this frequency, which are determined by\nthe material property designation you give the external medium\nin the \n.scuffgeo\n file; the wave impedance of the medium is\n\nZ=\\sqrt{\\mu/\\epsilon}\\approx 377\\,\\Omega\n in vacuum.)\n\n\nThe values specified for \n--pwPolarization\n may be\n\ncomplex numbers.\n\n\nAs an example, the \nscuff-scatter\n command-line options\n\n\n--pwDirection 0 0 1 --pwPolarization 0.7071 0.7071i 0.0\n\n\n\n\nwill specify an incident field consisting of a circularly\npolarized plane wave traveling in the positive \nz\n direction.\n\n\n\n\nGaussian beams\n\n\nscuff-scatter\n command-line syntax:\n\n\n--gbCenter Cx Cy Cz\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbWaist W\n\n\n\n\nC++ code:\n\n\n  double X0[3]={Cx, Cy, Cz};     /* beam center point */\n  double KProp[3]={nx, ny, nz};  /* beam propagation vector */\n  cdouble E0[3]={Ex, Ey, Ez};    /* complex field-strength vector */\n  double W0=W;                   /* beam waist */\n  GaussianBeam *GB=new GaussianBeam(X0, KProp, E0, W0);\n\n\n\n\nSelects the incident field to be a focused Gaussian beam, \ntraveling in the direction defined by the unit vector \n\nn\n=\n(nx,ny,nz)\n, with \nE\n-field polarization \nvector \nE\n=\n(Ex,Ey,Ez)\n, beam center point with cartesian \ncoordinates \nC\n=\n(Cx,Cy,Cz)\n, and beam waist \nW\n.\n\n\nThe values specified for \n--gbPolarization\n may be\n\ncomplex numbers.\n\n\nThe \nscuff-em\n implementation of the\nfield of a Gaussian laser beam was contributed by \nJohannes Feist and follows this paper:\n\n\n\n\nSheppard and Saghafi, \"Electromagnetic Gaussian Beams \nBeyond the Paraxial Approximation,\" \nJournal of the Optical \nSociety of America A\n \n16\n 1381 (1999), \nhttp://dx.doi.org/10.1364/JOSAA.16.001381\n.\n\n\n\n\n\n\nPoint sources\n\n\nscuff-scatter\n command-line syntax:\n\n\n--psStrength Px Py Pz\n--psLocation xx yy zz\n\n\n\n\nC++ code:\n\n\n  double  X0[3] = {xx, yy, zz};\n  cdouble P0[3] = {Px, Py, Pz};\n  PointSource *PS=new PointSource(X0, P0);\n\n\n\n\nSelects the incident field to be the field of a pointlike\nelectric dipole radiator with dipole moment \nP\n=\n(Px,Py,Pz)\n\nand located at cartesian coordinates (\nxx,yy,zz\n).\n\n\nMore specifically, the fields of a point source are given by\n\n\n\n\nThe values specified for \n--psStrength\n may be\n\ncomplex numbers.\n\n\nYou may define the incident field to be a superposition of\nthe fields of multiple point sources by specifying these\noptions more than once. (The \nn\nth occurrence of \n--psStrength\n\nwill be paired with the \nn\nth occurrence of \n--psLocation.\n)\n\n\nIn API codes (but not in \nscuff-scatter\n) it is also\npossible to a define a magnetic point source as follows:\n\n\n  PointSource *PS=new PointSource(X0, P0);\n\n\n\n\n\n\nSpecifying an entire list of incident fields\n\n\nA feature of the \n\nsurface-integral-equation solver implemented by \nscuff-em\n\nis that, once the computational work needed to solve a single\nscattering problem (for a given geometry at given frequency irradiated\nby a single incident field) has been done, there is relatively little\ncomputational cost required to solve additional problems (for the same \ngeometry at the same frequency) with different incident fields.\nTo exploit this feature, you may write an \"incident-field file\"\n(a simple text file) describing multiple types of incident field \nwith which to irradiate your geometry.\n\n\nExample of an incident-field file\n\n\nHere's an example\n of an incident-field file describing 9 \ndifferent incident fields. If you specify this file\nusing the \n--IFFile\n command-line option to\n\nscuff-scatter\n,\nthen every calculation you request (scattered fields,\npower/force/torque, visualization, etc.) will be \ndone 7 times at each frequency, once for each field.\n\n\nEX    PW    0  0  1       1          0          0\nEY    PW    0  0  1       0          1          0\nLC    PW    0  0  1       0.7071     0.7071i    0\nRC    PW    0  0  1       0.7071    -0.7071i    0\n\nPS1   PS    1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\nPS2   MPS   1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\n\nGB    GB    0.0 0.0 0.0   0.0 0.0 1.0    1.0 0.0 0.0    0.5\n\nCOMPOUND1\n  PW    0   0  1      1        0        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND\n\nCOMPOUND2\n  PW    0   0  1      0        1        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND\n\n\n\n\nHere's how to understand the 9 incident fields described\nby this file.\n\n\n\n\n\n\nThe first several lines define various types of incident\nfields in which there is only a single field source. For \nthis type of incident field, the first word on the \nline is an \narbitrary user-specified label (such as \nEX\n or \nPS1\n)\nthat will be used to identify data corresponding to \nthis incident field in output files.\nThe second word on the line is one of the four \nkeywords \nPW|PS|MPS|GB\n. The remainder of the line\nconsists of numerical parameters:\n\n\n\n\n\n\nFor \nplane waves\n (keyword \nPW\n) there are 6 numerical parameters: \nnx ny nz Ex Ey Ez\n. In the example above, \nEX\n and \nEY\n are linearly-polarized plane waves, while \nLC\n and \nRC\n are left- and right-circularly polarized waves.\n\n\n\n\n\n\nFor \nelectric-dipole point sources\n (keyword \nPS\n) there are 6 numerical parameters: \nxx yy zz Px Py Pz\n.\n\n\n\n\n\n\nFor \nmagnetic-dipole point sources\n (keyword \nMPS\n) there are 6 numerical parameters: \nxx yy zz Mx My Mz\n.\n\n\n\n\n\n\nFor \ngaussian beams\n (keyword \nGB\n) there are 10 numerical parameters: \nCx Cy Cz nx ny nz Ex Ey Ez W\n.    \n\n\n\n\n\n\n\n\n\n\nThe final two sections of the file describe \ncompound\n fields---that is,\nincident fields produced by more than one source acting simultaneously.\nThese types of fields are described by putting their label (here\n\nCOMPOUND1\n or \nCOMPOUND2\n) on line by itself, then specifying\nas many \nPW|PS|MPS|GB\n lines as you like, and finally closing \nthe compound-field definition with the \nEND\n keyword.\nFor example, the field we labeled \nCOMPOUND1\n consists of a\nplanewave acting simultaneously with the field of a point source.\n\n\n\n\n\n\n\n\nUsing incident fields in API programs\n\n\nPlease see \n\nhere\n\nfor further details and examples of how incident fields are manipulated in API codes, including an example of how to create your\nown custom-designed incident field.", 
            "title": "Incident fields"
        }, 
        {
            "location": "/reference/IncidentFields/#built-in-types-of-incident-field", 
            "text": "", 
            "title": "Built-in types of incident field"
        }, 
        {
            "location": "/reference/IncidentFields/#plane-waves", 
            "text": "scuff-scatter  command-line syntax:  --pwDirection nx ny nz\n--pwPolarization Ex Ey Ez   C++ code:    double  nHat[3] = {nx, ny, nz};\n  cdouble E0[3]   = {Ex, Ey, Ez};\n  PlaneWave *PW=new PlaneWave(E0, nHat);  Selects the incident field to be a plane wave, with propagation vector  n = (nx,ny,nz)  and  E -field polarization vector  E = (Ex,Ey,Ez).  More specifically, the fields of a plane wave are   where the components of the vectors  \\mathbf{\\hat n}  \nand  \\mathbf{E}_0 \nare what you specify with the  --pwDirection  and  --pwPolarization  options to  scuff-scatter . (The frequency  \\omega  is specified elsewhere, for example using \ncommand-line options like  --omega.  The\nquantities  \\epsilon  and  \\mu  are the material properties of\nthe exterior medium at this frequency, which are determined by\nthe material property designation you give the external medium\nin the  .scuffgeo  file; the wave impedance of the medium is Z=\\sqrt{\\mu/\\epsilon}\\approx 377\\,\\Omega  in vacuum.)  The values specified for  --pwPolarization  may be complex numbers.  As an example, the  scuff-scatter  command-line options  --pwDirection 0 0 1 --pwPolarization 0.7071 0.7071i 0.0  will specify an incident field consisting of a circularly\npolarized plane wave traveling in the positive  z  direction.", 
            "title": "Plane waves"
        }, 
        {
            "location": "/reference/IncidentFields/#gaussian-beams", 
            "text": "scuff-scatter  command-line syntax:  --gbCenter Cx Cy Cz\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbWaist W  C++ code:    double X0[3]={Cx, Cy, Cz};     /* beam center point */\n  double KProp[3]={nx, ny, nz};  /* beam propagation vector */\n  cdouble E0[3]={Ex, Ey, Ez};    /* complex field-strength vector */\n  double W0=W;                   /* beam waist */\n  GaussianBeam *GB=new GaussianBeam(X0, KProp, E0, W0);  Selects the incident field to be a focused Gaussian beam, \ntraveling in the direction defined by the unit vector  n = (nx,ny,nz) , with  E -field polarization \nvector  E = (Ex,Ey,Ez) , beam center point with cartesian \ncoordinates  C = (Cx,Cy,Cz) , and beam waist  W .  The values specified for  --gbPolarization  may be complex numbers.  The  scuff-em  implementation of the\nfield of a Gaussian laser beam was contributed by \nJohannes Feist and follows this paper:   Sheppard and Saghafi, \"Electromagnetic Gaussian Beams \nBeyond the Paraxial Approximation,\"  Journal of the Optical \nSociety of America A   16  1381 (1999),  http://dx.doi.org/10.1364/JOSAA.16.001381 .", 
            "title": "Gaussian beams"
        }, 
        {
            "location": "/reference/IncidentFields/#point-sources", 
            "text": "scuff-scatter  command-line syntax:  --psStrength Px Py Pz\n--psLocation xx yy zz  C++ code:    double  X0[3] = {xx, yy, zz};\n  cdouble P0[3] = {Px, Py, Pz};\n  PointSource *PS=new PointSource(X0, P0);  Selects the incident field to be the field of a pointlike\nelectric dipole radiator with dipole moment  P = (Px,Py,Pz) \nand located at cartesian coordinates ( xx,yy,zz ).  More specifically, the fields of a point source are given by   The values specified for  --psStrength  may be complex numbers.  You may define the incident field to be a superposition of\nthe fields of multiple point sources by specifying these\noptions more than once. (The  n th occurrence of  --psStrength \nwill be paired with the  n th occurrence of  --psLocation. )  In API codes (but not in  scuff-scatter ) it is also\npossible to a define a magnetic point source as follows:    PointSource *PS=new PointSource(X0, P0);", 
            "title": "Point sources"
        }, 
        {
            "location": "/reference/IncidentFields/#specifying-an-entire-list-of-incident-fields", 
            "text": "A feature of the  surface-integral-equation solver implemented by  scuff-em \nis that, once the computational work needed to solve a single\nscattering problem (for a given geometry at given frequency irradiated\nby a single incident field) has been done, there is relatively little\ncomputational cost required to solve additional problems (for the same \ngeometry at the same frequency) with different incident fields.\nTo exploit this feature, you may write an \"incident-field file\"\n(a simple text file) describing multiple types of incident field \nwith which to irradiate your geometry.", 
            "title": "Specifying an entire list of incident fields"
        }, 
        {
            "location": "/reference/IncidentFields/#example-of-an-incident-field-file", 
            "text": "Here's an example  of an incident-field file describing 9 \ndifferent incident fields. If you specify this file\nusing the  --IFFile  command-line option to scuff-scatter ,\nthen every calculation you request (scattered fields,\npower/force/torque, visualization, etc.) will be \ndone 7 times at each frequency, once for each field.  EX    PW    0  0  1       1          0          0\nEY    PW    0  0  1       0          1          0\nLC    PW    0  0  1       0.7071     0.7071i    0\nRC    PW    0  0  1       0.7071    -0.7071i    0\n\nPS1   PS    1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\nPS2   MPS   1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\n\nGB    GB    0.0 0.0 0.0   0.0 0.0 1.0    1.0 0.0 0.0    0.5\n\nCOMPOUND1\n  PW    0   0  1      1        0        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND\n\nCOMPOUND2\n  PW    0   0  1      0        1        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND  Here's how to understand the 9 incident fields described\nby this file.    The first several lines define various types of incident\nfields in which there is only a single field source. For \nthis type of incident field, the first word on the \nline is an \narbitrary user-specified label (such as  EX  or  PS1 )\nthat will be used to identify data corresponding to \nthis incident field in output files.\nThe second word on the line is one of the four \nkeywords  PW|PS|MPS|GB . The remainder of the line\nconsists of numerical parameters:    For  plane waves  (keyword  PW ) there are 6 numerical parameters:  nx ny nz Ex Ey Ez . In the example above,  EX  and  EY  are linearly-polarized plane waves, while  LC  and  RC  are left- and right-circularly polarized waves.    For  electric-dipole point sources  (keyword  PS ) there are 6 numerical parameters:  xx yy zz Px Py Pz .    For  magnetic-dipole point sources  (keyword  MPS ) there are 6 numerical parameters:  xx yy zz Mx My Mz .    For  gaussian beams  (keyword  GB ) there are 10 numerical parameters:  Cx Cy Cz nx ny nz Ex Ey Ez W .          The final two sections of the file describe  compound  fields---that is,\nincident fields produced by more than one source acting simultaneously.\nThese types of fields are described by putting their label (here COMPOUND1  or  COMPOUND2 ) on line by itself, then specifying\nas many  PW|PS|MPS|GB  lines as you like, and finally closing \nthe compound-field definition with the  END  keyword.\nFor example, the field we labeled  COMPOUND1  consists of a\nplanewave acting simultaneously with the field of a point source.", 
            "title": "Example of an incident-field file"
        }, 
        {
            "location": "/reference/IncidentFields/#using-incident-fields-in-api-programs", 
            "text": "Please see  here \nfor further details and examples of how incident fields are manipulated in API codes, including an example of how to create your\nown custom-designed incident field.", 
            "title": "Using incident fields in API programs"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/", 
            "text": "Brillouin-zone integration in \nscuff-em\n\n\nMany codes in the \nscuff-em\n suite require evaluating\nintegrals over the Brillouin zone (BZ) of a 1D or 2D\nreciprocal lattice, i.e.\n\n\n\n\nQ(\\omega) = \\int_\\text{BZ} \\overline{Q}(\\omega, \\mathbf{k}_\\text{B}) \n \\,d\\mathbf{k}_\\text{B}\n\n\n\n\nwhere we generically use the overlined symbol\n\n\\overline{Q}(\\mathbf{k}_\\text{B})\n to denote\nthe contribution of Bloch vector \n\\mathbf{k}_\\text{B}\n\nto quantity \nQ\n. Examples of calculations that require\nBrillouin-zone integrations include\n\n\n\n\n\n\nthe Casimir force per unit imaginary frequency\n\n\\omega=i\\xi\n \non an extended object in\n\nscuff-cas3d\n\n\n\n\n\n\nthe Casimir-Polder potential per unit imaginary frequency\n\n\\omega=i\\xi\n \nexperienced by a polarizable particle near an extended surface\nin \n\nscuff-caspol\n\n\n\n\n\n\nthe local density of states at a given angular frequency\n\n\\omega\n\nat user-specified evaluation points in \n\nscuff-ldos\n.\n\n\n\n\n\n\nIn general, Brillouin-zone integrations are evaluated\nby numerical cubature---that is, as weighted sums of\nintegrand samples:\n\n Q(\\omega) \\approx \\sum w_n \\overline Q(\\omega, \\mathbf{k}_n)\n\nwhere \n\\{w_n, \\mathbf{k}_n\\}\n are the weights and points in\na cubature rule for the Brillouin zone of your reciprocal\nlattice, and where each integrand sample\n\n\\overline Q(\\omega, \\bf k_n)\n is computed by performing a\nsingle \nscuff-em\n calculation at a fixed Bloch\nwavevector. The \nscuff-em\n workflow offers two \noptions for evaluating such cubatures:   \n\n\n\n\nYou can design and implement your own cubature scheme\ninvolving your own custom-chosen weights and points\n\n\\{w_n, \\bf k_n\\}\n. In this case, you will use \nthe \n--byOmegakBloch\n command-line option to instruct\na \nscuff-em\n application code to report values of the\nquantity \n\\overline Q(\\omega, \\bf k_n)\n at each of your points\n(this output will typically be written to file with\nextension \n.byOmegakBloch\n or \n.byXikBloch\n),\nthen compute the weighted sums yourself in e.g.\n\njulia\n.    \n\n\n\n\n\n\n\n\nAlternatively, you can ask \nscuff-em\n to perform the\nBZ integration internally, using one of several\nbuilt-in cubature schemes. In this case the BZ-integrated\nquantities \nQ(\\omega)\n will typically be written to \nan output file with extension \n.byOmega\n or \n.byXi\n.\nYou will \nalso\n get an output file named \n.byOmegakBloch\n\nor \n.byXikBloch\n that reports the Bloch-vector-resolved\nintegrand samples \n\\overline Q(\\omega, \\bf k_n)\n\nchosen internally by the \nscuff-em\n BZ integrator.\n\n\n\n\nCommand-line options for customizing internal BZ integration\n\n\nIf you choose the second option above, you may specify\nvarious command-line options to customize the algorithm\nused by \nscuff-em\n to select the cubature points and\nweights \n\\{w_n, \\mathbf{k}_n\\}\n. The options are \nlisted here and discussed in more detail below.\n\n\n--BZIMethod [CC | TC | Polar | Polar2]\n\n\n\n\nSelects the integration algorithm (see below for details).\n\n\n--BZIOrder NN\n\n\n\n\nSets the order (accuracy parameter) of the integration\nalgorithm to \nNN\n. The allowed values of \nNN\n here depend\non the integration algorithm you chose (see below).\n\n\n--BZIRelTol xx\n--BZIAbsTol xx\n--BZIMaxEvals NN\n\n\n\n\nFor adaptive integration algorithms in which the \norder is determined internally (see below), these \noptions allow you to specify relative and absolute\nerror tolerances and an upper limit on the number of \nintegrand samples that will be used.\n\n\n--BZSymmetryFactor [2|4|8]\n\n\n\n\nThis option lets you tell \nscuff-em\n that your\nintegrand function \n\\overline Q(\\mathbf k_\\text{B})\n\nis invariant under 2, 4, or 8-fold rotational \nsymmetry transformations applied to \n\\mathbf k_\\text{B}\n. \nSee below for more details on what this means.\n\n\nUnderstanding the internal BZ integration algorithms\n\n\nTo help you understand how to configure the various\ncommand-line options above, this section\ndescribes the various integration algorithms available\nand how they are affected by the command-line parameters.\n\n\nIntegration methods for 1D Brillouin zones\n\n\nFor one-dimensional Brillouin zones, there is only one\nBZ integration method available---namely,\n\nClenshaw-Curtis quadrature\n\n(\n--BZIMethod CC\n, the default)\nwith the number of integrand samples either fixed\nor chosen adaptively until user-specified error tolerances\nare achieved.\n\n\nMore specifically, you may say either\n\n\n\n\n--BZIOrder [11 | 13 | 15 | ... | 97 | 99]\n\n\n\n\nor \n\n\n\n\n--BZIOrder 0\n\n\n\n\nThe former option selects fixed-order CC cubature\nwith 11, 13, ... 99 sample points. (This number must \nbe an odd integer between 11 and 99 inclusive.)\n\n\nThe latter option selects adaptive\nCC cubature\nusing \nthis algorithm\n.\nIn this case the number of sample points will be chosen\nautomatically subject to the values you select for the\n\n--BZIRelTol\n, \n--BZIAbsTol\n, and \n--BZIMaxEvals\n\ncommand-line options.\n\n\nSymmetry factors for 1D Brillouin zones\n\n\nFor 1D Brillouin zones, the only allowed \nvalue of the \n--BZSymmetryFactor\n option is \n2\n,\nindicating that your integrand is symmetric under\nsign flip of the Bloch wavevector, i.e.\n\n\\overline Q(k_x) = \\overline Q(-k_x)\n.\nIn this case the BZ integration may be restricted to \nthe range \n0\\le k_x \\le \\frac{\\pi}{L_x}.\n\n\n\n\nIntegration methods for 2D Brillouin zones\n\n\nThe following integration methods are implemented for \n2D Brillouin zones. (See below for pictures of where\nthe various methods place their sample points.)\n\n\n\n\n\n\nClenshaw-Curtis cubature\n (\n--BZIMethod CC\n)\n\n\nNested 2D fixed-order or adaptive Clenshaw-Curtis cubature.\n\n\nFor fixed-order nested CC cubature with \nNN\n sample points\nper dimension, say \n--BZIOrder NN\n. Here \nNN\n must be \nan odd integer between 11 and 99 inclusive.\n\n\nFor adaptive 2D CC cubature (subject to your specified values\nof \n--BZIRelTol\n, \n--BZIAbsTol\n, and \n--BZIMaxEvals\n)\nsay \n--BZIOrder 0.\n    \n\n\n\n\n\n\n\n\n\n\n\n\nTriangle cubature\n (\n--BZIMethod TC\n)\n\n\nThis algorithm divides the Brillouin zone into 8\ntriangles and applies a fixed-order triangle cubature scheme\nto each triangle, omitting repetition of triangles\nthat are symmetry-equivalent given the value you specified\nfor \n--BZSymmetryFactor\n (see pictures below).\n\n\nFor this algorithm, the allowed values of\n\n--BZIOrder\n are 1, 2, 4, 5, 7, 9, 13, 14, 16, 20, or 25.\n\n\n\n\n\n\n\n\n\n\n\n\nPolar cubature\n (\n--BZIMethod Polar\n)\n\n\nThis algorithm uses a polar decomposition\n\n(k_x,k_y) \\to (k_\\rho, k_\\theta)\n to\nevaluate the BZ integral as two nested 1D integrals,\none over \nk_\\rho\n and the second over \nk_\\theta\n.\n(The \nk_\\rho\n integral is evaluated via\n Clenshaw-Curtis quadrature, and the \nk_\\theta\n \n quadrature is evaluated using rectangular-rule quadrature,\n not necessarily of the same order).\n\n\nThis algorithm is useful for integrands that are strongly \npeaked near the origin of the Brillouin zone and highly\nattenuated near the boundaries, so that most of the integral\ncomes from the region near the origin.\n\n\nFor this algorithm, the number of integration points\nused for the \nk_\\rho\n and \nk_\\theta\n integrals (call these\nnumbers \nN_\\rho\n and \nN_\\theta\n) are encoded \ninto the value passed to \n--BZIOrder\n\nin the form \n100\\times N_\\rho + N_\\theta,\n\nwhere \nN_\\rho\n and \nN_\\theta\n are each odd integers \nbetween 11 and 99 inclusive.\n\n\nThus, for example, \n--BZIOrder 3321\n specifies that the\n\nk_\\rho\n integral is to be evaluated via 33-point CC\ncubature, while the \nk_\\theta\n integral is to be evaluated\nvia 21-point rectangular-rule cubature.\n\n\n\n\n\n\n\n\n\n\n\n\n Polar cubature with change of variables\n     \nk_\\rho \\to k_z\n \n (\n--BZIMethod Polar2\n)\n\n\nThis is the same as \n--BZIMethod Polar\n, but with\ntwo modifications: \n(a)\n The \nk_\\rho\n integral \nis split into two separate integrals covering the\nranges \nk_\\rho < k_0\n and \nk_\\rho >k_0\n \n(where \nk_0\\equiv \\frac{\\omega}{c}\n is the vacuum photon\nwavenumber at the frequency in question).\n\n(b)\n In each of the two \nk_\\rho\n integrals we\nmake the change of variables\n\n k_\\rho \\to k_z\\equiv \\sqrt{|k_0^2 - k_\\rho^2|}.\n\n\n\n\nThese modifications are useful\nfor cases in which the free-space wavevector \nk_0\n\nfalls within the Brillouin zone. In these cases,\nthe convergence of the \nk_\\rho\n integral is\ndegraded by the phenomena known as \"Wood anomalies\"\nin optics or \"van Hove singularities\" in solid-state\nphysics, and changing variables to \nk_z\n introduces\na Jacobian factor that neutralizes these singularities\nto yield a better-behaved integrand.    \n\n\n\n\n\n\n Special \nN_\\theta\n values for rotationally-invariant integrands \n\n\nAs discussed above, for the \nPolar\n and \nPolar2\n integration methods\nthe value of the \n--BZIOrder\n option is interpreted as the composite \nquantity \n100\\times N_\\rho + N_\\theta\n,\nwhere \nN_\\rho\n and \nN_\\theta\n are odd integers in the range \n[11,99]\n\nspecifying the number of cubature points used for the \nk_\\rho\n and \n\nk_\\theta\n integrals (or set to 0 to request adaptive quadrature).\n\n\nFor \nfully\n rotationally-symmetric geometries in which the BZ integrand\n\n\\overline{Q}\n is independent of \nk_\\theta\n, you can specify\n\nN_\\theta=\\{2,4,6\\}\n to indicate that the \nk_\\theta\n integral\nis to be evaluated by a 1-point cubature with the single \nk_\\theta\n\nsample taken at \nk_\\theta=\\{0,\\frac{\\pi}{2},\\frac{\\pi}{4}\\}\n.\n\n\n(Of course, no geometry discretized into triangles can actually\nbe fully rotationally invariant, but pretending so may be a\nreasonable approximation in some cases, such as \nthis one\n.)\n\n\nSymmetry factors for 2D Brillouin zones\n\n\nFor 2D geometries, the option \n--BZSymmetryFactor\n may\ntake the value 2, 4, or 8, specifying that the Brillouin-zone\nintegrand \n\\overline{Q}(k_x, k_y)\n obeys symmetries as follows:\n\n\n\n\n\n\n--BZSymmetryFactor 2\n: \n\n\nWe have\n\n\\overline{Q}(k_x,k_y) = \\overline{Q}(k_x,-k_y),\n so the BZ integration\nmay be restricted to just the right half of the BZ.\n\n\n\n\n\n\n\n\n\n\n\n\n--BZSymmetryFactor 4\n:\n\n\nWe have\n\n\\overline{Q}(k_x,k_y) = \\overline{Q}(\\pm k_x, \\pm k_y),\n \nso the BZ integration\nmay be restricted to just the upper-right quadrant of the BZ.\n\n\n\n\n\n\n\n\n\n\n--BZSymmetryFactor 8\n: \n    In addition to symmetry under sign changes, the integrand\n    is symmetric under \nk_x\\leftrightarrow k_y\n,\n    so the BZ integration\n    may be restricted to the triangular region\n    \n0\\le k_y \\le k_x \\le \\frac{\\pi}{L_x}.\n\n    (This is only possible for square lattices.)\n\n\n\n\nLocations of quadrature points for 2D Brillouin zones\n\n\nHere are some diagrams indicating the Bloch wavevectors\nthat will be sampled by the internal algorithms for Brillouin-zone\nintegration with various values of the command-line parameters:\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 2\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 4\n\n\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 8\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 2\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 4\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 8\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 2\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 4\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 8\n\n\n\n\n\n\n\n\nNote:\n The next four diagrams are for a frequency of\n\n\\frac{\\omega}{c}\\approx 0.32\\cdot \\frac{2\\pi}{L}\n. The accumulation\nof points near \n|\\mathbf{k}_\\text{B}|=\\frac{\\omega}{c}\n\nis noticeable for the \nPolar2\n integration strategy.\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 1\n\n\n\n\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 2\n\n\n\n\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 4\n\n\n\n\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 8\n\n\n\n\n\n\nLocations of quadrature points for 1D Brillouin zones\n\n\n--BZIMethod CC    --BZIOrder  31    --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  31    --BZSymmetryFactor 2", 
            "title": "Brillouin zone integration"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#command-line-options-for-customizing-internal-bz-integration", 
            "text": "If you choose the second option above, you may specify\nvarious command-line options to customize the algorithm\nused by  scuff-em  to select the cubature points and\nweights  \\{w_n, \\mathbf{k}_n\\} . The options are \nlisted here and discussed in more detail below.  --BZIMethod [CC | TC | Polar | Polar2]  Selects the integration algorithm (see below for details).  --BZIOrder NN  Sets the order (accuracy parameter) of the integration\nalgorithm to  NN . The allowed values of  NN  here depend\non the integration algorithm you chose (see below).  --BZIRelTol xx\n--BZIAbsTol xx\n--BZIMaxEvals NN  For adaptive integration algorithms in which the \norder is determined internally (see below), these \noptions allow you to specify relative and absolute\nerror tolerances and an upper limit on the number of \nintegrand samples that will be used.  --BZSymmetryFactor [2|4|8]  This option lets you tell  scuff-em  that your\nintegrand function  \\overline Q(\\mathbf k_\\text{B}) \nis invariant under 2, 4, or 8-fold rotational \nsymmetry transformations applied to  \\mathbf k_\\text{B} . \nSee below for more details on what this means.", 
            "title": "Command-line options for customizing internal BZ integration"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#understanding-the-internal-bz-integration-algorithms", 
            "text": "To help you understand how to configure the various\ncommand-line options above, this section\ndescribes the various integration algorithms available\nand how they are affected by the command-line parameters.", 
            "title": "Understanding the internal BZ integration algorithms"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#integration-methods-for-1d-brillouin-zones", 
            "text": "For one-dimensional Brillouin zones, there is only one\nBZ integration method available---namely, Clenshaw-Curtis quadrature \n( --BZIMethod CC , the default)\nwith the number of integrand samples either fixed\nor chosen adaptively until user-specified error tolerances\nare achieved.  More specifically, you may say either   --BZIOrder [11 | 13 | 15 | ... | 97 | 99]   or    --BZIOrder 0   The former option selects fixed-order CC cubature\nwith 11, 13, ... 99 sample points. (This number must \nbe an odd integer between 11 and 99 inclusive.)  The latter option selects adaptive\nCC cubature\nusing  this algorithm .\nIn this case the number of sample points will be chosen\nautomatically subject to the values you select for the --BZIRelTol ,  --BZIAbsTol , and  --BZIMaxEvals \ncommand-line options.", 
            "title": "Integration methods for 1D Brillouin zones"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#symmetry-factors-for-1d-brillouin-zones", 
            "text": "For 1D Brillouin zones, the only allowed \nvalue of the  --BZSymmetryFactor  option is  2 ,\nindicating that your integrand is symmetric under\nsign flip of the Bloch wavevector, i.e. \\overline Q(k_x) = \\overline Q(-k_x) .\nIn this case the BZ integration may be restricted to \nthe range  0\\le k_x \\le \\frac{\\pi}{L_x}.", 
            "title": "Symmetry factors for 1D Brillouin zones"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#integration-methods-for-2d-brillouin-zones", 
            "text": "The following integration methods are implemented for \n2D Brillouin zones. (See below for pictures of where\nthe various methods place their sample points.)    Clenshaw-Curtis cubature  ( --BZIMethod CC )  Nested 2D fixed-order or adaptive Clenshaw-Curtis cubature.  For fixed-order nested CC cubature with  NN  sample points\nper dimension, say  --BZIOrder NN . Here  NN  must be \nan odd integer between 11 and 99 inclusive.  For adaptive 2D CC cubature (subject to your specified values\nof  --BZIRelTol ,  --BZIAbsTol , and  --BZIMaxEvals )\nsay  --BZIOrder 0.            Triangle cubature  ( --BZIMethod TC )  This algorithm divides the Brillouin zone into 8\ntriangles and applies a fixed-order triangle cubature scheme\nto each triangle, omitting repetition of triangles\nthat are symmetry-equivalent given the value you specified\nfor  --BZSymmetryFactor  (see pictures below).  For this algorithm, the allowed values of --BZIOrder  are 1, 2, 4, 5, 7, 9, 13, 14, 16, 20, or 25.       Polar cubature  ( --BZIMethod Polar )  This algorithm uses a polar decomposition (k_x,k_y) \\to (k_\\rho, k_\\theta)  to\nevaluate the BZ integral as two nested 1D integrals,\none over  k_\\rho  and the second over  k_\\theta .\n(The  k_\\rho  integral is evaluated via\n Clenshaw-Curtis quadrature, and the  k_\\theta  \n quadrature is evaluated using rectangular-rule quadrature,\n not necessarily of the same order).  This algorithm is useful for integrands that are strongly \npeaked near the origin of the Brillouin zone and highly\nattenuated near the boundaries, so that most of the integral\ncomes from the region near the origin.  For this algorithm, the number of integration points\nused for the  k_\\rho  and  k_\\theta  integrals (call these\nnumbers  N_\\rho  and  N_\\theta ) are encoded \ninto the value passed to  --BZIOrder \nin the form  100\\times N_\\rho + N_\\theta, \nwhere  N_\\rho  and  N_\\theta  are each odd integers \nbetween 11 and 99 inclusive.  Thus, for example,  --BZIOrder 3321  specifies that the k_\\rho  integral is to be evaluated via 33-point CC\ncubature, while the  k_\\theta  integral is to be evaluated\nvia 21-point rectangular-rule cubature.        Polar cubature with change of variables\n      k_\\rho \\to k_z    ( --BZIMethod Polar2 )  This is the same as  --BZIMethod Polar , but with\ntwo modifications:  (a)  The  k_\\rho  integral \nis split into two separate integrals covering the\nranges  k_\\rho < k_0  and  k_\\rho >k_0  \n(where  k_0\\equiv \\frac{\\omega}{c}  is the vacuum photon\nwavenumber at the frequency in question). (b)  In each of the two  k_\\rho  integrals we\nmake the change of variables  k_\\rho \\to k_z\\equiv \\sqrt{|k_0^2 - k_\\rho^2|}.   These modifications are useful\nfor cases in which the free-space wavevector  k_0 \nfalls within the Brillouin zone. In these cases,\nthe convergence of the  k_\\rho  integral is\ndegraded by the phenomena known as \"Wood anomalies\"\nin optics or \"van Hove singularities\" in solid-state\nphysics, and changing variables to  k_z  introduces\na Jacobian factor that neutralizes these singularities\nto yield a better-behaved integrand.         Special  N_\\theta  values for rotationally-invariant integrands   As discussed above, for the  Polar  and  Polar2  integration methods\nthe value of the  --BZIOrder  option is interpreted as the composite \nquantity  100\\times N_\\rho + N_\\theta ,\nwhere  N_\\rho  and  N_\\theta  are odd integers in the range  [11,99] \nspecifying the number of cubature points used for the  k_\\rho  and  k_\\theta  integrals (or set to 0 to request adaptive quadrature).  For  fully  rotationally-symmetric geometries in which the BZ integrand \\overline{Q}  is independent of  k_\\theta , you can specify N_\\theta=\\{2,4,6\\}  to indicate that the  k_\\theta  integral\nis to be evaluated by a 1-point cubature with the single  k_\\theta \nsample taken at  k_\\theta=\\{0,\\frac{\\pi}{2},\\frac{\\pi}{4}\\} .  (Of course, no geometry discretized into triangles can actually\nbe fully rotationally invariant, but pretending so may be a\nreasonable approximation in some cases, such as  this one .)", 
            "title": "Integration methods for 2D Brillouin zones"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#symmetry-factors-for-2d-brillouin-zones", 
            "text": "For 2D geometries, the option  --BZSymmetryFactor  may\ntake the value 2, 4, or 8, specifying that the Brillouin-zone\nintegrand  \\overline{Q}(k_x, k_y)  obeys symmetries as follows:    --BZSymmetryFactor 2 :   We have \\overline{Q}(k_x,k_y) = \\overline{Q}(k_x,-k_y),  so the BZ integration\nmay be restricted to just the right half of the BZ.       --BZSymmetryFactor 4 :  We have \\overline{Q}(k_x,k_y) = \\overline{Q}(\\pm k_x, \\pm k_y),  \nso the BZ integration\nmay be restricted to just the upper-right quadrant of the BZ.      --BZSymmetryFactor 8 : \n    In addition to symmetry under sign changes, the integrand\n    is symmetric under  k_x\\leftrightarrow k_y ,\n    so the BZ integration\n    may be restricted to the triangular region\n     0\\le k_y \\le k_x \\le \\frac{\\pi}{L_x}. \n    (This is only possible for square lattices.)", 
            "title": "Symmetry factors for 2D Brillouin zones"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#locations-of-quadrature-points-for-2d-brillouin-zones", 
            "text": "Here are some diagrams indicating the Bloch wavevectors\nthat will be sampled by the internal algorithms for Brillouin-zone\nintegration with various values of the command-line parameters:  --BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 1    --BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 2    --BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 4     --BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 8    --BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 1    --BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 2    --BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 4    --BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 8    --BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 1    --BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 2    --BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 4    --BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 8    Note:  The next four diagrams are for a frequency of \\frac{\\omega}{c}\\approx 0.32\\cdot \\frac{2\\pi}{L} . The accumulation\nof points near  |\\mathbf{k}_\\text{B}|=\\frac{\\omega}{c} \nis noticeable for the  Polar2  integration strategy.  --BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 1   --BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 2   --BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 4   --BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 8", 
            "title": "Locations of quadrature points for 2D Brillouin zones"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/#locations-of-quadrature-points-for-1d-brillouin-zones", 
            "text": "--BZIMethod CC    --BZIOrder  31    --BZSymmetryFactor 1    --BZIMethod CC    --BZIOrder  31    --BZSymmetryFactor 2", 
            "title": "Locations of quadrature points for 1D Brillouin zones"
        }, 
        {
            "location": "/reference/FAQ/", 
            "text": "Frequently asked questions about \nscuff-em\n\n\n\n\nWhat units does \nscuff-em\n use for physical quantities like length, frequency, field strengths, power, force, torque, etc?\n\n\nLength and frequency\n\n\nShort answer: The default units are \nL_0=1\\, \\mu\\text{m}\n for length\nand \n\\omega_0=3\\cdot 10^{14}\n rad/sec (=\nc/L_0)\n for angular frequency.\n\n\nThus, if you write a \n\ngmsh\n\ngeometry (\n.geo\n) file describing a sphere\nof radius \n1.3\n and use the resulting surface mesh in a\n\nscuff-scatter\n calculation\nwith an angular-frequency specification of \n--omega 2.0\n,\nthen you will be studying a sphere of radius 1.3 microns\nat an angular frequency of \n6\\cdot 10^{14}\n rad/sec \n(corresponding to a free-space wavelength of \n\n\\lambda=\\frac{2\\pi c}{\\omega} = 3.1415\\,\\mu\nm,\nwhich could alternatively be specified by saying\n\n--lambda 3.1415\n instead of \n--omega 2.0\n).\n[The dimensionless quantity \na=\\frac{\\omega R}{c}\n\n (the \"size parameter\" in Mie theory) \n  is just the product of the numerical values specified\n  for the radius and \n--omega\n, i.e. \na=1.3 \\cdot 2.0=2.6\n\n  in this case.]\n\n\nLonger answer: \nFor a problem involving only bodies with\n\nfrequency-independent material properties\n\n(permeability \n\\epsilon\n and permittivity \n\\mu\n),\nincluding perfectly-conducting (\nPEC\n) bodies and\nfrequency-independent dielectrics\n(such as \nCONST_EPS_10+1i\n), the scale invariance\nof Maxwell's equations means that the same\ncomputational results can be interpreted on different\nlength scales. For example, if your mesh file\ndescribes a sphere of radius \n0.9' and you run\na [[scuff-em]] calculation at angular frequency\n1.2`, \nthen the results can be equally well interpreted as describing\n\n\n\n\n\n\na sphere of radius 0.9 \n\\mu\nm at an angular frequency of\n\n1.2 \\cdot 3\\cdot 10^{14}\n rad/sec, or\n\n\n\n\n\n\na sphere of radius 0.9 mm at an angular frequency of\n\n1.2 \\cdot 3\\cdot 10^{11}\n rad/sec, or\n\n\n\n\n\n\na sphere of radius 0.9 nm at an angular frequency of\n\n1.2 \\cdot 3\\cdot 10^{17}\n rad/sec, etc. (Of course,\nthe continuum\n\n\n\n\n\n\nHowever, this scale invariance is broken by\nfrequency-dependent dielectric functions \n(or frequency-dependent permeabilities) such\nas the \nSILICON\n material definition in\n\nthis example\n. The convention\nadopted by \nscuff-em\n is that\n\n\\omega\n values in frequency-dependent material\ndefinitions are always interpreted in units of radians/second\n,\n\nnot\n specialized units like \n3 \\cdot 10^{14} rad/sec\n.\nThus, if your calculation involves a frequency-dependent \nmaterial function (either a [user-defined function][UserDefined] or\na [datafile][Tabulated]),\nthen \nscuff-em\n will eventually need to convert the numerical\nvalues you specify for \n--Omega\n inputs into absolute\nangular frequencies. For this purpose, \nscuff-em\n generally\nmakes the scale-breaking assumption that numerical \n--Omega\n values\nare given in units of \n\\omega_0=3\\cdot 10^{14}\n rad/sec,\ncorresponding to the default length scale of \nL_0=1\\,\\mu\nm.\n(The one exception to this rule is\n[\nscuff-rf\n][scuff-rf], which uses\nlength and frequency units more appropriate for RF modeling;\nthis is discussed in the \n[\nscuff-rf\n documentation][scuff-rf].)\n\n\nElectric and magnetic field strengths\n\n\nThe only code in the \nscuff-em\n suite that directly outputs\nnumerical values of electric and magnetic field components is\n\nscuff-scatter\n. For this\ncode, there is always a user-specified incident field with\na user-specified numerical field-strength parameter, and the\nunits of electric-field components reported by \nscuff-scatter\n\nare understood simply to be the same as the units of the incident-field\nspecifications.\nThe units of magnetic-field components are the units of electric-field\ncomponents divided by ohms (volts/amperes); thus, if \nE\n-field \ncomponents have units of volts/micron then \nH\n-field components\nhave units of amps/micron.\n\n\nThus, to run a \nscuff-scatter\n calculation to model the\nscattering of an incident plane wave of amplitude 1 volt/micron,\nuse the command-line option \n--pwPolarization 0 0 1\n\nand interpret the numbers reported for \nE\n-field (\nH\n-field)\ncomponents in units of volts/micron (amps/micron).\nAlternatively, to describe the scattering of a plane wave of \namplitude 1 volt/meter, use the same command-line options,\nbut now interprety the output numbers in units of \nvolts/meter (amps/meter).\n\n\nPower, force, torque\n\n\nThe units in which numerical values of power, force, and torque are\nreported differ slightly for different codes in the \nscuff-em\n suite:\n\n\n\n\n\n\nFor \nscuff-scatter\n,\nand torque in\n\n\n\n\n\n\nFor \nscuff-cas3D\n,\n\n\n\n\n\n\nequilibrium Casimir energies are reported in units of \n  \n\\hbar c/1\\,\\mu\\text{m}\n=0.1973 eV = 3.16\\cdot 10^{-20}$ joules,\n\n\n\n\n\n\nequilibrium Casimir forces are reported in units of \n  \n\\hbar c/(1\\,\\mu\\text{m})^2\n=31.6 femtoNewtons\n\n\n\n\n\n\nequilibrium Casimir torques are reported in units of\n  \n\\hbar c/(1\\,\\mu\\text{m})\n=31.6 femtoNewtons\n microns.\n\n\n\n\n\n\n\n\n\n\nscuff-neq\n reports power in watts,\nforce in nanoNewtons, torque in nanoNewtons\nmicrons.\n(More specifically, what \nscuff-neq\n actually reports are\n\nfluxes\n of energy and momentum; these are quantities\nthat need to be multiplied by energy prefactors and integrated\nover angular frequencies to yield heat-transfer rates, forces, and torques;\nthis is discussed in more detail in the \n\nscuff-neq\n documentation.\n\n\n\n\n\n\nI'm working on a big project involving multiple calculations on a geometry with various different values of geometric parameters, material properties, and meshing fineness. It's getting unwieldy to have all of these \n.geo\n and \n.msh\n and \n.scuffgeo\n files cluttering up my project directory. How would you suggest organizing things?\n\n\nHere is what I typically do:\n\n\n\n\n\n\nWithin your top-level project directory (I'll call it\n      \n~/myProject/\n), create the following subdirectories:\n\n\n\n\n~/myProject/geoFiles\n (for \ngmsh\n geometry files)\n\n\n~/myProject/mshFiles\n (for surface mesh files)\n\n\n~/myProject/scuffgeoFiles\n (for \nscuff-em\n geometry files\n).\n\n\n\n\n\n\n\n\nBefore running any \nscuff-em\n calculations, set the\n    environment variable \nSCUFF_MESH_PATH\n to the directory\n    you created for mesh files:\n\n\n\n\n\n\n% export SCUFF_MESH_PATH=~/myProject/mshFiles\n\n\n\n\n(Or just include this line in any scripts you write to launch jobs; see below).\n\n\n\n\n\n\nFrom the top-level project directory, create subdirectories for\n    each separate run you plan to do. For example, to do separate\n    runs for PEC and real gold, with coarse and fine resolutions \n    in both cases, I might create four directories called \n    \nPEC_Coarse\n, \nPEC_Fine\n, \nGold_Coarse\n, and \nGold_Fine.\n\n\n\n\n\n\nAssuming you want to look at the same frequencies, evaluation points,\n    incident fields, geometrical transformations, etc. in each case, \n    put files like \nOmegaFile\n, \nEPFile\n, \nIFFile\n, and \nTransFile\n \n    in the top-level directory (\n~/myProject/\n).\n\n\n\n\n\n\nWithin e.g. the \nPEC_Fine\n subdirectory, create a run script\n    that explicitly specifies the locations in which it expects\n    to find files, something like this:\n\n\n\n\n\n\n#!/bin/bash\n\nexport FILEBASE=${HOME}/myProject\nexport SCUFF_MESH_PATH=${FILEBASE}/mshFiles\nexport SCUFF_GEO_PATH=${FILEBASE}/scuffgeoFiles\n\nARGS=\n\nARGS=\n${ARGS} --geometry  ${SCUFF_GEO_PATH}/PEC_Fine.scuffgeo\n\nARGS=\n${ARGS} --OmegaFile ${FILEBASE}/OmegaFile\n\nARGS=\n${ARGS} --EPFile    ${FILEBASE}/EPFile\n\nARGS=\n${ARGS} --IFFile    ${FILEBASE}/IFFile\n  \n\nscuff-scatter ${ARGS}\n\n\n\n\n\n\n\n\n\nNow you can copy this run script to each new run directory \n    and make only minor changes (i.e. specify different \n.scuffgeo\n)\n    files to launch the new job.\n\n\n\n\n\n\nWhen running multiple jobs simultaneously on a single\n    multi-core workstation, I usually use the environment variables\n    \nOMP_NUM_THREADS\n and \nGOMP_CPU_AFFINITY\n to specify an \n    explicit divvying up of the available CPU cores so that \n    the various jobs don't step on each others' toes. (The\n    OS scheduler should be able to do this automatically, but \n    I haven't had good luck with that.)\n\n\nFor example, suppose I'm on a workstation that has 24 CPU cores,\nand I want to run 3 simultaneous \nscuff-em\n jobs.\nThen in the run scripts for the three jobs I will include\nthe following lines:\n\n\n\n\n\n\n...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY=\n0-7\n\n...\n\n\n\n\nfor the first run script,\n\n\n...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY=\n8-15\n\n...\n\n\n\n\nfor the second run script, and \n\n\n...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY=\n16-23\n\n...\n\n\n\n\nfor the third run script. Once all three jobs\nare running, you can use \n\nhtop\n\nor similar utilities to double check that each \njob is running on its own set of 8 cores and \nnot interfering with the other jobs.", 
            "title": "FAQ"
        }, 
        {
            "location": "/reference/FAQ/#what-units-does-scuff-em-use-for-physical-quantities-like-length-frequency-field-strengths-power-force-torque-etc", 
            "text": "", 
            "title": "What units does scuff-em use for physical quantities like length, frequency, field strengths, power, force, torque, etc?"
        }, 
        {
            "location": "/reference/FAQ/#length-and-frequency", 
            "text": "Short answer: The default units are  L_0=1\\, \\mu\\text{m}  for length\nand  \\omega_0=3\\cdot 10^{14}  rad/sec (= c/L_0)  for angular frequency.  Thus, if you write a  gmsh \ngeometry ( .geo ) file describing a sphere\nof radius  1.3  and use the resulting surface mesh in a scuff-scatter  calculation\nwith an angular-frequency specification of  --omega 2.0 ,\nthen you will be studying a sphere of radius 1.3 microns\nat an angular frequency of  6\\cdot 10^{14}  rad/sec \n(corresponding to a free-space wavelength of  \\lambda=\\frac{2\\pi c}{\\omega} = 3.1415\\,\\mu m,\nwhich could alternatively be specified by saying --lambda 3.1415  instead of  --omega 2.0 ).\n[The dimensionless quantity  a=\\frac{\\omega R}{c} \n (the \"size parameter\" in Mie theory) \n  is just the product of the numerical values specified\n  for the radius and  --omega , i.e.  a=1.3 \\cdot 2.0=2.6 \n  in this case.]  Longer answer: \nFor a problem involving only bodies with frequency-independent material properties \n(permeability  \\epsilon  and permittivity  \\mu ),\nincluding perfectly-conducting ( PEC ) bodies and\nfrequency-independent dielectrics\n(such as  CONST_EPS_10+1i ), the scale invariance\nof Maxwell's equations means that the same\ncomputational results can be interpreted on different\nlength scales. For example, if your mesh file\ndescribes a sphere of radius  0.9' and you run\na [[scuff-em]] calculation at angular frequency 1.2`, \nthen the results can be equally well interpreted as describing    a sphere of radius 0.9  \\mu m at an angular frequency of 1.2 \\cdot 3\\cdot 10^{14}  rad/sec, or    a sphere of radius 0.9 mm at an angular frequency of 1.2 \\cdot 3\\cdot 10^{11}  rad/sec, or    a sphere of radius 0.9 nm at an angular frequency of 1.2 \\cdot 3\\cdot 10^{17}  rad/sec, etc. (Of course,\nthe continuum    However, this scale invariance is broken by\nfrequency-dependent dielectric functions \n(or frequency-dependent permeabilities) such\nas the  SILICON  material definition in this example . The convention\nadopted by  scuff-em  is that \\omega  values in frequency-dependent material\ndefinitions are always interpreted in units of radians/second , not  specialized units like  3 \\cdot 10^{14} rad/sec .\nThus, if your calculation involves a frequency-dependent \nmaterial function (either a [user-defined function][UserDefined] or\na [datafile][Tabulated]),\nthen  scuff-em  will eventually need to convert the numerical\nvalues you specify for  --Omega  inputs into absolute\nangular frequencies. For this purpose,  scuff-em  generally\nmakes the scale-breaking assumption that numerical  --Omega  values\nare given in units of  \\omega_0=3\\cdot 10^{14}  rad/sec,\ncorresponding to the default length scale of  L_0=1\\,\\mu m.\n(The one exception to this rule is\n[ scuff-rf ][scuff-rf], which uses\nlength and frequency units more appropriate for RF modeling;\nthis is discussed in the \n[ scuff-rf  documentation][scuff-rf].)", 
            "title": "Length and frequency"
        }, 
        {
            "location": "/reference/FAQ/#electric-and-magnetic-field-strengths", 
            "text": "The only code in the  scuff-em  suite that directly outputs\nnumerical values of electric and magnetic field components is scuff-scatter . For this\ncode, there is always a user-specified incident field with\na user-specified numerical field-strength parameter, and the\nunits of electric-field components reported by  scuff-scatter \nare understood simply to be the same as the units of the incident-field\nspecifications.\nThe units of magnetic-field components are the units of electric-field\ncomponents divided by ohms (volts/amperes); thus, if  E -field \ncomponents have units of volts/micron then  H -field components\nhave units of amps/micron.  Thus, to run a  scuff-scatter  calculation to model the\nscattering of an incident plane wave of amplitude 1 volt/micron,\nuse the command-line option  --pwPolarization 0 0 1 \nand interpret the numbers reported for  E -field ( H -field)\ncomponents in units of volts/micron (amps/micron).\nAlternatively, to describe the scattering of a plane wave of \namplitude 1 volt/meter, use the same command-line options,\nbut now interprety the output numbers in units of \nvolts/meter (amps/meter).", 
            "title": "Electric and magnetic field strengths"
        }, 
        {
            "location": "/reference/FAQ/#power-force-torque", 
            "text": "The units in which numerical values of power, force, and torque are\nreported differ slightly for different codes in the  scuff-em  suite:    For  scuff-scatter ,\nand torque in    For  scuff-cas3D ,    equilibrium Casimir energies are reported in units of \n   \\hbar c/1\\,\\mu\\text{m} =0.1973 eV = 3.16\\cdot 10^{-20}$ joules,    equilibrium Casimir forces are reported in units of \n   \\hbar c/(1\\,\\mu\\text{m})^2 =31.6 femtoNewtons    equilibrium Casimir torques are reported in units of\n   \\hbar c/(1\\,\\mu\\text{m}) =31.6 femtoNewtons  microns.      scuff-neq  reports power in watts,\nforce in nanoNewtons, torque in nanoNewtons microns.\n(More specifically, what  scuff-neq  actually reports are fluxes  of energy and momentum; these are quantities\nthat need to be multiplied by energy prefactors and integrated\nover angular frequencies to yield heat-transfer rates, forces, and torques;\nthis is discussed in more detail in the  scuff-neq  documentation.", 
            "title": "Power, force, torque"
        }, 
        {
            "location": "/reference/FAQ/#im-working-on-a-big-project-involving-multiple-calculations-on-a-geometry-with-various-different-values-of-geometric-parameters-material-properties-and-meshing-fineness-its-getting-unwieldy-to-have-all-of-these-geo-and-msh-and-scuffgeo-files-cluttering-up-my-project-directory-how-would-you-suggest-organizing-things", 
            "text": "Here is what I typically do:    Within your top-level project directory (I'll call it\n       ~/myProject/ ), create the following subdirectories:   ~/myProject/geoFiles  (for  gmsh  geometry files)  ~/myProject/mshFiles  (for surface mesh files)  ~/myProject/scuffgeoFiles  (for  scuff-em  geometry files ).     Before running any  scuff-em  calculations, set the\n    environment variable  SCUFF_MESH_PATH  to the directory\n    you created for mesh files:    % export SCUFF_MESH_PATH=~/myProject/mshFiles  (Or just include this line in any scripts you write to launch jobs; see below).    From the top-level project directory, create subdirectories for\n    each separate run you plan to do. For example, to do separate\n    runs for PEC and real gold, with coarse and fine resolutions \n    in both cases, I might create four directories called \n     PEC_Coarse ,  PEC_Fine ,  Gold_Coarse , and  Gold_Fine.    Assuming you want to look at the same frequencies, evaluation points,\n    incident fields, geometrical transformations, etc. in each case, \n    put files like  OmegaFile ,  EPFile ,  IFFile , and  TransFile  \n    in the top-level directory ( ~/myProject/ ).    Within e.g. the  PEC_Fine  subdirectory, create a run script\n    that explicitly specifies the locations in which it expects\n    to find files, something like this:    #!/bin/bash\n\nexport FILEBASE=${HOME}/myProject\nexport SCUFF_MESH_PATH=${FILEBASE}/mshFiles\nexport SCUFF_GEO_PATH=${FILEBASE}/scuffgeoFiles\n\nARGS= \nARGS= ${ARGS} --geometry  ${SCUFF_GEO_PATH}/PEC_Fine.scuffgeo \nARGS= ${ARGS} --OmegaFile ${FILEBASE}/OmegaFile \nARGS= ${ARGS} --EPFile    ${FILEBASE}/EPFile \nARGS= ${ARGS} --IFFile    ${FILEBASE}/IFFile   \n\nscuff-scatter ${ARGS}    Now you can copy this run script to each new run directory \n    and make only minor changes (i.e. specify different  .scuffgeo )\n    files to launch the new job.    When running multiple jobs simultaneously on a single\n    multi-core workstation, I usually use the environment variables\n     OMP_NUM_THREADS  and  GOMP_CPU_AFFINITY  to specify an \n    explicit divvying up of the available CPU cores so that \n    the various jobs don't step on each others' toes. (The\n    OS scheduler should be able to do this automatically, but \n    I haven't had good luck with that.)  For example, suppose I'm on a workstation that has 24 CPU cores,\nand I want to run 3 simultaneous  scuff-em  jobs.\nThen in the run scripts for the three jobs I will include\nthe following lines:    ...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY= 0-7 \n...  for the first run script,  ...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY= 8-15 \n...  for the second run script, and   ...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY= 16-23 \n...  for the third run script. Once all three jobs\nare running, you can use  htop \nor similar utilities to double check that each \njob is running on its own set of 8 cores and \nnot interfering with the other jobs.", 
            "title": "I'm working on a big project involving multiple calculations on a geometry with various different values of geometric parameters, material properties, and meshing fineness. It's getting unwieldy to have all of these .geo and .msh and .scuffgeo files cluttering up my project directory. How would you suggest organizing things?"
        }, 
        {
            "location": "/applications/GeneralReference/", 
            "text": "General reference for \nscuff-em\n command-line applications\n\n\nThis page collects some general information that applies\nto many or all of the standalone command-line applications\nin the \nscuff-em\n suite.\n\n\nTable of Contents\n\n\nGeneral reference for scuff-em command-line applications\n\n\n1. Common command-line arguments\n\n\nOptions specifying geometry inputs\n\n\nOptions specifying individual frequencies and Bloch vectors at which to calculate\n\n\nOptions specifying evaluation points\n\n\nOptions controlling frequency integrations\n\n\nOptions controlling Brillouin-zone integrations\n\n\nMiscellaneous options\n\n\n\n\n\n\n2. Passing command-line options via text file\n\n\n3. Complex numbers\n\n\n4. Log files\n\n\n5. Output Files\n\n\n6. Environment variables\n\n\n\n\n\n\n\n\n1. Common command-line arguments\n\n\nThe various standalone applications in the \nscuff-em\n suite\nshare a number of command-line arguments in common,\nas described below.\nNot all codes accept all arguments (for example, \n\nscuff-transmission\n does not accept \n--TransFile\n), but the \nformat of each arguments is standardized among all codes that \ndo\n \naccept that argument.\n\n\nOptions specifying geometry inputs\n\n\n--geometry MyGeometry.scuffgeo\n\n\n\n\nSpecifies the \n\nscuff-em\n geometry file\n\ndescribing your geometry. This option is always mandatory.\n\n\n\n\n--TransFile MyTransformations.trans\n\n\n\n\nSpecifies an optional file describing one or more\n\ngeometrical transformations\n\nto be applied to your geometry. Omitting the \n--TransFile\n option\n(when running a code that accepts it) is equivalent to specifying\nan empty transformation named \nDEFAULT\n that leaves the geometry\nunchanged from the configuration described by the \n.scuffgeo\n file.\n\n\n\n\nOptions specifying individual frequencies and Bloch vectors at which to calculate\n\n\n--Omega 3.34\n--Omega 4.25+0.9i\n--Lambda 2.3\n--OmegaFile MyOmegaFile\n--LambdaFile MyLambdaFile\n\n\n\n\nSpecifies one or more frequencies at which to perform calculations.\n\n\n--Omega\n specifies the angular frequency in units of \n\n\\omega_0=3\\cdot 10^{14}\n rad/sec. The argument of \n--Omega\n may be a\n\ncomplex number\n.\n\n\nThe alternative option \n--Lambda\n instead specifies the frequency\nin terms of the corresponding free-space wavelength \n\\lambda=c/\\omega\n \n(where \nc\n is the \nvacuum\n speed of light, irrespective of the material\nproperties of your geometry.)\n\n--Lambda\n values are interpreted in units of microns (\n\\mu\nm).\n\n\nThe options \n--OmegaFile\n or \n--LambdaFile\n may be used to specify a \nfile containing one or more \n--Omega\n or \n--Lambda\n values, one \nper line (blank lines and comments are ignored.)\n\n\n\n\n--OmegakBlochFile MyOkBFile\n\n\n\n\nSimilar to \n--OmegaFile\n, but specifies a list of\n(frequency, Bloch vector) points at which to perform calculations.\nThis option only makes sense when used with \n\nextended geometries\n\n\nThe argument specified for \n--OmegakBlochFile\n should\nbe a file containing two numbers on each line (for 1D extended \ngeometries) or three numbers on each line (for 2D extended \ngeometries). (Blank lines and comment lines beginning with \n#\n\nare ignored.) The first number on each line is the \n--Omega\n\nvalue; the next one or two numbers are the components of the \n1D or 2D Bloch wavevector, measured in units of (\n\\mu\nm)\n^{-1}\n.\n\n\n\n\n--Xi 0.39 \n--XiFile MyXiFile\n--XikBlochFile MyXkBFile\n\n\n\n\nSimilar to \n--Omega\n, \n--OmegaFile\n, and \n--OmegakBlochFile,\n \nbut used for codes (\nscuff-cas3d\n and\n\nscuff-caspol\n) that perform calculations\nat pure imaginary frequencies, \n\\omega=i\\xi\n.\nValues specified for \n--Xi\n should be positive real numbers.\n\n\n\n\n\n\nOptions specifying evaluation points\n\n\n--EPFile MyEPFile\n\n\n\n\nFor codes that compute spatially-resolved output quantities,\nthis option specifies a file describing a list of spatial \nevaluation points. (\nWhich\n output quantity depends\non the code you are running; for example,\n\nscuff-scatter\n\nwill report components of the scattered and total fields at the \nevaluation points, while\n\nscuff-neq\n\nwill report values of the thermally-averaged fluxes of\nenergy and momentum at the evaluation points.)\n\n\nThe argument to \n--EPFile\n should be a file containing one or more\nlines, each of which contains three space-separated numbers\n(the Cartesian coordinates of the evaluation point). \nBlank lines and comments (lines beginning with \n#\n) are ignored.\nFor example,\nto ask \nscuff-scatter\n for the scattered field components\nat points on the \nz\n axis, the file might look like this:\n\n\n# evaluation points\n0.0 0.0 -2.0\n0.0 0.0 -1.9\n...\n0.0 0.0  1.9\n0.0 0.0  2.0\n\n\n\n\nOptions controlling frequency integrations\n\n\n--OmegaQuadrature [adaptive | cliff]\n--OmegaMin 0.01\n--XiQuadrature [adaptive | cliff]\n--XiMin 0.01\n--AbsTol\n--RelTol\n\n\n\n\nThese arguments affect the behavior of application codes\nthat compute output quantities by performing numerical\nintegrations over angular frequencies---either real\nangular frequencies \n\\omega\n or imaginary angular\nfrequencies \n\\xi\n. (More specifically, \nscuff-neq\n\nperforms \n\\omega\n integrations, while \nscuff-cas3d\n and\n\nscuff-caspol\n perform \n\\xi\n integrations.)\n\n\n--OmegaQuadrature\n or \n--XiQuadrature\n specify the\nnumerical quadrature algorithm. If these\noptions are left unspecified, an appropriate algorithm \nis chosen automatically.\n\n\n--OmegaMin\n or \n--XiMin\n specify the minimum angular\nfrequency at which numerical \nscuff-em\n calculations \nare performed. For cases in which the lower limit of the \n\n\\omega\n or \n\\xi\n integration is 0, the integrand is \nassumed to be constant between 0 and the value specified here.\nThese options are interpreted in the usual \nscuff-em\n\nfrequency units of \n3\\times 10^{14}\n rad/sec, so typical\nvalues will be something like \n0.001.\n\n\n--AbsTol\n and \n--RelTol\n may be used to specify\nabsolute and relative error tolerances for adaptive\nquadrature algorithms. If an adaptive cubature method\nseems be spending too much time attempting to achieve\nhigh accuracy in a frequency quadrature, try increasing\n\n--RelTol\n to something like \n0.1\n or even \n0.5.\n\n\n\n\nOptions controlling Brillouin-zone integrations\n\n\n--BZQuadrature [adaptive | cliff]\n--BZSymmetry [adaptive | cliff]\n--MaxBZSamples 1000;\n\n\n\n\nThese arguments affect the behavior of application codes\nthat compute output quantities for periodic geometries\nby performing numerical integrations over the Brillouin\nzone. Such codes include \nscuff-ldos\n, \nscuff-neq\n,\n\nscuff-cas3d\n, and \nscuff-caspol\n.\n\n\n--BZSymmetry\n may be used for 2D periodic geometries to\ndeclare that the Brillouin-zone integrand \nf(k_x, k_y)\n\nis symmetric under the interchange \nk_x \\leftrightarrow k_y\n.\n\n\n--MaxBZSamples 1000\n may be used to restrict adaptive\nintegration algorithms to a maximum of 1,000 evaluations\nof the Brillouin-zone integrand.\n\n\n\n\nMiscellaneous options\n\n\n--FileBase MyFileBase\n\n\n\n\nSpecifies the base file name for output files (so that, for example,\nthe frequency-resolved output file written by \nscuff-cas3d\n\nwill be \nMyFileBase.byXi\n, while the frequency-integrated \noutput file will be \nMyFileBase.out\n). If this option is not \nspecified, the file base is taken to be the base filename of the \n\n.scuffgeo\n file.\n\n\n\n\n2. Passing command-line options via text file\n\n\nAll of the standalone applications in the \nscuff-em\n suite allow \ntheir command-line options to be passed via a text file fed into \nstandard input.\n\n\nEach line of this text file should consist of a single \ncommand-line option (minus the -- at the beginning) followed by any \narguments the option might take.\n\n\nFor example, running \nscuff-scatter\n with the command-line options\n\n\n% scuff-scatter --geometry Spheres.scuffgeo --omega 1.0 --pwPolarization 1 0 0 --pwDirection 0 0 1 --EPFile MyEPFile \n\n\n\n\nis equivalent to running\n\n\n% scuff-scatter \n MyOptionsFile\n\n\n\n\nwhere the file \nMyOptionsFile\n looks like this:\n\n\n# options for scuff-scatter \ngeometry Spheres.scuffgeo\nomega 1.0\n\npwPolarization 1 0 0 \npwDirection 0 0 1\n\nEPFile MyEPFile\n\n\n\n\nNote that blank lines and comments (lines starting with #) are ignored.\n\n\nYou may also combine the two methods of specifying options by passing \nsome options via text file and others on the command line. If there are \nany conflicts, the values specified on the command line take precedence. \nFor instance, to re-run the example above at a new frequency with \neverything else unchanged, you could say\n\n\n % scuff-scatter --Omega 2.0 \n MyOptionsFile\n\n\n\n\n\n\n3. Complex numbers\n\n\nMany of the standalone programs in the \nscuff-em\n suite have \noptions for which you may specify complex numbers. (An example \nis the --omega option accepted by \nscuff-scatter\n and other \ncodes, for which you may specify complex or even pure imaginary \nnumbers to do calculations at complex frequencies.)\n\n\nTo specify a complex number as a parameter value, write both the \nreal and imaginary parts together as a single string (no spaces), \nseparated by \n+\n or \n-\n, with the imaginary part terminated by \n\ni\n or \nI\n (you may also use \nj\n or \nJ\n). For example, all \nof the following are valid frequency specifications:\n\n\n --omega 2.3+4.5i\n --omega 2.3\n --omega 4.5j\n --omega 12.3e2+45.4e2I\n\n\n\n\n \n\n\n4. Log files\n\n\nAll command-line codes in the \nscuff-em\n suite\nwrite logging information to text-based logfiles\nwith extension \n.log.\n You can monitor these\nfiles to follow the progress of your calculations.\n\n\nFor example, after launching \n\nthis sample \nscuff-cas3d\n run\n,\ntype the following at a terminal window:\n\n\n% tail -f SiliconSlabs_L2_40.log\n\n\n\n\nThis produces a running list of log messages, something like this:\n\n\n06/15/15::10:13:40: scuff-cas3D running on superhr1\n06/15/15::10:13:40: Added /home/homer/work/scuff-em-sandbox/mshFiles to mesh search path.\n06/15/15::10:13:40: Adding lattice basis vector (2,0).\n06/15/15::10:13:40: Adding lattice basis vector (0,2).\n06/15/15::10:13:40: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.19635,0.19635)\n06/15/15::10:13:49: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.217586,0.172518)\n06/15/15::10:13:51: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.256543,0.106264)\n06/15/15::10:13:52: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.275845,0.0318681) \n\n\n\n\n\n\n5. Output Files\n\n\nThe \nscuff-em\n application codes generally produce\noutput in the form of human-readable text-based\ndata files. The typical naming convention for \nthese files is \nGeometry.Extension\n, where \nGeometry.scuffgeo\n\nis the name of the \nscuff-em\n geometry file \non which the calculation was run, and where \nExtension\n\nis an application-specific file extension that attempts \nto describe the content of the file; for example, \n\nscuff-scatter\n produces files named \nGeometry.PFT\n\nto report the power, force, and torque on bodies \nirradiated by external fields. You can use the \n\n--filebase\n command-line option to \nscuff-em\n\ncodes to select a base filename other than \n\nGeometry.\n\n\nAll text-based data files produced by \nscuff-em\n\ncodes should contain a human-readable \nheader\n at the \ntop of the file explaining how to interpret its content.\nFor example, the first few lines of the \n\n.PFT\n output file produced by \nscuff-scatter\n\nlook like this:\n\n\n# scuff-scatter running on hikari 08/03/15::23:15:45\n# data file columns: \n# 1 omega \n# 2 surface label \n# 3 absorbed power (watts)\n# 4 scattered power (watts)\n# 5 x-force (nanoNewtons)\n# 6 y-force (nanoNewtons)\n# 7 z-force (nanoNewtons)\n# 8 x-torque (nanoNewtons*microns)\n# 9 y-torque (nanoNewtons*microns)\n# 10 z-torque (nanoNewtons*microns)\n0.05 Particle 6.994160e-04 1.562608e-03 -1.120907e-04 7.169210e-03 7.128598e-03 -3.622586e-03 1.005173e-03 9.428114e-02 \n\n\n\n\nIf you encounter a situation in which a \nscuff-em\n\napplication code fails to write an appropriate file\nheader to an output file, please file an issue\non the \n\nscuff-em\n GitHub page\n.\n\n\nOther types of output files produced by \nscuff-em\n\napplication codes include \n.hdf5\n binary data\nfiles and \n.pp\n files containing visualization data\nthat may be viewed in \ngmsh\n.\n\n\n6. Environment variables\n\n\nHere are some environment-variable settings that \naffect the behavior of \nscuff-em\n.\n\n\n% export SCUFF_GEO_PATH=/path/to/scuffgeo/files\n% export SCUFF_MESH_PATH=/path/to/msh/files\n% export SCUFF_MATPROP_PATH=/path/to/matprop/files\n\n\n\n\n\n\nThese environment variables may be used to specify\ncolon-separated lists of directories in which\n\nscuff-em\n will look for\nvarious types of input files:\n[\n.scuffgeo\n geometry files][Geometries] (\nSCUFF_GEO_PATH\n),\n\n.msh\n surface-mesh files (\nSCUFF_MESH_PATH\n),\nand\n[material-property files]\nMaterials\n.\n\n\n\n\n% export SCUFF_LOGLEVEL=\nNONE\n\n% export SCUFF_LOGLEVEL=\nTERSE\n\n% export SCUFF_LOGLEVEL=\nVERBOSE\n\n% export SCUFF_LOGLEVEL=\nVERBOSE2\n\n\n\n\n\n\n\nSets the verbosity of messages written to the \n.log\n file.\n\n\n\n\n% export SCUFF_INTERPOLATION_TOLERANCE=1.0e-3\n\n\n\n\n\n\nThis option, which is only relevant for\n\nextended geometries\n,\nset an internal tolerance parameter that controls\nthe accuracy with which BEM matrix elements and\nscattered fields are computed. Its default value\nis \n1.0e-6\n, but this is probably overly stringent,\nand may generally be relaxed to \n1e-3\n or so\nto reduce memory usage and CPU time without \nsignificant accuracy penalties. If your calculation\nis running out of memory or taking too long to run,\ntry setting it to \n1.0e-4\n or \n1.0e-3.\n\nPlease tell us about your experiences \nwith this parameter!\n\n\n(More specifically: \nscuff-em\n uses Ewald summation\nto accelerate the calculation of the periodic Green's\nfunction, but even this accelerated calculation is \nnot fast enough to handle the many millions of \nevaluations needed to assemble the full BEM matrix.\nFor this reason, when assembling the BEM matrix at\na given frequency and Bloch vector, \nscuff-em\n first\nprecomputes Ewald-summed values of the periodic DGF \nat grid points of an interpolation grid, after which\nvalues are obtained by interpolation (bypassing \nEwald summation). The spacing of the grid points is \nchosen automatically to ensure that the maximum relative \nerror between the interpolated and exact values at any \npoint within the grid boundaries is less than \n\nSCUFF_INTERPOLATION_TOLERANCE.\n\n\n\n\n% export OMP_NUM_THREADS=\n8\n\n% export GOMP_CPU_AFFINITY=\n0-7\n\n\n\n\n\n\n\nThese options \nshould not\n be necessary, but \nmay\n be\nneeded to ensure that \nscuff-em\n takes advantage\nof all available CPU cores on your system. The former \noption says that you want to use 8 cores, and the latter \noption says that you want these 8 cores to be the first\n8 available (as opposed to, say, the second set of 8\navailable cores on a 16-core machine).", 
            "title": "General command-line reference"
        }, 
        {
            "location": "/applications/GeneralReference/#1-common-command-line-arguments", 
            "text": "The various standalone applications in the  scuff-em  suite\nshare a number of command-line arguments in common,\nas described below.\nNot all codes accept all arguments (for example,  scuff-transmission  does not accept  --TransFile ), but the \nformat of each arguments is standardized among all codes that  do  \naccept that argument.", 
            "title": "1. Common command-line arguments"
        }, 
        {
            "location": "/applications/GeneralReference/#options-specifying-geometry-inputs", 
            "text": "--geometry MyGeometry.scuffgeo   Specifies the  scuff-em  geometry file \ndescribing your geometry. This option is always mandatory.   --TransFile MyTransformations.trans   Specifies an optional file describing one or more geometrical transformations \nto be applied to your geometry. Omitting the  --TransFile  option\n(when running a code that accepts it) is equivalent to specifying\nan empty transformation named  DEFAULT  that leaves the geometry\nunchanged from the configuration described by the  .scuffgeo  file.", 
            "title": "Options specifying geometry inputs"
        }, 
        {
            "location": "/applications/GeneralReference/#options-specifying-individual-frequencies-and-bloch-vectors-at-which-to-calculate", 
            "text": "--Omega 3.34\n--Omega 4.25+0.9i\n--Lambda 2.3\n--OmegaFile MyOmegaFile\n--LambdaFile MyLambdaFile   Specifies one or more frequencies at which to perform calculations.  --Omega  specifies the angular frequency in units of  \\omega_0=3\\cdot 10^{14}  rad/sec. The argument of  --Omega  may be a complex number .  The alternative option  --Lambda  instead specifies the frequency\nin terms of the corresponding free-space wavelength  \\lambda=c/\\omega  \n(where  c  is the  vacuum  speed of light, irrespective of the material\nproperties of your geometry.) --Lambda  values are interpreted in units of microns ( \\mu m).  The options  --OmegaFile  or  --LambdaFile  may be used to specify a \nfile containing one or more  --Omega  or  --Lambda  values, one \nper line (blank lines and comments are ignored.)   --OmegakBlochFile MyOkBFile   Similar to  --OmegaFile , but specifies a list of\n(frequency, Bloch vector) points at which to perform calculations.\nThis option only makes sense when used with  extended geometries  The argument specified for  --OmegakBlochFile  should\nbe a file containing two numbers on each line (for 1D extended \ngeometries) or three numbers on each line (for 2D extended \ngeometries). (Blank lines and comment lines beginning with  # \nare ignored.) The first number on each line is the  --Omega \nvalue; the next one or two numbers are the components of the \n1D or 2D Bloch wavevector, measured in units of ( \\mu m) ^{-1} .   --Xi 0.39 \n--XiFile MyXiFile\n--XikBlochFile MyXkBFile   Similar to  --Omega ,  --OmegaFile , and  --OmegakBlochFile,  \nbut used for codes ( scuff-cas3d  and scuff-caspol ) that perform calculations\nat pure imaginary frequencies,  \\omega=i\\xi .\nValues specified for  --Xi  should be positive real numbers.", 
            "title": "Options specifying individual frequencies and Bloch vectors at which to calculate"
        }, 
        {
            "location": "/applications/GeneralReference/#options-specifying-evaluation-points", 
            "text": "--EPFile MyEPFile   For codes that compute spatially-resolved output quantities,\nthis option specifies a file describing a list of spatial \nevaluation points. ( Which  output quantity depends\non the code you are running; for example, scuff-scatter \nwill report components of the scattered and total fields at the \nevaluation points, while scuff-neq \nwill report values of the thermally-averaged fluxes of\nenergy and momentum at the evaluation points.)  The argument to  --EPFile  should be a file containing one or more\nlines, each of which contains three space-separated numbers\n(the Cartesian coordinates of the evaluation point). \nBlank lines and comments (lines beginning with  # ) are ignored.\nFor example,\nto ask  scuff-scatter  for the scattered field components\nat points on the  z  axis, the file might look like this:  # evaluation points\n0.0 0.0 -2.0\n0.0 0.0 -1.9\n...\n0.0 0.0  1.9\n0.0 0.0  2.0", 
            "title": "Options specifying evaluation points"
        }, 
        {
            "location": "/applications/GeneralReference/#options-controlling-frequency-integrations", 
            "text": "--OmegaQuadrature [adaptive | cliff]\n--OmegaMin 0.01\n--XiQuadrature [adaptive | cliff]\n--XiMin 0.01\n--AbsTol\n--RelTol   These arguments affect the behavior of application codes\nthat compute output quantities by performing numerical\nintegrations over angular frequencies---either real\nangular frequencies  \\omega  or imaginary angular\nfrequencies  \\xi . (More specifically,  scuff-neq \nperforms  \\omega  integrations, while  scuff-cas3d  and scuff-caspol  perform  \\xi  integrations.)  --OmegaQuadrature  or  --XiQuadrature  specify the\nnumerical quadrature algorithm. If these\noptions are left unspecified, an appropriate algorithm \nis chosen automatically.  --OmegaMin  or  --XiMin  specify the minimum angular\nfrequency at which numerical  scuff-em  calculations \nare performed. For cases in which the lower limit of the  \\omega  or  \\xi  integration is 0, the integrand is \nassumed to be constant between 0 and the value specified here.\nThese options are interpreted in the usual  scuff-em \nfrequency units of  3\\times 10^{14}  rad/sec, so typical\nvalues will be something like  0.001.  --AbsTol  and  --RelTol  may be used to specify\nabsolute and relative error tolerances for adaptive\nquadrature algorithms. If an adaptive cubature method\nseems be spending too much time attempting to achieve\nhigh accuracy in a frequency quadrature, try increasing --RelTol  to something like  0.1  or even  0.5.", 
            "title": "Options controlling frequency integrations"
        }, 
        {
            "location": "/applications/GeneralReference/#options-controlling-brillouin-zone-integrations", 
            "text": "--BZQuadrature [adaptive | cliff]\n--BZSymmetry [adaptive | cliff]\n--MaxBZSamples 1000;   These arguments affect the behavior of application codes\nthat compute output quantities for periodic geometries\nby performing numerical integrations over the Brillouin\nzone. Such codes include  scuff-ldos ,  scuff-neq , scuff-cas3d , and  scuff-caspol .  --BZSymmetry  may be used for 2D periodic geometries to\ndeclare that the Brillouin-zone integrand  f(k_x, k_y) \nis symmetric under the interchange  k_x \\leftrightarrow k_y .  --MaxBZSamples 1000  may be used to restrict adaptive\nintegration algorithms to a maximum of 1,000 evaluations\nof the Brillouin-zone integrand.", 
            "title": "Options controlling Brillouin-zone integrations"
        }, 
        {
            "location": "/applications/GeneralReference/#miscellaneous-options", 
            "text": "--FileBase MyFileBase   Specifies the base file name for output files (so that, for example,\nthe frequency-resolved output file written by  scuff-cas3d \nwill be  MyFileBase.byXi , while the frequency-integrated \noutput file will be  MyFileBase.out ). If this option is not \nspecified, the file base is taken to be the base filename of the  .scuffgeo  file.", 
            "title": "Miscellaneous options"
        }, 
        {
            "location": "/applications/GeneralReference/#2-passing-command-line-options-via-text-file", 
            "text": "All of the standalone applications in the  scuff-em  suite allow \ntheir command-line options to be passed via a text file fed into \nstandard input.  Each line of this text file should consist of a single \ncommand-line option (minus the -- at the beginning) followed by any \narguments the option might take.  For example, running  scuff-scatter  with the command-line options  % scuff-scatter --geometry Spheres.scuffgeo --omega 1.0 --pwPolarization 1 0 0 --pwDirection 0 0 1 --EPFile MyEPFile   is equivalent to running  % scuff-scatter   MyOptionsFile  where the file  MyOptionsFile  looks like this:  # options for scuff-scatter \ngeometry Spheres.scuffgeo\nomega 1.0\n\npwPolarization 1 0 0 \npwDirection 0 0 1\n\nEPFile MyEPFile  Note that blank lines and comments (lines starting with #) are ignored.  You may also combine the two methods of specifying options by passing \nsome options via text file and others on the command line. If there are \nany conflicts, the values specified on the command line take precedence. \nFor instance, to re-run the example above at a new frequency with \neverything else unchanged, you could say   % scuff-scatter --Omega 2.0   MyOptionsFile", 
            "title": "2. Passing command-line options via text file"
        }, 
        {
            "location": "/applications/GeneralReference/#3-complex-numbers", 
            "text": "Many of the standalone programs in the  scuff-em  suite have \noptions for which you may specify complex numbers. (An example \nis the --omega option accepted by  scuff-scatter  and other \ncodes, for which you may specify complex or even pure imaginary \nnumbers to do calculations at complex frequencies.)  To specify a complex number as a parameter value, write both the \nreal and imaginary parts together as a single string (no spaces), \nseparated by  +  or  - , with the imaginary part terminated by  i  or  I  (you may also use  j  or  J ). For example, all \nof the following are valid frequency specifications:   --omega 2.3+4.5i\n --omega 2.3\n --omega 4.5j\n --omega 12.3e2+45.4e2I", 
            "title": "3. Complex numbers"
        }, 
        {
            "location": "/applications/GeneralReference/#4-log-files", 
            "text": "All command-line codes in the  scuff-em  suite\nwrite logging information to text-based logfiles\nwith extension  .log.  You can monitor these\nfiles to follow the progress of your calculations.  For example, after launching  this sample  scuff-cas3d  run ,\ntype the following at a terminal window:  % tail -f SiliconSlabs_L2_40.log  This produces a running list of log messages, something like this:  06/15/15::10:13:40: scuff-cas3D running on superhr1\n06/15/15::10:13:40: Added /home/homer/work/scuff-em-sandbox/mshFiles to mesh search path.\n06/15/15::10:13:40: Adding lattice basis vector (2,0).\n06/15/15::10:13:40: Adding lattice basis vector (0,2).\n06/15/15::10:13:40: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.19635,0.19635)\n06/15/15::10:13:49: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.217586,0.172518)\n06/15/15::10:13:51: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.256543,0.106264)\n06/15/15::10:13:52: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.275845,0.0318681)", 
            "title": "4. Log files"
        }, 
        {
            "location": "/applications/GeneralReference/#5-output-files", 
            "text": "The  scuff-em  application codes generally produce\noutput in the form of human-readable text-based\ndata files. The typical naming convention for \nthese files is  Geometry.Extension , where  Geometry.scuffgeo \nis the name of the  scuff-em  geometry file \non which the calculation was run, and where  Extension \nis an application-specific file extension that attempts \nto describe the content of the file; for example,  scuff-scatter  produces files named  Geometry.PFT \nto report the power, force, and torque on bodies \nirradiated by external fields. You can use the  --filebase  command-line option to  scuff-em \ncodes to select a base filename other than  Geometry.  All text-based data files produced by  scuff-em \ncodes should contain a human-readable  header  at the \ntop of the file explaining how to interpret its content.\nFor example, the first few lines of the  .PFT  output file produced by  scuff-scatter \nlook like this:  # scuff-scatter running on hikari 08/03/15::23:15:45\n# data file columns: \n# 1 omega \n# 2 surface label \n# 3 absorbed power (watts)\n# 4 scattered power (watts)\n# 5 x-force (nanoNewtons)\n# 6 y-force (nanoNewtons)\n# 7 z-force (nanoNewtons)\n# 8 x-torque (nanoNewtons*microns)\n# 9 y-torque (nanoNewtons*microns)\n# 10 z-torque (nanoNewtons*microns)\n0.05 Particle 6.994160e-04 1.562608e-03 -1.120907e-04 7.169210e-03 7.128598e-03 -3.622586e-03 1.005173e-03 9.428114e-02   If you encounter a situation in which a  scuff-em \napplication code fails to write an appropriate file\nheader to an output file, please file an issue\non the  scuff-em  GitHub page .  Other types of output files produced by  scuff-em \napplication codes include  .hdf5  binary data\nfiles and  .pp  files containing visualization data\nthat may be viewed in  gmsh .", 
            "title": "5. Output Files"
        }, 
        {
            "location": "/applications/GeneralReference/#6-environment-variables", 
            "text": "Here are some environment-variable settings that \naffect the behavior of  scuff-em .  % export SCUFF_GEO_PATH=/path/to/scuffgeo/files\n% export SCUFF_MESH_PATH=/path/to/msh/files\n% export SCUFF_MATPROP_PATH=/path/to/matprop/files   These environment variables may be used to specify\ncolon-separated lists of directories in which scuff-em  will look for\nvarious types of input files:\n[ .scuffgeo  geometry files][Geometries] ( SCUFF_GEO_PATH ), .msh  surface-mesh files ( SCUFF_MESH_PATH ),\nand\n[material-property files] Materials .   % export SCUFF_LOGLEVEL= NONE \n% export SCUFF_LOGLEVEL= TERSE \n% export SCUFF_LOGLEVEL= VERBOSE \n% export SCUFF_LOGLEVEL= VERBOSE2    Sets the verbosity of messages written to the  .log  file.   % export SCUFF_INTERPOLATION_TOLERANCE=1.0e-3   This option, which is only relevant for extended geometries ,\nset an internal tolerance parameter that controls\nthe accuracy with which BEM matrix elements and\nscattered fields are computed. Its default value\nis  1.0e-6 , but this is probably overly stringent,\nand may generally be relaxed to  1e-3  or so\nto reduce memory usage and CPU time without \nsignificant accuracy penalties. If your calculation\nis running out of memory or taking too long to run,\ntry setting it to  1.0e-4  or  1.0e-3. \nPlease tell us about your experiences \nwith this parameter!  (More specifically:  scuff-em  uses Ewald summation\nto accelerate the calculation of the periodic Green's\nfunction, but even this accelerated calculation is \nnot fast enough to handle the many millions of \nevaluations needed to assemble the full BEM matrix.\nFor this reason, when assembling the BEM matrix at\na given frequency and Bloch vector,  scuff-em  first\nprecomputes Ewald-summed values of the periodic DGF \nat grid points of an interpolation grid, after which\nvalues are obtained by interpolation (bypassing \nEwald summation). The spacing of the grid points is \nchosen automatically to ensure that the maximum relative \nerror between the interpolated and exact values at any \npoint within the grid boundaries is less than  SCUFF_INTERPOLATION_TOLERANCE.   % export OMP_NUM_THREADS= 8 \n% export GOMP_CPU_AFFINITY= 0-7    These options  should not  be necessary, but  may  be\nneeded to ensure that  scuff-em  takes advantage\nof all available CPU cores on your system. The former \noption says that you want to use 8 cores, and the latter \noption says that you want these 8 cores to be the first\n8 available (as opposed to, say, the second set of 8\navailable cores on a 16-core machine).", 
            "title": "6. Environment variables"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/", 
            "text": "Solving electromagnetic scattering problems with \n     \nscuff-scatter\n\n\n\n\n\nscuff-scatter\n is a tool within the \nscuff-em\n code suite\nfor solving classical scattering problems involving\nuser-specified incident fields impinging on a material\ngeometry.\n\n\nTo run a scattering calculation using \nscuff-scatter\n, you will\n\n\n\n\n\n\nCreate a \nscuff-em\n geometry file\n\ndescribing the shapes and material properties of the scattering objects in your geometry\n\n\n\n\n\n\nChoose the \nincident field\n that will scatter off your objects: a plane wave, a gaussian beam, a point dipole source, or some combination thereof\n\n\n\n\n\n\nRun \nscuff-scatter\n with command-line options specifying the geometry, the frequencies, the incident field, and the type of output you wish to get back.\n\n\n\n\n\n\nThe various output quantities that you can ask \nscuff-scatter\n to generate include the following:\n\n\n\n\n\n\nThe components of the scattered and total electric and magnetic fields at arbitrary user-specified points away from scattering surfaces. (The points may lie inside or outside the scattering objects).\n\n\n\n\n\n\nThe components of the total electric and magnetic fields on the scattering surfaces. (These quantities may alternatively be interpreted as effective surface currents and charges that give rise to the scattered fields.)\n\n\n\n\n\n\nThe electric and magnetic dipole moments induced by the incident field on the scattering objects. (These are obtained from the interpretation of the tangential fields as effective sources that radiate the scattered fields.)\n\n\n\n\n\n\nThe total power scattered by, and the total power absorbed by, the scattering objects from the incident field.\n\n\n\n\n\n\nThe total force and/or torque exerted on the scattering objects by the incident fields (radiation pressure).\n\n\n\n\n\n\nVisualization files plotting the electric and magnetic surface currents, and the associated charge densities, \n  induced by the incident fields on the scattering objects.\n\n\n\n\n\n\nVisualization files plotting field components and Poynting fluxes on arbitrary user-specified surface meshes.\n\n\n\n\n\n\nFor more sophisticated users, \nscuff-scatter\n also offers\nan \nadvanced mode\n of operation that exposes---at the\ncommand-line level---some of the key efficiencies of the\n\nsurface-integral-equation formulation\n\nimplemented by the\n\nscuff-em\n core library\n.\nThis offers significant speedup for certain types of computations,\nat the expense of a slightly more effort required to set\nup your calculation.\n\n\nTable of Contents\n\n\n1. \nscuff-scatter\n command-line options\n\n\nCommon options\n\n\nOptions defining the scattering problem\n\n\nOptions defining the incident field\n\n\nOptions requesting scattered and total fields\n\n\nOptions requesting power, force, and torque data\n\n\n\n\n\n\n2. \nscuff-scatter\n advanced mode\n\n\n3. \nscuff-scatter\n examples\n\n\n\n\n\n\n\n\n1. \nscuff-scatter\n command-line options\n\n\nCommon options\n\n\nscuff-scatter\n recognizes the following subset of the \n\nlist of commonly accepted options to \nscuff-em\n command-line codes\n.\n\n\n--geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache\n\n\n\n\nOptions defining the scattering problem\n\n\n--geometry MyGeometry.scuffgeo\n\n\n\n\nSpecifies the geometry input file.\n\n\n--Omega      3.1415\n--OmegaFile  MyOmegaFile\n--Lambda     0.5\n--LambdaFile MyLambdaFile\n\n\n\n\nSpecifies the angular frequencies at which to\nrun calculations. (Angular frequencies are interpreted\nin units of \nc/1\\,\\mu\\text{m}=3\\cdot 10^{14}\n rad/sec.)\nThe \n--Omega\n option may be used more than once \nto specify multiple frequencies. Alternatively,\nthe \n--OmegaFile\n option may be used to specify the\nname of a file containing a list of frequencies (one per\nline) at which to run calculations.\n\n\nThe options \n--Lambda\n and \n--LambdaFile\n may alternatively\nbe used to define the frequencies at which to run calculations\nin terms of the corresponding free-space wavelength\n\n\\lambda=\\frac{2\\pi}{\\omega}\n, interpreted in units\nof microns. Thus \n--Omega 3.1415\n and \n--Lambda 0.5\n\nare equivalent; both specify an angular frequency\n\n\\omega=\\pi \\cdot 3\\cdot 10^{14}\nrad/sec, \ncorresponding\nto a free-space wavelength of \n\\lambda=0.5\\,\\mu\nm.\n\n\nNote: Even if you use \n--Lambda / --LambdaFile\n\ninstead of \n--Omega / --OmegaFile\n to specify the\ncomputational frequencies, the output files\nwill still report data in terms of the frequency\n(the equivalent \n--Omega\n values), not the \nwavelength. To plot your data versus wavelength\ninstead of frequency, just plot versus the\nquantity \n\\frac{2\\pi}{\\omega}\n.\n\n\nOptions defining the incident field\n\n\nThe options for specifying incident fields in\n\nscuff-em\n are described in detail on the page\n\nIncident fields in \nscuff-em\n;\nhere we just list the\navailable options without commentary.\n\n\n--pwDirection    nx ny nz\n--pwPolarization Ex Ey Ez\n\n\n\n\n--psStrength Px Py Pz\n--psLocation xx yy zz\n\n\n\n\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbCenter Cx Cy Cz\n--gbWaist W\n\n\n\n\n(As in \nscuff-scatter\n, these options may occur multiple times \nto define superpositions of multiple types of incident field.)\n\n\nOptions requesting scattered and total fields\n\n\n --EPFile MyEPFile\n\n\n\n\nSpecifies a list of evaluation points at which to\ncompute and report components of the scattered and total\nfields. This option may be specified more than once to \ndefine multiple sets of field evaluation points. \n\n\nOptions requesting power, force, and torque data\n\n\n --PFTFile     MyGeometry.PFT\n --EMTPFTFile  MyGeometry.EMTPFT\n --OPFTFile    MyGeometry.OPFT\n --DSIPFTFile  MyGeometry.DSIPFT\n\n\n\n\nEach of these options requests that power, force, and torque (PFT)\ndata be written to a file of the specified name. The resulting\nfiles all have the same file format---reporting absorbed and\nscattered power, force (radiation pressure), and torque\nfor all objects in the geometry at all frequencies you\nrequested (see the file header for details)---but differ \nin the algorithm used to compute the force:\n\n\n\n\n\n\nThe \"energy-momentum-transfer\" PFT (EMTPFT) method\ncomputes powers, forces and torques by considering the\nJoule heating of, and Lorentz force on, the\nsurface currents in the presence of the total \nfields. (This is the default, so the \n--PFTFile\n \noption is synonymous with \n--EMTPFTFile\n.)\n\n\n\n\n\n\nThe \"displaced-surface-integral\" PFT (DSIPFT) method\ncomputes PFTs by integrating the Poynting vector\nand Maxwell stress tensor over a bounding surface \nsurrounding the body.\n\n\n\n\n\n\nThe \"overlap\" PFT (OPFT) method computes PFTs\ndirectly from the surface currents by exploiting\nthe relationship between the surface currents\nand the total electric and magnetic fields at \nbody surfaces.\n\n\n\n\n\n\n\n\n2. \nscuff-scatter\n advanced mode\n\n\nFor some types of calculation it is possible to achieve\nsignificant computational accelerations by taking advantage\nof certain efficiencies inherent in the particular \nmathematical strategy used by the \n\nscuff-em\n core library\n\nto solve Maxwell's equations---namely, the\ndiscretized surface-integral-equation (SIE) formulation.\n\n\nYou can read about all the gory details of SIE solvers \n\nhere\n, but for the purposes of \nthis discussion all you really need to know is this: For a\ngiven material geometry irradiated by a given incident field \nat a given frequency, \nscuff-em\n assembles and solves a \nlinear system of the form\n\n \\mathbf{M}(\\omega) \\mathbf{c} = \\mathbf{f}^{\\text{inc}}\n\nwhere \n\n\n\n\n\n\nc\n represents the unknown surface currents for which we are solving,\n\n\n\n\n\n\nthe RHS vector \nf\n depends on the geometry, the frequency, and the incident field,\n\n\n\n\n\n\nthe matrix \nM\n depends on the scattering geometry and the frequency but not on the incident field.\nMore specifically, for a scattering geometry consisting of \nN\n objects\n(or \nN\n surfaces in a \n\nregions-and-surfaces geometry specification\n),\nthe matrix \nM\n has an \nN\nN\n block structure in which the \n(m,n)\n block\ndescribes the interactions of object \nm\n with object \nn\n.\n\n\n\n\n\n\nArmed with just this much knowledge, we can understand the\ntwo key efficiencies possible in SIE scattering calculations:\n\n\n\n\n\n\n(1)\n First, suppose that, in a geometry consisting of 2 or more bodies,\nwe would like to perform calculations for various different\nrelative geometric configurations of the bodies---for example,\ndifferent separation distances or rotation angles between bodies---at\nthe same frequency.\nThe diagonal blocks of the \nM\n matrix, which represent \nthe self-interactions of objects and are the most costly\nblocks to compute, are \nindependent\n of the relative \nconfiguration of the various objects in the geometry,\nand thus need only be computed \nonce\n for a given\ngeometry at a given frequency, after which they may be\nreused for any number of calculations involving \nrearrangements of the relative positions and orientations\nof the bodies.    \n\n\nThus, if we are interested in running calculations\nfor a sphere-cube geometry at (say) 7 different\nvalues of the surface-surface separation, it greatly\nbehooves us to assemble the diagonal (self-interaction)\nblocks just \nonce\n per frequency, then reuse \nthese blocks for each of the 7 separation distances.\nThe sphere-cube interaction block of the matrix\nmust be recomputed at each separation distance, but \nthis is relatively cheap compared to the cost of \ncomputing the sphere-sphere and cube-cube \nself-interaction blocks.   \n\n\n\n\n\n\n\n\n\n\n\n\n(2)\n In the equation above, the LHS is \nindependent\n of\nthe incident field. This means that, once we have \nassembled and LU-factorized the \nM\n matrix \nfor given geometry at a given frequency (a procedure\nwhich scales asymptotically like \n\\sim T^3\n with \nT\n \nthe total number of triangles in our surface meshes) \nwe can solve scattering problems for any number of\nincident fields with cost \n\\sim T^2\n per incident\nfield---that is, essentially \nfor free\n compared\nto the cost of assembling and factorizing the matrix.\n\n\nThus, if we are interested in observing the \nscattering properties of our geometry under irradiation\nby 7 different types of incident field (say,\nplane waves originating from 7 different angles)\nit greatly behooves us to form and LU-factorize\nthe \nM\n matrix just \nonce\n for this frequency,\nthen reuse the factorized matrix to solve the linear\nsystem above for the 7 different types of incident field.\n\n\n\n\n\n\nTo take advantage of efficiency \n(a)\n, \nscuff-scatter\n\nsupports the command-line option\n\n\n  --transfile MyTransFile\n\n\n\n\nwhere \nMyTransFile\n is a \n\nlist of geometrical transformations\n.\n\n\nTo take advantage of efficiency \n(b)\n, \nscuff-scatter\n\nsupports the command-line option\n\n\n  --IFFile    MyIFFile\n\n\n\n\nwhere \nMyIFFile\n is a \nlist of incident fields\n.\n\n\n\n\n3. \nscuff-scatter\n examples\n\n\n\n\nMie scattering\n\n\nElectrostatics of a spherical dielectric shell\n\n\nSpatially-resolved study of plane-wave transmission through a infinite-area thin dielectric film\n\n\nDiffraction of a plane wave by a discs, disc arrays, and hole arrays", 
            "title": "scuff-scatter"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#common-options", 
            "text": "scuff-scatter  recognizes the following subset of the  list of commonly accepted options to  scuff-em  command-line codes .  --geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache", 
            "title": "Common options"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-defining-the-scattering-problem", 
            "text": "--geometry MyGeometry.scuffgeo  Specifies the geometry input file.  --Omega      3.1415\n--OmegaFile  MyOmegaFile\n--Lambda     0.5\n--LambdaFile MyLambdaFile  Specifies the angular frequencies at which to\nrun calculations. (Angular frequencies are interpreted\nin units of  c/1\\,\\mu\\text{m}=3\\cdot 10^{14}  rad/sec.)\nThe  --Omega  option may be used more than once \nto specify multiple frequencies. Alternatively,\nthe  --OmegaFile  option may be used to specify the\nname of a file containing a list of frequencies (one per\nline) at which to run calculations.  The options  --Lambda  and  --LambdaFile  may alternatively\nbe used to define the frequencies at which to run calculations\nin terms of the corresponding free-space wavelength \\lambda=\\frac{2\\pi}{\\omega} , interpreted in units\nof microns. Thus  --Omega 3.1415  and  --Lambda 0.5 \nare equivalent; both specify an angular frequency \\omega=\\pi \\cdot 3\\cdot 10^{14} rad/sec, \ncorresponding\nto a free-space wavelength of  \\lambda=0.5\\,\\mu m.  Note: Even if you use  --Lambda / --LambdaFile \ninstead of  --Omega / --OmegaFile  to specify the\ncomputational frequencies, the output files\nwill still report data in terms of the frequency\n(the equivalent  --Omega  values), not the \nwavelength. To plot your data versus wavelength\ninstead of frequency, just plot versus the\nquantity  \\frac{2\\pi}{\\omega} .", 
            "title": "Options defining the scattering problem"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-defining-the-incident-field", 
            "text": "The options for specifying incident fields in scuff-em  are described in detail on the page Incident fields in  scuff-em ;\nhere we just list the\navailable options without commentary.  --pwDirection    nx ny nz\n--pwPolarization Ex Ey Ez  --psStrength Px Py Pz\n--psLocation xx yy zz  --gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbCenter Cx Cy Cz\n--gbWaist W  (As in  scuff-scatter , these options may occur multiple times \nto define superpositions of multiple types of incident field.)", 
            "title": "Options defining the incident field"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-requesting-scattered-and-total-fields", 
            "text": "--EPFile MyEPFile  Specifies a list of evaluation points at which to\ncompute and report components of the scattered and total\nfields. This option may be specified more than once to \ndefine multiple sets of field evaluation points.", 
            "title": "Options requesting scattered and total fields"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-requesting-power-force-and-torque-data", 
            "text": "--PFTFile     MyGeometry.PFT\n --EMTPFTFile  MyGeometry.EMTPFT\n --OPFTFile    MyGeometry.OPFT\n --DSIPFTFile  MyGeometry.DSIPFT  Each of these options requests that power, force, and torque (PFT)\ndata be written to a file of the specified name. The resulting\nfiles all have the same file format---reporting absorbed and\nscattered power, force (radiation pressure), and torque\nfor all objects in the geometry at all frequencies you\nrequested (see the file header for details)---but differ \nin the algorithm used to compute the force:    The \"energy-momentum-transfer\" PFT (EMTPFT) method\ncomputes powers, forces and torques by considering the\nJoule heating of, and Lorentz force on, the\nsurface currents in the presence of the total \nfields. (This is the default, so the  --PFTFile  \noption is synonymous with  --EMTPFTFile .)    The \"displaced-surface-integral\" PFT (DSIPFT) method\ncomputes PFTs by integrating the Poynting vector\nand Maxwell stress tensor over a bounding surface \nsurrounding the body.    The \"overlap\" PFT (OPFT) method computes PFTs\ndirectly from the surface currents by exploiting\nthe relationship between the surface currents\nand the total electric and magnetic fields at \nbody surfaces.", 
            "title": "Options requesting power, force, and torque data"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#2-scuff-scatter-advanced-mode", 
            "text": "For some types of calculation it is possible to achieve\nsignificant computational accelerations by taking advantage\nof certain efficiencies inherent in the particular \nmathematical strategy used by the  scuff-em  core library \nto solve Maxwell's equations---namely, the\ndiscretized surface-integral-equation (SIE) formulation.  You can read about all the gory details of SIE solvers  here , but for the purposes of \nthis discussion all you really need to know is this: For a\ngiven material geometry irradiated by a given incident field \nat a given frequency,  scuff-em  assembles and solves a \nlinear system of the form  \\mathbf{M}(\\omega) \\mathbf{c} = \\mathbf{f}^{\\text{inc}} \nwhere     c  represents the unknown surface currents for which we are solving,    the RHS vector  f  depends on the geometry, the frequency, and the incident field,    the matrix  M  depends on the scattering geometry and the frequency but not on the incident field.\nMore specifically, for a scattering geometry consisting of  N  objects\n(or  N  surfaces in a  regions-and-surfaces geometry specification ),\nthe matrix  M  has an  N N  block structure in which the  (m,n)  block\ndescribes the interactions of object  m  with object  n .    Armed with just this much knowledge, we can understand the\ntwo key efficiencies possible in SIE scattering calculations:    (1)  First, suppose that, in a geometry consisting of 2 or more bodies,\nwe would like to perform calculations for various different\nrelative geometric configurations of the bodies---for example,\ndifferent separation distances or rotation angles between bodies---at\nthe same frequency.\nThe diagonal blocks of the  M  matrix, which represent \nthe self-interactions of objects and are the most costly\nblocks to compute, are  independent  of the relative \nconfiguration of the various objects in the geometry,\nand thus need only be computed  once  for a given\ngeometry at a given frequency, after which they may be\nreused for any number of calculations involving \nrearrangements of the relative positions and orientations\nof the bodies.      Thus, if we are interested in running calculations\nfor a sphere-cube geometry at (say) 7 different\nvalues of the surface-surface separation, it greatly\nbehooves us to assemble the diagonal (self-interaction)\nblocks just  once  per frequency, then reuse \nthese blocks for each of the 7 separation distances.\nThe sphere-cube interaction block of the matrix\nmust be recomputed at each separation distance, but \nthis is relatively cheap compared to the cost of \ncomputing the sphere-sphere and cube-cube \nself-interaction blocks.          (2)  In the equation above, the LHS is  independent  of\nthe incident field. This means that, once we have \nassembled and LU-factorized the  M  matrix \nfor given geometry at a given frequency (a procedure\nwhich scales asymptotically like  \\sim T^3  with  T  \nthe total number of triangles in our surface meshes) \nwe can solve scattering problems for any number of\nincident fields with cost  \\sim T^2  per incident\nfield---that is, essentially  for free  compared\nto the cost of assembling and factorizing the matrix.  Thus, if we are interested in observing the \nscattering properties of our geometry under irradiation\nby 7 different types of incident field (say,\nplane waves originating from 7 different angles)\nit greatly behooves us to form and LU-factorize\nthe  M  matrix just  once  for this frequency,\nthen reuse the factorized matrix to solve the linear\nsystem above for the 7 different types of incident field.    To take advantage of efficiency  (a) ,  scuff-scatter \nsupports the command-line option    --transfile MyTransFile  where  MyTransFile  is a  list of geometrical transformations .  To take advantage of efficiency  (b) ,  scuff-scatter \nsupports the command-line option    --IFFile    MyIFFile  where  MyIFFile  is a  list of incident fields .", 
            "title": "2. scuff-scatter advanced mode"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#3-scuff-scatter-examples", 
            "text": "Mie scattering  Electrostatics of a spherical dielectric shell  Spatially-resolved study of plane-wave transmission through a infinite-area thin dielectric film  Diffraction of a plane wave by a discs, disc arrays, and hole arrays", 
            "title": "3. scuff-scatter examples"
        }, 
        {
            "location": "/applications/scuff-transmission/scuff-transmission/", 
            "text": "scuff-transmission\n\n\nThe documentation for \nscuff-transmission\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-transmission"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/", 
            "text": "Computing the photonic local density of states with\n    \nscuff-ldos\n\n\n\n\n\n\n\nscuff-ldos\n\nis a tool for computing the electromagnetic local density \nof states (LDOS) at points inside or outside compact or \nextended material bodies.\n\n\nThe inputs you supply to \nscuff-ldos\n calculation are\n\n\n\n\n\n\nA \n.scuffgeo\n file describing your geometry.\n\n\n\n\n\n\nA list of evaluation points \n\\mathbf x\n at which you want to know\n  the LDOS.\n\n\n\n\n\n\nOne or more angular frequencies \n\\omega\n at which to perform\n  calculations.\n\n\n\n\n\n\nOptionally, for periodic geometries, you may additionally specify\n  a list of Bloch wavevectors at which to evaluate wavevector-resolved\n  contributions to the LDOS. If you do not specify such a list,\n  \nscuff-ldos\n will evaluate an integral over the Brillouin zone\n  to compute the total LDOS at each \n(\\omega, \\mathbf x)\n point.\n\n\n\n\n\n\nThe outputs you get back from a \nscuff-ldos\n calculation may\ninclude\n\n\n\n\n\n\nThe LDOS at each \n(\\omega, \\mathbf x)\n point.\n\n\n\n\n\n\nFor periodic geometries, the contributions of individual\n  Bloch wavevectors \n\\mathbf k_{\\text{Bloch}}\n to the LDOS.\n  If you supplied a list of Bloch vectors as an input,\n  you will get wavevector-resolved information for each point\n  in your list; otherwise, you will get wavevector-resolved \n  information for each point chosen automatically by \n  \nscuff-ldos\n in its numerical-cubature evaluation of \n  the Brillouin-zone integral.\n\n\n\n\n\n\nOptionally, the full Cartesian components of the scattering\n  parts of the dyadic Green's functions (DGFs) [the \n  electric / magnetic LDOS is proportional to the imaginary part \n  of the trace of the electric / magnetic DGFs].\n\n\n\n\n\n\nFor testing purposes, \nscuff-ldos\n also includes built-in\nfunctionality to compute the LDOS for some geometries that\nmay be handled analytically (specifically, infinite-area PEC\nground planes and infinite-area dielectric half-spaces).\n\n\nTable of Contents\n\n\n1. What \nscuff-ldos\n actually computes\n\n\n2. \nscuff-ldos\n command-line options\n\n\nCommon options\n\n\nOptions requesting analytical LDOS calculations\n\n\n\n\n\n\n3. \nscuff-ldos\n output files\n\n\nThe .log file\n\n\nThe .LDOS file\n\n\nThe .byOmegakBloch file\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-ldos\n\n\n\n\n\n\n\n\n1. What \nscuff-ldos\n actually computes\n\n\nSome technical details on the calculation performed by\n\nscuff-ldos\n may be found in \nthis memo\n.\nThe long story short is as follows:\n\n\nWhat \nscuff-ldos\n actually computes is the scattering\npart of the dyadic Green's functions (DGFs) of the geometry \nin question. For a given (angular frequency, evaluation point)\npair \n(\\omega, \\mathbf x)\n, these are \n3\\times 3\n matrices\ngiving the scattered fields at \n\\mathbf x\n due to point sources\nat \n\\mathbf x\n, with all fields and sources having time\ndependence \ne^{-i\\omega t}\n. (The full definition may be\nfound in the memo above). The LDOS is obtained from the \nimaginary part of the traces of the DGFs.\n\n\nFor non-periodic geometries, \nscuff-ldos\n does 6 scattering\ncalculations for each \n(\\omega, \\mathbf x)\n point---specifically,\nscattering calculations in which the incident field is the\nfield of an electric or magnetic point source oriented in \neach of the 3 cartesian directions. (Because these calculations\ninvolve the same scattering geometry at the same frequency,\njust with different incident fields, they are fast in a \nBEM solver like \nscuff-em\n because the BEM matrix need\nnot be recomputed anew for each new incident field.) The\nresults for the LDOS at each \n(\\omega,\\mathbf x)\n point are\nreported in the \n.LDOS\n output file.\n\n\nFor periodic geometries, \nscuff-ldos\n does many scattering\ncalculations for each \n(\\omega, \\mathbf x)\n point.\nIndeed, the DGFs at \n\\mathbf x\n are defined as the response of \nthe system to a single point source at \n\\mathbf x\n; however, in\nin \nscuff-em\n calculations for periodic geometries,\n\nall\n currents and fields, including incident fields, \nmust be Bloch-periodic, a condition which is not satisfied\nby the fields of a single point source at \n\\mathbf x\n. Instead,\nwhat \nscuff-em\n can compute is the response of the system\nto a phased \narray\n of point sources---that is, an infinite\ncollection of point sources located at points \n\\mathbf x+\\mathbf L\n\nwith phases \ne^{ik_BL}\n; here \n\\mathbf L\n ranges over all \nlattice vectors in a 1D or 2D lattice, and \nk_B\n is \na 1D or 2D Bloch wavevector that ranges over the\nBrillouin zone (BZ) of the reciprocal lattice. By performing\nthese calculations at \nall\n possible Bloch vectors\n\nk_B\n and adding up the results---that is, by\nperforming an integration over the BZ, effectively an \ninverse Fourier transform---we recover \nthe fields of just the single point source at \n\\mathbf x\n.\nFor periodic geometries, \nscuff-ldos\n performs this \nBZ integration by numerical cubature for\neach \n(\\omega,\\mathbf x)\n point. This involves sampling\nthe integrand (that is, computing Bloch-periodic DGFs) \nat large numbers of \nk_B\n points; these samples, \nwhich provide Bloch-vector-resolved information on the \nLDOS and DGFs of the system, are reported by \nscuff-ldos\n \nin the\n.byOmegakBloch\n output file, while results \nfor the full (BZ-integrated) LDOS are written to the \n\n.LDOS\n output file.\n\n\n\n\n\n\n2. \nscuff-ldos\n command-line options\n\n\nCommon options\n\n\nscuff-ldos\n recognizes the following subset of the \n[list of commonly accepted options to \nscuff-em\n command-line codes][CommonOptions].\n\n\n--geometry\n--EPFile\n--Omega\n--OmegaFile\n--OmegakBlochFile\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache\n\n\nOf these options, \n--geometry\n and \n--EPFile\n are\nalways mandatory, while one of \n\n--Omega\n, \n--OmegaFile\n, or \n--OmegakBlochFile\n \nmust also be specified. All\nother command-line arguments are optional.\n\n\nIf you specify \n--Omega\n or \n--OmegaFile\n in\na calculation involving a periodic geometry,\nthen \nscuff-ldos\n will perform a numerical\ncubature over the Brillouin zone for each\n\n\\omega\n value. (The options \n--BZSymmetry\n,\n\n--AbsTol\n, and \n--RelTol\n control the \nparameters of this cubature.) Samples\nof the integrand at the cubature points \nwill be written to the \n.byOmegakBloch\n \nfile, while the full integrated resuts\nwill be written to the \n.LDOS\n file.\n\n\nAlternatively, if you use \n--OmegakBlochFile\n\nto specify a list of (\n\\omega, \\mathbf k_B\n)\npoints, then \nscuff-ldos\n will skip the\nnumerical BZ cubature and instead perform\ncomputations at just the points you \nspecified. In this case you wil get back a\n\n.byOmegakBloch\n file, but not an\n\n.LDOS\n file.\n\n\nOptions requesting analytical LDOS calculations\n\n\n````\n--GroundPlane\n\n\n--HalfSpace PEC\n--HalfSpace Aluminum\n\n\n--SkipBZIntegration\n  ````\n\n\nAs noted above, for testing purposes \nscuff-ldos\n incorporates\n\n\nThe first option here instructs \nscuff-ldos\n to \nbypass the usual LDOS calculation it would otherwise \nperform and instead to compute the LDOS of an\nauxiliary geometry in which the half-space \nregion lying below the \nxy\n plane (the region\n\nz<0\n) is filled with a homogeneous material\ndescribed by the given \n\nscuff-em\n material designation\n.\nIf this material is \nPEC\n, then the calculation\nis performed using the image-source method.\nOtherwise, the calculation is performed using the \nanalytical plane-wave decomposition \noutlined in the \n\nscuff-ldos\n memo\n.\n\n\nAs illustrated by \nthis example\n,\nthe \n--HalfSpace\n option is intended to be\ntacked on to an otherwise complete \nscuff-ldos\n\ncommand-line containing options such as \n\n--geometry\n and \n--EPFile.\n With \n--HalfSpace\n,\n\nscuff-ldos\n performs the same calculation that \nit would do without that option---using the same\nevaluation points and the same frequency options---but\njust does the calculation a different way. (Although\nthe surface meshes specified in the \n.scuffgeo\n\nfile are not referenced in this case, a \nvalid \n.scuffgeo\n file must still be supplied;\nthe \nLATTICE...ENDLATTICE\n section of this \nfile is used to define the lattice used \nfor the analytical calculation.)\n\n\n\n\n3. \nscuff-ldos\n output files\n\n\nThe \n.log\n file\n\n\nLike all command-line codes in the \nscuff-em\n suite,\n\nscuff-ldos\n produces a text output file named\n\nFileBase.log\n that you can follow to monitor the\nstatus of your calculation.\n\n\nThe \n.LDOS\n file\n\n\nThis file reports values of the electric and magnetic\nLDOS for each angular frequency and each evaluation\npoint you requested. This file is always produced\nfor calculations on non-periodic geometries. For\ncalculation on periodic geometries, this file is \nproduced only if you specified the \n\n--Omega\n and/or \n--OmegaFile\n command-line options.\n\n\nThe \n.byOmegakBloch\n file\n\n\nThis file reports Bloch-vector resolved versions\nof the information reported by the \n.LDOS\n file.\nThis file is only produced for calculations on\nperiodic geometries.\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-ldos\n\n\n\n\nLDOS above a dielectric half-space", 
            "title": "scuff-ldos"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#2-scuff-ldos-command-line-options", 
            "text": "", 
            "title": "2. scuff-ldos command-line options"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#common-options", 
            "text": "scuff-ldos  recognizes the following subset of the \n[list of commonly accepted options to  scuff-em  command-line codes][CommonOptions].  --geometry\n--EPFile\n--Omega\n--OmegaFile\n--OmegakBlochFile\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache  Of these options,  --geometry  and  --EPFile  are\nalways mandatory, while one of  --Omega ,  --OmegaFile , or  --OmegakBlochFile  \nmust also be specified. All\nother command-line arguments are optional.  If you specify  --Omega  or  --OmegaFile  in\na calculation involving a periodic geometry,\nthen  scuff-ldos  will perform a numerical\ncubature over the Brillouin zone for each \\omega  value. (The options  --BZSymmetry , --AbsTol , and  --RelTol  control the \nparameters of this cubature.) Samples\nof the integrand at the cubature points \nwill be written to the  .byOmegakBloch  \nfile, while the full integrated resuts\nwill be written to the  .LDOS  file.  Alternatively, if you use  --OmegakBlochFile \nto specify a list of ( \\omega, \\mathbf k_B )\npoints, then  scuff-ldos  will skip the\nnumerical BZ cubature and instead perform\ncomputations at just the points you \nspecified. In this case you wil get back a .byOmegakBloch  file, but not an .LDOS  file.", 
            "title": "Common options"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#options-requesting-analytical-ldos-calculations", 
            "text": "````\n--GroundPlane  --HalfSpace PEC\n--HalfSpace Aluminum  --SkipBZIntegration\n  ````  As noted above, for testing purposes  scuff-ldos  incorporates  The first option here instructs  scuff-ldos  to \nbypass the usual LDOS calculation it would otherwise \nperform and instead to compute the LDOS of an\nauxiliary geometry in which the half-space \nregion lying below the  xy  plane (the region z<0 ) is filled with a homogeneous material\ndescribed by the given  scuff-em  material designation .\nIf this material is  PEC , then the calculation\nis performed using the image-source method.\nOtherwise, the calculation is performed using the \nanalytical plane-wave decomposition \noutlined in the  scuff-ldos  memo .  As illustrated by  this example ,\nthe  --HalfSpace  option is intended to be\ntacked on to an otherwise complete  scuff-ldos \ncommand-line containing options such as  --geometry  and  --EPFile.  With  --HalfSpace , scuff-ldos  performs the same calculation that \nit would do without that option---using the same\nevaluation points and the same frequency options---but\njust does the calculation a different way. (Although\nthe surface meshes specified in the  .scuffgeo \nfile are not referenced in this case, a \nvalid  .scuffgeo  file must still be supplied;\nthe  LATTICE...ENDLATTICE  section of this \nfile is used to define the lattice used \nfor the analytical calculation.)", 
            "title": "Options requesting analytical LDOS calculations"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#3-scuff-ldos-output-files", 
            "text": "", 
            "title": "3. scuff-ldos output files"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#the-log-file", 
            "text": "Like all command-line codes in the  scuff-em  suite, scuff-ldos  produces a text output file named FileBase.log  that you can follow to monitor the\nstatus of your calculation.", 
            "title": "The .log file"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#the-ldos-file", 
            "text": "This file reports values of the electric and magnetic\nLDOS for each angular frequency and each evaluation\npoint you requested. This file is always produced\nfor calculations on non-periodic geometries. For\ncalculation on periodic geometries, this file is \nproduced only if you specified the  --Omega  and/or  --OmegaFile  command-line options.", 
            "title": "The .LDOS file"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#the-byomegakbloch-file", 
            "text": "This file reports Bloch-vector resolved versions\nof the information reported by the  .LDOS  file.\nThis file is only produced for calculations on\nperiodic geometries.", 
            "title": "The .byOmegakBloch file"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#4-examples-of-calculations-using-scuff-ldos", 
            "text": "LDOS above a dielectric half-space", 
            "title": "4. Examples of calculations using scuff-ldos"
        }, 
        {
            "location": "/applications/scuff-tmatrix/scuff-tmatrix/", 
            "text": "scuff-tmatrix\n\n\nThe documentation for \nscuff-tmatrix\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-tmatrix"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/", 
            "text": "Computing thermal-equilibrium Casimir energies, forces, \n    and torques with \nscuff-cas3d\n\n\n\n\n\nscuff-cas3d\n is a command-line application within the \nscuff-em\n suite\nfor modeling Casimir interactions between compact or extended homogeneous\nbodies of arbitary shape and arbitrary (linear, isotropic, piecewise homogeneous)\nfrequency-dependent permittivity and permeability. \nscuff-cas3d\n implements the \n\nfluctuating-surface current (FSC)\n approach\n\nto numerical Casimir modeling.]\n\n\nscuff-cas3d\n handles \nequilibrium\n Casimir interactions, in which\nall interacting bodies and the external medium in which they are embedded \nexist at the same temperature (which may be absolute zero). If you\nneed to model Casimir interactions between bodies at \ndifferent\n \ntemperatures, the tool you want is \n\nscuff-neq\n.\n(However: if your exterior embedding medium is not at zero \ntemperature, then the \ntotal\n Casimir forces will involve\nboth non-equilibrium contributions computed with \nscuff-neq\n \nand equilibrium contributions (at the temperature of the \nexterior medium) computed with \nscuff-cas3d\n.\n\n\nThe basic flow of a typical \nscuff-cas3d\n run goes something like this:\n\n\n\n\n\n\nYou create a \nscuff-em\n geometry file\n\ndescribing the interacting objects or surfaces in your geometry.\n\n\n\n\n\n\nOptionally, you define a \n\nlist of geometric transformations\n \nto be applied to the geometry for Casimir computations.\nFor example, if your geometry consists of two nanoparticles, you\nmight ask for the Casimir force between the particles at 10 different\nvalues of the surface--surface separation.\n\n\n\n\n\n\nYou run \nscuff-cas3d\n with various\n\ncommand-line options\n specifying the\ndesired output quantities (energy, \ny\n-force, etc.), whether\nyou want frequency-resolved or frequency-summed data, and\nother options. This produces various text-based \n\noutput files\n, which you will typically\nplot using \ngnuplot\n or other \nplotting or post-processing tools.\n\n\n\n\n\n\nTable of Contents\n\n\n1. What scuff-cas3d actually computes\n\n\n1a. Compact objects\n\n\n1b. Extended objects\n\n\n\n\n\n\n2. \nscuff-cas3d\n command-line options\n\n\nCommon options\n\n\nOptions requesting Casimir output quantities\n\n\nOptions specifying temperature\n\n\n\n\n\n\n3. \nscuff-cas3d\n output files\n\n\nThe .log file\n\n\nThe .out file\n\n\nThe .byXi file\n\n\nThe .byXikBloch file\n\n\n\n\n\n\n4. Examples of Casimir calculations using \nscuff-cas3d\n\n\n\n\n\n\n1. What \nscuff-cas3d\n actually computes\n\n\n1a. Compact objects\n\n\nThe Casimir energy \n\\mathcal{E}\n of a collection of compact bodies,\nand the \ni\n-directed Casimir force \n\\mathcal{F}_i\n and \ntorque \n\\mathcal{T}_i\n on one of \nthose bodies, are computed in the FSC approach as integrals \nover the positive imaginary frequency axis\n(\n\\omega=i\\xi\n) of the form\n\n\n\n\n \\begin{array}{ccc}\n   \\mathcal{E}   &=& \\int_0^\\infty E(\\xi) \\, d\\xi \\\\\n   \\mathcal{F}_i &=& \\int_0^\\infty F_i(\\xi) \\, d\\xi \\\\\n   \\mathcal{T}_i &=& \\int_0^\\infty T_i(\\xi) \\, d\\xi \\\\\n   \\end{array}\n\n\n\n\n\n(This is for the zero-temperature case; at a finite temperature\n\nT\n the imaginary-frequency integration is replaced by a \nMatsubara sum according to the prescription\n\n \\int_0^\\infty F(\\xi) \\, d\\xi \n   \\qquad \\Longrightarrow \\qquad\n   (\\Delta \\xi) \\sideset{}{'}{\\sum}_{n=0}^\\infty F(n\\Delta\\xi),\n   \\qquad \\Delta\\xi =\\frac{2\\pi k T}{\\hbar}\n\n\nwhere the primed sum indicates that the \nn=0\n term is \nto be weighted by \n1/2.\n)\n\n\nThe heart of the FSC algorithm implemented by \nscuff-cas3d\n\nis an efficient technique for computing the quantities\n\n\\{E,F_i,T_i\\}(\\xi)\n---that is, the contributions of \nindividual imaginary frequencies to the total Casimir \nquantities---at arbitrary frequencies \n\\xi\n.\nThe question of \nwhich\n frequencies \n\\xi\n are sampled\ndepends on the command-line options you specify:\n\n\n\n\n\n\nIf you use the \n--Xi\n or \n--XiFile\n command-line options to \nspecify one or more particular values of \n\\xi\n, then \nscuff-cas3d\n\nwill compute and report just the integrand \nF(\\xi)\n at those\nvalues. In this case, the code will produce a \n.byXi\n file,\nbut no \n.out\n file.\n\n\n\n\n\n\nIf, instead, you use the \n--temperature\n command-line option to specify \na temperature at which to calculate, then \nscuff-cas3d\n\nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get both a \n.byXi\n and a \n.out\n file; \nthe \n.byXi\n file will report data on the Casimir\nintegrands at the Matsubara frequencies\n\n\\xi_n\\equiv n\\Delta \\xi\n for \nn=0,1,\\cdots\n\n\n\n\n\n\n\n\nIf you don't specify any of the above, then \nscuff-cas3d\n\ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In \nthis case, you will get both a \n.byXi\n and a \n.out\n\nfile; the \n.byXi\n file reports data on the Casimir\nintegrands at the frequencies \n\\{\\xi\\}\n chosen by \nthe built-in integrator.\n\n\n\n\n\n\n1b. Extended objects\n\n\nFor an extended material configuration described by a\n\nperiodic geometry\n\nwith Bloch-periodic boundary conditions, the Casimir force \n\ndensity\n (that is, the force \nper unit length\n for a 1D \nextended geometry, or \nper unit area\n for a 2D extended \ngeometry) is computed in the FSC approach as multi-dimensional \nintegrals over both imaginary frequencies \n\\xi\n and Bloch \nvectors \n\\mathbf{k}\n:\n\n\n\n\n \\mathcal{F}\n   = \n   \\int_0^\\infty d\\xi \\,\n    \\underbrace{\\int_{\\text{BZ}} \n     f(\\xi, \\mathbf{k}) \n     \\, d\\mathbf{k}}_{\\equiv F(\\xi)}\n\n\n\n\n\n(Expressions for the Casimir energy and torque are similar).\nThe Bloch vector \n\\mathbf k\n is a one-component vector\nfor 1D-extended geometries (such as \n\ninfinite-length cylinders or beams\n,\nand a two-component vector\nfor 2D-extended geometries (such as \n\ninfinite-area slabs\n).\nThe \n\\mathbf k\n integral here ranges over the \nBrillouin\nzone\n (BZ)\n\n\nscuff-cas3d\n uses the FSC algorithm to compute\nvalues of the integrand \nf(\\xi, \\mathbf k)\n at \nindividual \n(\\xi, \\mathbf k)\n points.\n\n\nThe FSC algorithm implemented by \nscuff-cas3d\n\nis an efficient technique for computing the quantity\n\n f(\\xi, \\mathbf k)\n---that is, the contributions of\nindividual (imaginary frequency, wavevector) pairs\n\n(\\xi,\\mathbf k)\n---to the total Casimir quantities.\nThe question of \nwhich\n (\n\\xi, \\mathbf k)\n points are \nsampled depends on the command-line options you specify:\n\n\n\n\n\n\nIf you use the \n--XikBlochFile\n command-line option\nto specify a list of \n(\\xi, \\mathbf k)\n points, then \n\nscuff-cas3d\n will compute and report just the \nintegrand \nf(\\xi, \\mathbf k)\n at those values. \nIn this case, the code will produce a \n.byXikBloch\n file,\nbut no other output files.\n\n\n\n\n\n\nIf you use the \n--Xi\n or \n--XiFile\n command-line options to\nspecify one or more particular values of \n\\xi\n (but not\nspecific values of \n\\mathbf k\n), then \nscuff-cas3d\n will\nnumerically evaluate the Brillouin-zone integral over \n\n\\mathbf k\n and will report the resulting value of the \nquantity \nF(\\xi)\n at each \n\\xi\n value. \nIn this case, the code will produce two output files\n\n(1)\n a \n.byXi\n file reporting values of \nF(\\xi)\n at the \n\n\\xi\n points you specified, and \n(2)\n a \n.byXikBloch\n\nfile reporting values of the \n\\mathbf k\n integrand \nf(\\xi, \\mathbf k)\n\nat each of the \n\\mathbf k\n points sampled by the \nbuilt-in integrator.\n\n\n\n\n\n\nIf you use the \n--temperature\n command-line option to specify\na temperature at which to calculate, then \nscuff-cas3d\n\nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get three output files: \n\n(1)\n a \n.out\n file reporting the full Matsubara-summed\nCasimir quantities,\n\n(2)\n a \n.byXi\n file reporting values of the function\n\nF(\\xi)\n at each Matsubara frequency; and \n\n(3)\n a \n.byXikBloch\n\nfile reporting values of the \n\\mathbf k\n integrand \nf(\\xi, \\mathbf k)\n\nat each point sampled by the built-in integrator.\n\n\n\n\n\n\nIf you don't specify any of the above, then \nscuff-cas3d\n\ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In\nthis case, you will get the same three output files\nas in the case of the previous item (\n.out\n, \n.byXi\n, \n.byXikBloch\n);\nthe only difference is that the \n\\xi\n points reported\nin the \n.byXi\n and \n.byXikBloch\n files are the quadrature \npoints chosen by the built-in integrator instead of the \nMatsubara frequencies.\n\n\n\n\n\n\n\n\n2. \nscuff-cas3d\n command-line options\n\n\nCommon options\n\n\nscuff-cas3d\n recognizes the following subset of the \n[list of commonly accepted options to \nscuff-em\n command-line codes][CommonOptions].\n\n\n--geometry\n--TransFile\n--Xi\n--XiFile\n--XikBlochFile\n--XiQuadrature\n--XiMin\n--BZQuadrature\n--BZSymmetry\n--MaxBZSamples\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache\n\n\nOptions requesting Casimir output quantities\n\n\n--Energy\n--XForce\n--YForce\n--ZForce\n--Torque ax ay az\n\n\nSpecifies the Casimir quantities in which you are\ninterested: the energy, the Cartesian components\nof the force, or the torque about an axis\npassing through the origin and the point with \nCartesian coordinates \n(ax,ay,az).\n (Thus, for\n\n\nYou may specify more than one of these options,\nbut you must specify at least one.\n\n\nNote\n: \nscuff-cas3d\n always computes the force and torque\non just \none\n of the objects or surfaces in your geometry---namely,\nthe one described by the first \nOBJECT\n or \nSURFACE\n \nspecification in your \n.scuffgeo\n file. For geometries\nconsisting of just two objects or surfaces, the force/torque\non the second object/surface is just the negative of the \nforce/torque on the first. \n\n\nOptions specifying temperature\n\n\n--Temperature 300\n\n\nSets the simulation temperature \nin units of Kelvin,\n\nso that \n--temperature 300\n requests room-temperature calculations.\nThis option implies that you are asking \nscuff-cas3d\n\nto compute full Matsubara-summed Casimir quantities, so it is\nincompatible with options such as \n--Xi\n or \n--XiFile\n that\nspecify particular frequencies at which to compute.\n\n\n\n\n3. \nscuff-cas3d\n output files\n\n\nThe base file name of all output files produced by\n\nscuff-cas3d\n may be specified using the \n--FileBase\n\ncommand-line option; if this option is not specified\nthen the file base is taken to be the base file\nname of the \n.scuffgeo\n file you specified using\nthe \n--geometry\n option.\n\n\nFor all data output files (\n.out\n, \n.byXi\n,\n\n.byXikBloch\n), the output file contains a\n\nheader\n (a sequence of text lines starting with\n#\n)\nexplaining how to interpret the contents of the file.\n\n\nThe \n.log\n file\n\n\nLike all command-line codes in the \nscuff-em\n suite,\n\nscuff-cas3d\n writes a \n.log\n file\n that you \ncan monitor to keep track of your calculation's progress.\n\n\nThe \n.out\n file\n\n\nIf you requested the calculation of\nfull frequency-integrated or Matsubara-summed\nCasimir quantities, these will be written to \nthe \n.out\n file.\n\n\nThe \n.byXi\n file\n\n\nFor any problem involving compact geometries,\nand for any problem involving extended geometries\nin which you requested Brillouin-zone integrations,\nthe contributions of individual imaginary frequencies \n\n\\xi\n will be written to a file named \n.byXi\n.\n\n\nThe \n.byXikBloch\n file\n\n\nFor any problem involving extended geometries,\nthe contributions of individual (frequency, Bloch vector)\npoints \n(\\xi,\\mathbf k)\n will be written to a file\nnamed \nFILEBASE.byXikBloch\n.\n\n\n\n\n4. Examples of Casimir calculations using \nscuff-cas3d\n\n\n\n\n\n\nCasimir forces in a compact geometry:\n  \nA cube and a torus immersed in ethanol\n\n\n\n\n\n\nCasimir forces in a 1D extended geometry: \n  \ninfinite-length silicon beams\n\n\n\n\n\n\nCasimir forces in a 2D extended geometry: \n  \ninfinite-area silicon slabs", 
            "title": "scuff-cas3D"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#1a-compact-objects", 
            "text": "The Casimir energy  \\mathcal{E}  of a collection of compact bodies,\nand the  i -directed Casimir force  \\mathcal{F}_i  and \ntorque  \\mathcal{T}_i  on one of \nthose bodies, are computed in the FSC approach as integrals \nover the positive imaginary frequency axis\n( \\omega=i\\xi ) of the form    \\begin{array}{ccc}\n   \\mathcal{E}   &=& \\int_0^\\infty E(\\xi) \\, d\\xi \\\\\n   \\mathcal{F}_i &=& \\int_0^\\infty F_i(\\xi) \\, d\\xi \\\\\n   \\mathcal{T}_i &=& \\int_0^\\infty T_i(\\xi) \\, d\\xi \\\\\n   \\end{array}   (This is for the zero-temperature case; at a finite temperature T  the imaginary-frequency integration is replaced by a \nMatsubara sum according to the prescription  \\int_0^\\infty F(\\xi) \\, d\\xi \n   \\qquad \\Longrightarrow \\qquad\n   (\\Delta \\xi) \\sideset{}{'}{\\sum}_{n=0}^\\infty F(n\\Delta\\xi),\n   \\qquad \\Delta\\xi =\\frac{2\\pi k T}{\\hbar} \nwhere the primed sum indicates that the  n=0  term is \nto be weighted by  1/2. )  The heart of the FSC algorithm implemented by  scuff-cas3d \nis an efficient technique for computing the quantities \\{E,F_i,T_i\\}(\\xi) ---that is, the contributions of \nindividual imaginary frequencies to the total Casimir \nquantities---at arbitrary frequencies  \\xi .\nThe question of  which  frequencies  \\xi  are sampled\ndepends on the command-line options you specify:    If you use the  --Xi  or  --XiFile  command-line options to \nspecify one or more particular values of  \\xi , then  scuff-cas3d \nwill compute and report just the integrand  F(\\xi)  at those\nvalues. In this case, the code will produce a  .byXi  file,\nbut no  .out  file.    If, instead, you use the  --temperature  command-line option to specify \na temperature at which to calculate, then  scuff-cas3d \nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get both a  .byXi  and a  .out  file; \nthe  .byXi  file will report data on the Casimir\nintegrands at the Matsubara frequencies \\xi_n\\equiv n\\Delta \\xi  for  n=0,1,\\cdots     If you don't specify any of the above, then  scuff-cas3d \ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In \nthis case, you will get both a  .byXi  and a  .out \nfile; the  .byXi  file reports data on the Casimir\nintegrands at the frequencies  \\{\\xi\\}  chosen by \nthe built-in integrator.", 
            "title": "1a. Compact objects"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#1b-extended-objects", 
            "text": "For an extended material configuration described by a periodic geometry \nwith Bloch-periodic boundary conditions, the Casimir force  density  (that is, the force  per unit length  for a 1D \nextended geometry, or  per unit area  for a 2D extended \ngeometry) is computed in the FSC approach as multi-dimensional \nintegrals over both imaginary frequencies  \\xi  and Bloch \nvectors  \\mathbf{k} :    \\mathcal{F}\n   = \n   \\int_0^\\infty d\\xi \\,\n    \\underbrace{\\int_{\\text{BZ}} \n     f(\\xi, \\mathbf{k}) \n     \\, d\\mathbf{k}}_{\\equiv F(\\xi)}   (Expressions for the Casimir energy and torque are similar).\nThe Bloch vector  \\mathbf k  is a one-component vector\nfor 1D-extended geometries (such as  infinite-length cylinders or beams ,\nand a two-component vector\nfor 2D-extended geometries (such as  infinite-area slabs ).\nThe  \\mathbf k  integral here ranges over the  Brillouin\nzone  (BZ)  scuff-cas3d  uses the FSC algorithm to compute\nvalues of the integrand  f(\\xi, \\mathbf k)  at \nindividual  (\\xi, \\mathbf k)  points.  The FSC algorithm implemented by  scuff-cas3d \nis an efficient technique for computing the quantity  f(\\xi, \\mathbf k) ---that is, the contributions of\nindividual (imaginary frequency, wavevector) pairs (\\xi,\\mathbf k) ---to the total Casimir quantities.\nThe question of  which  ( \\xi, \\mathbf k)  points are \nsampled depends on the command-line options you specify:    If you use the  --XikBlochFile  command-line option\nto specify a list of  (\\xi, \\mathbf k)  points, then  scuff-cas3d  will compute and report just the \nintegrand  f(\\xi, \\mathbf k)  at those values. \nIn this case, the code will produce a  .byXikBloch  file,\nbut no other output files.    If you use the  --Xi  or  --XiFile  command-line options to\nspecify one or more particular values of  \\xi  (but not\nspecific values of  \\mathbf k ), then  scuff-cas3d  will\nnumerically evaluate the Brillouin-zone integral over  \\mathbf k  and will report the resulting value of the \nquantity  F(\\xi)  at each  \\xi  value. \nIn this case, the code will produce two output files (1)  a  .byXi  file reporting values of  F(\\xi)  at the  \\xi  points you specified, and  (2)  a  .byXikBloch \nfile reporting values of the  \\mathbf k  integrand  f(\\xi, \\mathbf k) \nat each of the  \\mathbf k  points sampled by the \nbuilt-in integrator.    If you use the  --temperature  command-line option to specify\na temperature at which to calculate, then  scuff-cas3d \nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get three output files:  (1)  a  .out  file reporting the full Matsubara-summed\nCasimir quantities, (2)  a  .byXi  file reporting values of the function F(\\xi)  at each Matsubara frequency; and  (3)  a  .byXikBloch \nfile reporting values of the  \\mathbf k  integrand  f(\\xi, \\mathbf k) \nat each point sampled by the built-in integrator.    If you don't specify any of the above, then  scuff-cas3d \ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In\nthis case, you will get the same three output files\nas in the case of the previous item ( .out ,  .byXi ,  .byXikBloch );\nthe only difference is that the  \\xi  points reported\nin the  .byXi  and  .byXikBloch  files are the quadrature \npoints chosen by the built-in integrator instead of the \nMatsubara frequencies.", 
            "title": "1b. Extended objects"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#2-scuff-cas3d-command-line-options", 
            "text": "", 
            "title": "2. scuff-cas3d command-line options"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#common-options", 
            "text": "scuff-cas3d  recognizes the following subset of the \n[list of commonly accepted options to  scuff-em  command-line codes][CommonOptions].  --geometry\n--TransFile\n--Xi\n--XiFile\n--XikBlochFile\n--XiQuadrature\n--XiMin\n--BZQuadrature\n--BZSymmetry\n--MaxBZSamples\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache", 
            "title": "Common options"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#options-requesting-casimir-output-quantities", 
            "text": "--Energy\n--XForce\n--YForce\n--ZForce\n--Torque ax ay az  Specifies the Casimir quantities in which you are\ninterested: the energy, the Cartesian components\nof the force, or the torque about an axis\npassing through the origin and the point with \nCartesian coordinates  (ax,ay,az).  (Thus, for  You may specify more than one of these options,\nbut you must specify at least one.  Note :  scuff-cas3d  always computes the force and torque\non just  one  of the objects or surfaces in your geometry---namely,\nthe one described by the first  OBJECT  or  SURFACE  \nspecification in your  .scuffgeo  file. For geometries\nconsisting of just two objects or surfaces, the force/torque\non the second object/surface is just the negative of the \nforce/torque on the first.", 
            "title": "Options requesting Casimir output quantities"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#options-specifying-temperature", 
            "text": "--Temperature 300  Sets the simulation temperature  in units of Kelvin, \nso that  --temperature 300  requests room-temperature calculations.\nThis option implies that you are asking  scuff-cas3d \nto compute full Matsubara-summed Casimir quantities, so it is\nincompatible with options such as  --Xi  or  --XiFile  that\nspecify particular frequencies at which to compute.", 
            "title": "Options specifying temperature"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#3-scuff-cas3d-output-files", 
            "text": "The base file name of all output files produced by scuff-cas3d  may be specified using the  --FileBase \ncommand-line option; if this option is not specified\nthen the file base is taken to be the base file\nname of the  .scuffgeo  file you specified using\nthe  --geometry  option.  For all data output files ( .out ,  .byXi , .byXikBloch ), the output file contains a header  (a sequence of text lines starting with # )\nexplaining how to interpret the contents of the file.", 
            "title": "3. scuff-cas3d output files"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#the-log-file", 
            "text": "Like all command-line codes in the  scuff-em  suite, scuff-cas3d  writes a  .log  file  that you \ncan monitor to keep track of your calculation's progress.", 
            "title": "The .log file"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#the-out-file", 
            "text": "If you requested the calculation of\nfull frequency-integrated or Matsubara-summed\nCasimir quantities, these will be written to \nthe  .out  file.", 
            "title": "The .out file"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#the-byxi-file", 
            "text": "For any problem involving compact geometries,\nand for any problem involving extended geometries\nin which you requested Brillouin-zone integrations,\nthe contributions of individual imaginary frequencies  \\xi  will be written to a file named  .byXi .", 
            "title": "The .byXi file"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#the-byxikbloch-file", 
            "text": "For any problem involving extended geometries,\nthe contributions of individual (frequency, Bloch vector)\npoints  (\\xi,\\mathbf k)  will be written to a file\nnamed  FILEBASE.byXikBloch .", 
            "title": "The .byXikBloch file"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#4-examples-of-casimir-calculations-using-scuff-cas3d", 
            "text": "Casimir forces in a compact geometry:\n   A cube and a torus immersed in ethanol    Casimir forces in a 1D extended geometry: \n   infinite-length silicon beams    Casimir forces in a 2D extended geometry: \n   infinite-area silicon slabs", 
            "title": "4. Examples of Casimir calculations using scuff-cas3d"
        }, 
        {
            "location": "/applications/scuff-caspol/scuff-caspol/", 
            "text": "scuff-caspol\n\n\nThe documentation for \nscuff-caspol\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-caspol"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/", 
            "text": "Modeling non-equilibrium electromagnetic fluctuations with\n     \nscuff-neq\n\n\n\n\n\nscuff-neq\n is an application code in the \nscuff-em\n suite for \nstudying non-equilibrium (NEQ) electromagnetic-fluctuation-induced \nphenomena--specifically, for computing \nradiative heat-transfer rates\n \nand \nnon-equilibrium Casimir forces and torques\n for bodies of \narbitrary shapes and arbitrary (linear, isotropic, piecewise \nhomogeneous) frequency-dependent permittivity and permeability.\n\nscuff-neq\n implements the \n\nfluctuating-surface current (FSC)\n approach\n \nto numerical modeling of non-equilibrium fluctuation phenomena.\n\n\nMechanically, working with \nscuff-neq\n is similar in many ways to \nworking with the equilibrium Casimir code \nscuff-cas3d\n. \nIn particular,\n\n\n\n\n\n\nAs in \nscuff-cas3d\n, you can request either \n(a)\n frequency-resolved \ninformation on heat-transfer rates and NEQ Casimir forces (in which case \nyou will specify a list of frequencies and will get back a list of \nfrequency-specific values of energy and momentum fluxes) or \n\n(b)\n frequency-integrated information, in which case you will assign \ntemperatures to each body in your geometry and \nscuff-neq\n will \nnumerically integrate the fluxes, weighted by appropriate Bose-Einstein \nfactors, to obtain the total heat-transfer rate or NEQ Casimir force. \n(For more details, see \n\nWhat \nscuff-neq\n actually computes\n.)\n\n\n\n\n\n\nAs in \nscuff-cas3d\n, you can specify an optional list of \n\ngeometrical transformations\n \ndescribing various displacements and rotations of the bodies \nin your geometry; in this case you will get back values of the \nfrequency-resolved or frequency-integrated quantities for each \ntransformation you specify.\n\n\n\n\n\n\nA bonus feature of \nscuff-neq\n that is \nnot\n present in \n\nscuff-cas3d\n is the ability to obtain spatially-resolved \ninformation on energy and momentum fluxes. More specifically, \nyou can specify to \nscuff-neq\n a \n\nlist of evaluation points\n\nand you will get back values of the (thermally and \ntemporally averaged) Poynting flux and Maxwell stress tensor \nat each point you requested.\n\n\nIn addition to numerical output on heat-transfer rates and\nCasimir quantities, you can also request visualization outputs\nthat plot the spatial distribution of the heat or momentum flux.\n\n\nFor Casimir forces and torques, the quantities computed by \n\nscuff-neq\n are only the \nnon-equilibrium\n contributions to \nthe total force and torque---that\nis, the contributions arising from the temperature \ndifferences between individual bodies and the surrounding environment.\nTo get the total force, these must be added to the \nequilibrium\n\ncontributions, which are the Casimir forces and torques for the \ncase in which all bodies are at the temperature of the environment.\nThese contributions must be computed by doing a separate \n\nscuff-cas3d\n calculation, on the same geometry, at the \ntemperature of the external medium. \n(For heat-transfer rates there is of course no equilibrium \ncontribution, as there is no net power transfer between \nbodies at thermal equilibrium.)\n\n\nOne difference between \nscuff-cas3d\n and \nscuff-neq\n is that,\nwhereas \nscuff-cas3d\n reports only the Casimir force on one body in \na geometry (namely, the first body listed in the \n.scuffgeo\n file), \n\nscuff-neq\n reports forces and heat-transfer rates for \nall\n bodies\nin the geometry. \n[\nThe extra information would typically \nbe redundant in an equilibrium Casimir calculation, since the equilibrium \nCasimir force on the second body (in a two-body geometry) is just equal\nand opposite to the force on the first body; but in general no such \nrelation holds in the non-equilibrium case.\n]\n\n\nIn fact, the output from \nscuff-neq\n is even more detailed\nthan that: in addition to the total power/force/torque on\neach body, you also get the contributions of each individual\nsource body to those quantities. All of this means that the\noutput from \nscuff-neq\n requires some effort to interpret,\nas discussed in more detail below.\n\n\nTable of Contents\n\n\n1. What \nscuff-neq\n actually computes\n\n\n2. \nscuff-neq\n command-line options\n\n\nCommon options\n\n\nOptions specifying input fields\n\n\nOptions requesting output quantities\n\n\nOption requesting visualization output\n\n\nOptions specifying object temperatures\n\n\nOptions controlling the computation of power, force, and torque\n\n\nOther options\n\n\n\n\n\n\n3. \nscuff-neq\n output files\n\n\nThe .log file\n\n\nOutput files for spatially-integrated PFTs: The .SIFlux, .SIIntegrand, and .NEQPFT files\n\n\nOutput files for spatially-resolved PFTs: The .SRFlux, .SRIntegrand, and .PVMST files\n\n\nUnits of output quantities\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-neq\n\n\n\n\n\n\n1. What \nscuff-neq\n actually computes\n\n\nscuff-neq\n implements the\n\nFSC approach to non-equilibrium fluctuation phenomena\n,\nan algorithm for computing the thermal averages of power,\nforce, and torque (PFT) quantities in geometries consisting\nof homogeneous material bodies at various temperatures embedded\nin an finite-temperature or zero-temperature environment.\n\nscuff-neq\n can compute both\nspatially-\nresolved\n and spatially-\nintegrated\n PFT quantities.\n(Examples of spatially-resolved quantities include components\nof the average Poynting flux or Maxwell stress tensor at individual\npoints in space. Examples of spatially-integrated quantities \ninclude the total power absorbed by, or the total force or torque \non, a compact homogeneous body. Spatially-integrated quantities \nare generally obtained by integrating spatially-resolved quantities\nover closed bounding surfaces, although this is not necessarily\nthe way they are computed by \nscuff-neq\n.)\n\n\nIn general, for a geometry consisting of multiple homogeneous\nmaterial regions, PFT quantities receive contributions from source\nfluctuations in all regions and at all frequencies, and the\nthe thermal average of a PFT quantity \nQ\n may be\nwritten in the form\n\n\n\n\n \\big\\langle Q\\big\\rangle\n    = \\int_0^\\infty \\, \\sum_r \\, \\Theta(T_r,\\omega) \\Phi_r(\\omega)\\,d\\omega\n\n\nwhere \nT_r\n is the temperature of region \nr\n, \n\\Phi_r(\\omega)\n is\na temperature-independent \ngeneralized flux\n describing the \ncontribution of frequency-\n\\omega\n source fluctuations in region \nr\n,\nand \n\n\\Theta(T_r,\\omega) = \\frac{\\hbar\\omega}{e^{\\hbar \\omega/kT_r} - 1}\n\nis the Bose-Einstein factor.\n\n\nThe sum over regions \nr\n in this equation includes the\ncontributions of the external environment. To isolate these\ncontributions it is convenient to decompose \n\\langle Q \\rangle\n\ninto a sum of two terms:\n\n \\begin{array}{rcl}\n \\big\\langle Q\\big\\rangle\n&=&\n \\big\\langle Q\\big\\rangle^{\\small EQ} + \n   \\big\\langle Q\\big\\rangle^{\\small NEQ}\n\\\\[8pt]\n \\big\\langle Q\\big\\rangle^{\\small EQ}\n&\\equiv&\n  \\displaystyle{\\int_0^\\infty} \\Theta(T_{\\small env},\\omega) \n                \\sum_r \\, \\Phi_r(\\omega)\\,d\\omega \n\\\\[8pt]\n \\qquad \\big\\langle Q\\big\\rangle^{\\small NEQ} \n&\\equiv& \n  \\displaystyle{\\int_0^\\infty \\sum_s }\n  \\Big[ \\Theta(T_s, \\omega) - \\Theta(T_{\\small env},\\omega)\\Big]\n        \\Phi_s(\\omega)\\,d\\omega \n\\\\[4pt]\n&=&\n  \\displaystyle{\\int_0^\\infty \\sum_s}\n  \\Delta \\Theta(T_s, \\omega) \\Phi_s(\\omega)\\,d\\omega \n\\end{array}\n\n\n\n\n\nwhere \n\n\n\n\n \\Delta \\Theta(T_s, \\omega) \\equiv \n   \\Theta(T_s, \\omega) - \\Theta(T_{\\small env},\\omega).\n\n\n\n\n\nThe quantity \n\\langle Q\\rangle^{\\small EQ}\n\nis the average value of \nQ\n that would obtain if \nthe temperature in all material regions were equal\nto the environment temperature \nT_{\\small env}\n---that is,\nit is the \nequilibrium\n value of \n\\langle Q\\rangle\n\nat temperature \nT_{\\small env}\n. The equilibrium value\nof PFT quantities may be computed by methods that are \nless costly than \nscuff-neq\n. (For example,\nif \nQ\n is a spatially-integrated force or torque, then \n\n\\langle Q\\rangle^{\\small EQ}\n is just the equilibrium\nCasimir force, which is computed efficiently by \n\nscuff-cas3d\n.\nOn the other hand, if \nQ\n is a spatially-integrated\npower transfer quantity, then \n\n\\langle Q\\rangle^{\\small EQ}=0\n identically.)\nThus this contribution is not computed by \nscuff-neq\n.\n\n\nThe quantity \n\\langle Q\\rangle^{\\small NEQ}\n\nis the extent to which \n\\langle Q\\rangle\n\n\ndeviates\n from its equilibrium value, and\nthe sum in its definition ranges only over \nthe source bodies in the geometry, not including\nthe environment contribution.\n\n\\langle Q \\rangle^{\\small NEQ}\n is the\nquantity that is computed by \nscuff-neq\n.\n\n\n\n\n2. \nscuff-neq\n command-line options\n\n\nCommon options\n\n\nscuff-neq\n recognizes the following subset of the \n\nlist of commonly accepted options to \nscuff-em\n command-line codes\n.\n\n\n--geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache\n\n\nOptions specifying input fields\n\n\nscuff-scatter\n recognizes the following options specifying\nvarious types of incident fields. You may specify more than\none type of incident field, in which case your geometry will\nbe illuminated by the simultaneous superposition of all the \nfields you specify.\n\n\nFor more details on how to use the following options \nand the precise mathematical expressions for the fields\nthey describe,\nsee [Incident fields in \nscuff-em\n][IncidentFields].\n\n\nThese options are \n\n\nOptions requesting output quantities\n\n\n--PAbs  \n--PRad  \n--XForce  \n--YForce  \n--ZForce\n--XTorque  \n--YTorque\n--ZTorque\n\n\nSpecifies the quantities in which you are interested:\nabsorbed power (\n--PAbs\n), radiated power (\n--PRad\n),\nCartesian force components, or Cartesian torque components.\nYou may specify none, all, or any subset of these options,\nbut each option you specify will generally increase\nthe computation time (you can scrutinize the\n\n.log\n file\n to see how \nmuch\n additional time each\nextra output quantity takes to compute).\n\n\nOption requesting visualization output\n\n\n--PlotFlux\n\n\nThis option directs \nscuff-neq\n to produce visualization\nfiles (in addition to its usual output files) which may be \nopened in \ngmsh\n to visualize,\nfor each spatially-integrated PFT quantity you requested,\nthe spatial distribution of the Poynting flux or \nMaxwell stress on the surfaces of objects or \nthe displaced bounding surfaces over which those quantities\nare integrated to compute the total PFT quantity.\n\n\nOptions specifying object temperatures\n\n\n--Temperature UpperSphere 300\n--Temperature LowerSphere 100\n--Temperature ENVIRONMENT 100\n\n\n\n\nThe first two options here set the temperatures\nof the objects labeled \nUpperSphere\n and\n\nLowerSphere\n in the \n.scuffgeo\n file.\n\nTemperature specifications are interpreted in \nunits of Kelvin\n, so \n300\n corresponds to \nroom temperature.\n\n\nThe third option here sets the temperature of\nthe environment in which the objects are embedded.\n(The keywords \nMEDIUM\n and \nEXTERIOR\n may be used\nhere interchangeably with \nENVIRONMENT\n).\n\n\nNote that the temperatures of all objects, and of\nthe environment, are zero by default. This means that,\nif you request a full frequency-integrated calculation\n(which you do by omitting the \n--omega\n or \n--omegaFile\n\noption) and you do not specify any \n--temperature\n \noptions, the code will chug for a while (computing \ntemperature-independent fluxes at various frequencies)\nbefore reporting strictly zero values for all\nquantities! This is probably not what you want.\n\n\n\n\nOptions controlling the computation of power, force, and torque\n\n\n--ForceDSI\n\n\n--DSIPoints 302\n--DSIRadius 5.0\n--DSIMesh BoundingMesh.msh\n--DSIFarField\n\n\nAs detailed in \nthis paper\n, there are several\nways to compute PFTs in surface-integral formulations,\nincluding the \"displaced-surface-integral\" (DSIPFT),\n\"equivalence principle\" (EPPFT), and \"overlap\" (OPFT) \nmethods.\n\n\nBy default, \nscuff-neq\n uses different algorithms for \ndifferent cases of the PFT computation:\n\n\n\n\nPower computation (self term): EPPFT\n\n\nPower computation (non-self terms): EPPFT\n\n\nForce/Torque computation (self term): DSIPFT\n\n\nForce/Torque computation (non-self term): OPFT\n\n\n\n\nHowever, you can override this default behavior \nby specifying \n--ForceDSI\n, in which case DSIPFT\nwill be used in all cases.\n\n\nThe other options here set specific parameters \nthat are only used for DSIPFT calculations.\n\n\n--DSIMesh\n specifies the name of a mesh file\n(such as a \nGMSH\n-produced \n.msh\n file) that \ndefines the bounding surface over which the \nsurface integrals are computed. (This surface is\nautomatically displaced and rotated appropriately\nfor each object in accordance with any\ngeometrical transformations that may be \nspecified in the \n.scuffgeo\n file and/or the\n\n.trans\n file.) The surface integral is evaluated\nvia a one-point cubature over the surface of \neach panel in the bounding mesh; thus, the\nfiner the bounding mesh, the more accurate and\nthe more expensive the computation).\n\n\nIf you do not specify a \n--DSIMesh\n, then the\nsurface integral for each object is computed \nusing Lebedev cubature over a bounding sphere \ncentered at the origin of coordinates of the \nobject mesh (appropriately displaced if the \nobject has been displaced via statements in \nthe \n.scuffgeo\n or \n.trans\n files.) In this case,\nyou may use \n--DSIRadius\n and \n--DSIPoints\n to\nset the radius of this sphere (in microns) and \nthe number of Lebedev cubature points (the more \npoints, the more accurate and expensive the calculation).\nTo see the possible values that may be specified \nfor \n--DSIPoints,\n type \nscuff-neq --help.\n\n\nFinally, you may use \n--DSIFarField\n to request\nthat the Poynting vector and Maxwell tensor\non the bounding surface be computed using only\nthe far-field (radiation-zone) contributions \nof the surface currents to the fields.\n\n\nOther options\n\n\n--OmitSelfTerms\n\n\nOmit the contributions of sources in individual bodies\nto the total PFTs on those bodies themselves.\n\n\n\n\n3. \nscuff-neq\n output files\n\n\n\n\nThe \n.log\n file\n\n\nLike all command-line codes in the \nscuff-em\n suite,\n\nscuff-cas3d\n writes a \n.log\n file\n that you\ncan monitor to keep track of your calculation's progress.\n\n\nOutput files for spatially-integrated PFTs: The \n.SIFlux\n, \n.SIIntegrand\n, and \n.NEQPFT\n files\n\n\nIf you requested the computation of any spatially-integrated\nPFTs (by setting command-line options such as \n--PAbs\n or \n--YForce\n),\nyou will get back files reporting various contributions to \nthese quantities.\nTo understand what is written to these files, let \nQ_d\n be\nthe spatially-integrated PFT on a destination body \nd\n,\nand write the FSC decomposition of the thermal average\nof \nQ_d\n in the form\n\n\n\n\n \\big\\langle Q_d\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to d}(u)}_{\\texttt{.SIFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SIIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.NEQPFT}}\n\n\n\n\n\nIn this equation,\n\n\n\n\n\n\n\n\nu\n is a dimensionless frequency variable: \nu=\\omega/\\omega_0\n, \nwhere \n\\omega_0=3\\cdot 10^{14}\n rad/sec. (Thus \nu\n agrees numerically\nwith the arguments to the \n--omega\n option.)\n\n\n\n\n\n\n\n\n\\widehat\\Theta(u)\n is a dimensionless version of the usual\nBose-Einstein factor, defined by \n\\Theta(\\omega)=\\hbar \\omega_0 \\widehat\\Theta(u)\n.\n\n\n\n\n\n\n\n\n\\Delta \\widehat \\Theta_s(u)=\\widehat \\Theta_s(u) - \\widehat \\Theta_{\\small env}(u)\n \nis the difference between the dimensionless Bose-Einstein factors of source body \ns\n \nand the environment.\n\n\n\n\n\n\n\n\n\\Phi_{s\\to d}\n is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body \ns\n\nto the power, force, or torque on destination body \nd\n.\nValues of this quantity are written to the \n.SIFlux\n output\nfile.\n\n\n\n\n\n\n\n\n\\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to d}(u)\n is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body \ns\n to the PFT on destination\nbody \nd\n. \nValues of this quantity are written to the \n.SIIntegrand\n output\nfile.\n\n\n\n\n\n\nFinally, \n\\langle Q_d \\rangle\n is the total thermally-averaged\nPFT on body \nd\n. Values of this quantity are written to the \n\n.NEQPFT\n output file.\n\n\n\n\n\n\nIn all of these files, each single line corresponds to\na single frequency, a single geometric transformation,\nand a single pair of (source,destination) objects.\n\n\nAt the top of each output file you will find a file header\nexplaining the significance of each of the various\ncolumns in the file. One of the columns will be\ndescribed in the header as \n# (source object, dest object),\n\nand will take values like \n12\n, \n22\n, or \n02.\n\nThe first case (\n12\n) indicates that the data on that\nline correspond to the contributions of object 1 to the \nPFT on object 2. (The ordering of objects corresponds\nwith the order of their appearance in the \n.scuffgeo\n\nfile).  The second case (\n22\n) indicate that the data\non that line correspond to the self-contributions of \nobject 2 to its own PFT. The third case (\n02\n) \nindicates that the data on that line correspond to \nthe \ntotal\n PFT on object 2---that is, the sum of \ncontributions from all source objects.\n\n\nOutput files for spatially-resolved PFTs: The \n.SRFlux\n, \n.SRIntegrand\n, and \n.PVMST\n files\n\n\nIf you requested the computation of spatially-resolved\npower and momentum flux (by specifying the \n--EPFile\n \ncommand-line option), you will get back files reporting \nvarious contributions to these quantities. The breakdown\nhere is similar to that described above for spatially-integrated\nquantities. To understand this, let \nQ(\\mathbf{x})\n be\na spatially-resolved PFT quantity (a component \nof the Poynting vector or Maxwell stress tensor)\nat a point \n\\mathbf{x}\n. Then the thermal average of \nQ\n \nmay be written in the form\n\n\n\n\n \\big\\langle Q(\\mathbf{x})\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to\\mathbf x}(u)}_{\\texttt{.SRFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SRIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.PVMST}}\n\n\n\n\n\nIn this equation,\n\n\n\n\n\n\n\n\n\\Phi_{s\\to \\mathbf{x}}\n is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body \ns\n\nto the Poynting flux or Maxwell stress at \n\\mathbf{x}\n.\nValues of this quantity are written to the \n.SRFlux\n output\nfile.\n\n\n\n\n\n\n\n\n\\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to \\mathbf{x}}(u)\n is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body \ns\n to the Poynting flux or \nMaxwell stress at \n\\mathbf{x}\n. Values of this quantity are \nwritten to the \n.SRIntegrand\n output\nfile.\n\n\n\n\n\n\nFinally, \n\\langle Q(\\mathbf{x})\\rangle\n is the total thermally-averaged\nPoynting vector or Maxwell stress tensor at \n\\mathbf{x}\n.\nValues of this quantity are written to the \n.PVMST\n output file.\n\n\n\n\n\n\nIn all of these files, each line corresponds to\na single frequency, a single geometric transformation,\nand a single source object.\nAt the top of each output file you will find a file header\nexplaining how to interpret the various data columns\non each line.\n\n\nUnits of output quantities\n\n\n\n\n\n\nThe units of the total (frequency-integrated)\nspatially-integrated output quantities reported in\nthe \n.NEQPFT\n file are \nwatts\n for power, \nnanoNewtons\n\nfor force, and \nnanoNewtons \n\\times\n microns\n for torque.\n\n\n\n\n\n\nThe quantities in the \n.SIIntegrand\n output file\nare the PFT quantities per unit \ndimensionless\n frequency,\nso have the same units as the corresponding quantities\nin the \n.NEQPFT\n file.\n\n\n\n\n\n\nThe quantities in the \n.SIFlux\n output file are\nthe quantities per unit dimensionless frequency\nper watt of thermal energy, so these quantities\nhave the same units as the quantities in \nthe \n.NEQPFT\n and \n.SIIntegrand\n file, but divided\nby watts: thus the power flux is \ndimensionless\n,\nthe force flux has units of \nnanoNewtons / watts\n,\nand the torque flux has units of \nnanoNewtons microns/watts.\n\n\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-neq\n\n\n\n\n\n\nHeat radiation from a warm sphere in a cold environment\n\n\n\n\n\n\nHeat transfer and non-equilibrium Casimir forces between warm and cold spheres\n\n\n\n\n\n\nSpatial distribution of poynting flux from a warm tip above a cold substrate", 
            "title": "scuff-neq"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#2-scuff-neq-command-line-options", 
            "text": "", 
            "title": "2. scuff-neq command-line options"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#common-options", 
            "text": "scuff-neq  recognizes the following subset of the  list of commonly accepted options to  scuff-em  command-line codes .  --geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache", 
            "title": "Common options"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#options-specifying-input-fields", 
            "text": "scuff-scatter  recognizes the following options specifying\nvarious types of incident fields. You may specify more than\none type of incident field, in which case your geometry will\nbe illuminated by the simultaneous superposition of all the \nfields you specify.  For more details on how to use the following options \nand the precise mathematical expressions for the fields\nthey describe,\nsee [Incident fields in  scuff-em ][IncidentFields].  These options are", 
            "title": "Options specifying input fields"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#options-requesting-output-quantities", 
            "text": "--PAbs  \n--PRad  \n--XForce  \n--YForce  \n--ZForce\n--XTorque  \n--YTorque\n--ZTorque  Specifies the quantities in which you are interested:\nabsorbed power ( --PAbs ), radiated power ( --PRad ),\nCartesian force components, or Cartesian torque components.\nYou may specify none, all, or any subset of these options,\nbut each option you specify will generally increase\nthe computation time (you can scrutinize the .log  file  to see how  much  additional time each\nextra output quantity takes to compute).", 
            "title": "Options requesting output quantities"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#option-requesting-visualization-output", 
            "text": "--PlotFlux  This option directs  scuff-neq  to produce visualization\nfiles (in addition to its usual output files) which may be \nopened in  gmsh  to visualize,\nfor each spatially-integrated PFT quantity you requested,\nthe spatial distribution of the Poynting flux or \nMaxwell stress on the surfaces of objects or \nthe displaced bounding surfaces over which those quantities\nare integrated to compute the total PFT quantity.", 
            "title": "Option requesting visualization output"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#options-specifying-object-temperatures", 
            "text": "--Temperature UpperSphere 300\n--Temperature LowerSphere 100\n--Temperature ENVIRONMENT 100   The first two options here set the temperatures\nof the objects labeled  UpperSphere  and LowerSphere  in the  .scuffgeo  file. Temperature specifications are interpreted in \nunits of Kelvin , so  300  corresponds to \nroom temperature.  The third option here sets the temperature of\nthe environment in which the objects are embedded.\n(The keywords  MEDIUM  and  EXTERIOR  may be used\nhere interchangeably with  ENVIRONMENT ).  Note that the temperatures of all objects, and of\nthe environment, are zero by default. This means that,\nif you request a full frequency-integrated calculation\n(which you do by omitting the  --omega  or  --omegaFile \noption) and you do not specify any  --temperature  \noptions, the code will chug for a while (computing \ntemperature-independent fluxes at various frequencies)\nbefore reporting strictly zero values for all\nquantities! This is probably not what you want.", 
            "title": "Options specifying object temperatures"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#options-controlling-the-computation-of-power-force-and-torque", 
            "text": "--ForceDSI  --DSIPoints 302\n--DSIRadius 5.0\n--DSIMesh BoundingMesh.msh\n--DSIFarField  As detailed in  this paper , there are several\nways to compute PFTs in surface-integral formulations,\nincluding the \"displaced-surface-integral\" (DSIPFT),\n\"equivalence principle\" (EPPFT), and \"overlap\" (OPFT) \nmethods.  By default,  scuff-neq  uses different algorithms for \ndifferent cases of the PFT computation:   Power computation (self term): EPPFT  Power computation (non-self terms): EPPFT  Force/Torque computation (self term): DSIPFT  Force/Torque computation (non-self term): OPFT   However, you can override this default behavior \nby specifying  --ForceDSI , in which case DSIPFT\nwill be used in all cases.  The other options here set specific parameters \nthat are only used for DSIPFT calculations.  --DSIMesh  specifies the name of a mesh file\n(such as a  GMSH -produced  .msh  file) that \ndefines the bounding surface over which the \nsurface integrals are computed. (This surface is\nautomatically displaced and rotated appropriately\nfor each object in accordance with any\ngeometrical transformations that may be \nspecified in the  .scuffgeo  file and/or the .trans  file.) The surface integral is evaluated\nvia a one-point cubature over the surface of \neach panel in the bounding mesh; thus, the\nfiner the bounding mesh, the more accurate and\nthe more expensive the computation).  If you do not specify a  --DSIMesh , then the\nsurface integral for each object is computed \nusing Lebedev cubature over a bounding sphere \ncentered at the origin of coordinates of the \nobject mesh (appropriately displaced if the \nobject has been displaced via statements in \nthe  .scuffgeo  or  .trans  files.) In this case,\nyou may use  --DSIRadius  and  --DSIPoints  to\nset the radius of this sphere (in microns) and \nthe number of Lebedev cubature points (the more \npoints, the more accurate and expensive the calculation).\nTo see the possible values that may be specified \nfor  --DSIPoints,  type  scuff-neq --help.  Finally, you may use  --DSIFarField  to request\nthat the Poynting vector and Maxwell tensor\non the bounding surface be computed using only\nthe far-field (radiation-zone) contributions \nof the surface currents to the fields.", 
            "title": "Options controlling the computation of power, force, and torque"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#other-options", 
            "text": "--OmitSelfTerms  Omit the contributions of sources in individual bodies\nto the total PFTs on those bodies themselves.", 
            "title": "Other options"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#3-scuff-neq-output-files", 
            "text": "", 
            "title": "3. scuff-neq output files"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#the-log-file", 
            "text": "Like all command-line codes in the  scuff-em  suite, scuff-cas3d  writes a  .log  file  that you\ncan monitor to keep track of your calculation's progress.", 
            "title": "The .log file"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#output-files-for-spatially-integrated-pfts-the-siflux-siintegrand-and-neqpft-files", 
            "text": "If you requested the computation of any spatially-integrated\nPFTs (by setting command-line options such as  --PAbs  or  --YForce ),\nyou will get back files reporting various contributions to \nthese quantities.\nTo understand what is written to these files, let  Q_d  be\nthe spatially-integrated PFT on a destination body  d ,\nand write the FSC decomposition of the thermal average\nof  Q_d  in the form    \\big\\langle Q_d\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to d}(u)}_{\\texttt{.SIFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SIIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.NEQPFT}}   In this equation,     u  is a dimensionless frequency variable:  u=\\omega/\\omega_0 , \nwhere  \\omega_0=3\\cdot 10^{14}  rad/sec. (Thus  u  agrees numerically\nwith the arguments to the  --omega  option.)     \\widehat\\Theta(u)  is a dimensionless version of the usual\nBose-Einstein factor, defined by  \\Theta(\\omega)=\\hbar \\omega_0 \\widehat\\Theta(u) .     \\Delta \\widehat \\Theta_s(u)=\\widehat \\Theta_s(u) - \\widehat \\Theta_{\\small env}(u)  \nis the difference between the dimensionless Bose-Einstein factors of source body  s  \nand the environment.     \\Phi_{s\\to d}  is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body  s \nto the power, force, or torque on destination body  d .\nValues of this quantity are written to the  .SIFlux  output\nfile.     \\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to d}(u)  is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body  s  to the PFT on destination\nbody  d . \nValues of this quantity are written to the  .SIIntegrand  output\nfile.    Finally,  \\langle Q_d \\rangle  is the total thermally-averaged\nPFT on body  d . Values of this quantity are written to the  .NEQPFT  output file.    In all of these files, each single line corresponds to\na single frequency, a single geometric transformation,\nand a single pair of (source,destination) objects.  At the top of each output file you will find a file header\nexplaining the significance of each of the various\ncolumns in the file. One of the columns will be\ndescribed in the header as  # (source object, dest object), \nand will take values like  12 ,  22 , or  02. \nThe first case ( 12 ) indicates that the data on that\nline correspond to the contributions of object 1 to the \nPFT on object 2. (The ordering of objects corresponds\nwith the order of their appearance in the  .scuffgeo \nfile).  The second case ( 22 ) indicate that the data\non that line correspond to the self-contributions of \nobject 2 to its own PFT. The third case ( 02 ) \nindicates that the data on that line correspond to \nthe  total  PFT on object 2---that is, the sum of \ncontributions from all source objects.", 
            "title": "Output files for spatially-integrated PFTs: The .SIFlux, .SIIntegrand, and .NEQPFT files"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#output-files-for-spatially-resolved-pfts-the-srflux-srintegrand-and-pvmst-files", 
            "text": "If you requested the computation of spatially-resolved\npower and momentum flux (by specifying the  --EPFile  \ncommand-line option), you will get back files reporting \nvarious contributions to these quantities. The breakdown\nhere is similar to that described above for spatially-integrated\nquantities. To understand this, let  Q(\\mathbf{x})  be\na spatially-resolved PFT quantity (a component \nof the Poynting vector or Maxwell stress tensor)\nat a point  \\mathbf{x} . Then the thermal average of  Q  \nmay be written in the form    \\big\\langle Q(\\mathbf{x})\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to\\mathbf x}(u)}_{\\texttt{.SRFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SRIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.PVMST}}   In this equation,     \\Phi_{s\\to \\mathbf{x}}  is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body  s \nto the Poynting flux or Maxwell stress at  \\mathbf{x} .\nValues of this quantity are written to the  .SRFlux  output\nfile.     \\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to \\mathbf{x}}(u)  is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body  s  to the Poynting flux or \nMaxwell stress at  \\mathbf{x} . Values of this quantity are \nwritten to the  .SRIntegrand  output\nfile.    Finally,  \\langle Q(\\mathbf{x})\\rangle  is the total thermally-averaged\nPoynting vector or Maxwell stress tensor at  \\mathbf{x} .\nValues of this quantity are written to the  .PVMST  output file.    In all of these files, each line corresponds to\na single frequency, a single geometric transformation,\nand a single source object.\nAt the top of each output file you will find a file header\nexplaining how to interpret the various data columns\non each line.", 
            "title": "Output files for spatially-resolved PFTs: The .SRFlux, .SRIntegrand, and .PVMST files"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#units-of-output-quantities", 
            "text": "The units of the total (frequency-integrated)\nspatially-integrated output quantities reported in\nthe  .NEQPFT  file are  watts  for power,  nanoNewtons \nfor force, and  nanoNewtons  \\times  microns  for torque.    The quantities in the  .SIIntegrand  output file\nare the PFT quantities per unit  dimensionless  frequency,\nso have the same units as the corresponding quantities\nin the  .NEQPFT  file.    The quantities in the  .SIFlux  output file are\nthe quantities per unit dimensionless frequency\nper watt of thermal energy, so these quantities\nhave the same units as the quantities in \nthe  .NEQPFT  and  .SIIntegrand  file, but divided\nby watts: thus the power flux is  dimensionless ,\nthe force flux has units of  nanoNewtons / watts ,\nand the torque flux has units of  nanoNewtons microns/watts.", 
            "title": "Units of output quantities"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#4-examples-of-calculations-using-scuff-neq", 
            "text": "Heat radiation from a warm sphere in a cold environment    Heat transfer and non-equilibrium Casimir forces between warm and cold spheres    Spatial distribution of poynting flux from a warm tip above a cold substrate", 
            "title": "4. Examples of calculations using scuff-neq"
        }, 
        {
            "location": "/applications/scuff-RF/scuff-RF/", 
            "text": "scuff-RF\n\n\nThe documentation for \nscuff-RF\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-RF"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/", 
            "text": "Solving electrostatics problems with\n     \nscuff-static\n\n\n\n\n\nscuff-static\n is a tool within the\n\nscuff-em\n code suite for solving\na broad class of electrostatics problems.\n\n\nThe various calculations that \nscuff-static\n may\nbe divided into two categories: \n\n(1)\n calculations that yield\nthe response of the geometry to one or more \nspecific excitation stimuli (\"type-1\" calculations),\nand \n\n(2)\n calculations\nthat yield intrinsic properties of the material geometry,\nindependent of any external excitation (\"type-2\"\ncalculations).\n\n\nType-1 calculations\n\n\nFor type-1 calculations, you pass command-line options\nto \nscuff-static\n that specify a specific\nelectrostatic \"excitation.\" A single excitation consists of\none or both of the following:\n\n\n\n\n\n\na set of electrostatic potential values at which to maintain\n   the conductors in the geometry (option \n--potfile\n);\n   conductors for which no value is specified are maintained \n   at 0V by default.\n\n\n\n\n\n\na description of an external electrostatic field,\n   which may be a superposition of\n\n\n\n\nthe field of one or point charges (\n--monopole\n),\n\n\nthe field of one or point dipoles (\n--dipole\n),\n\n\na spatially-constant electrostatic field (\n--ConstField\n)\n\n\nan spatially-varying electrostatic potential defined by a\n    user-specified functional form (\n--PhiExt\n).\n\n\n\n\n\n\n\n\nYou may also use the \n--ExcitationFile\n option to\nspecify a \nlist\n of excitations, each consisting of one or both\nof the above ingredients. This is equivalent to running\n\nscuff-static\n multiple times\nwith options specifying a single excitation \n(\n--potfile\n, \n--monopole\n, etc.) each time---but is much \nfaster\n,\nbecause of the structure of BEM solvers: once we have\ndone the set-up work needed to solve for one\nexcitation (namely, forming and factorizing the \n\nBEM matrix\n), solving for any number\nof additional excitations is essentially \"free\" computationally.\n\n\nHaving specified one or more excitations for a type-1\ncalculation, you may request multiple types of output,\nwhich will be computed separately for each excitation:\n\n\n\n\n\n\nValues of the electrostatic potential \n\\phi(\\mathbf x)\n and\n  electric field \n\\mathbf E(\\mathbf x)\n components\n  at arbitrary user-specified \nE\nvaluation \nP\noints \n\\mathbf x\n \n  inside or outside material bodies, output in the form of\n  numerical data in a text file (option \n--EPFile\n)\n\n\n\n\n\n\nField visualization files plotting the potential and\n  fields on one or more arbitrary user-specified \nF\nield-\nV\nisualization\n  mesh(es) (option \n--FVMesh\n), with the field-visualization\n  mesh(es)\n  optionally subject to one or more \n  \ngeometric transformations\n\n  (option \n--FVMeshTransFile\n)\n\n\n\n\n\n\nSurface-charge visualization files showing\n  the distribution of electrostatic surface charges\n  induced by the excitation (option \n--PlotFile\n)\n\n\n\n\n\n\nType-2 calculations\n\n\nIn contrast to type-1 calculations, type-2 calculations\ndo not involve any user-specified excitation. The available\ntype-2 calculations are:\n\n\n\n\n\n\nComputation of the capacitance matrix for the conductors \n  in the geometry (option \n--capfile\n)\n\n\n\n\n\n\nComputation of the DC polarizabilities of the bodies \n  (both conductors and dielectrics) in the geometry (option \n--polfile\n)\n\n\n\n\n\n\nComputation of the \nC-matrix\n, a sort of electrostatic\n  version of the \n\"T-matrix\"\n\n  used to characterize the scattering properties\n  of bodies at nonzero frequencies (options \n--CMatrixFile\n\n  and/or \n--CMatrixHDF5File\n). The C-matrix\n  was shown in \nthis paper\n\n  to be related to quantum-mechanical entanglement entropy.\n\n\n\n\n\n\nGeometrical transformations\n\n\nFor both type-1 and type-2 calculations, you may use\nthe optional \n--transfile\n option to specify a list\nof \ngeometric transformations\n\nto be applied to the scattering geometry; you will then\nget back results for each specified output quantity\nunder each transformation.\n\n\nImplicit dielectric substrates\n\n\nYou may use the optional \n--substrate\n option to specify\nthat your geometry exists in the presence of\na substrate consisting\nof one or more (infinite-area) stacked dielectric layers with an\noptional ground plane. This substrate will be treated \nimplicitly\n\nby \nscuff-static\n; your \n.scuffgeo\n file\nand the \n.msh\n files it specifies need only define the\n(finite-area) conducting and/or dielectric objects\nthat lie above (or within the substrate.\n\n\nUnder the hood: Implementation of \nscuff-static\n\n\nAs a technical detail, we note that the implementation of\n\nscuff-static\n actually differs in some significant ways\nfrom the other codes in the \nscuff-em\n suite; in particular,\nas compared to the \nscuff-em\n core library,\n\nscuff-static\n uses different basis functions and a\ndifferent formulation of the boundary-element method, as\nappropriate for zero-frequency problems. (More specifically,\n\nscuff-static\n expands\nsurface electric charge densities on PEC and dielectric\nsurfaces using ``pulse'' basis functions, which are\nconstant on individual triangles and vanishing everywhere\nelse.) However, from the implementation standpoint, it\nturns out that the calculations needed to implement the\nelectrostatics calculations in \nscuff-static\n are a\nproper \nsubset\n of the calculations already implemented\nin \nscuff-em\n. Moreover, from the user's standpoint,\nthe work needed to set up a \nscuff-static\n problem\n(create surface meshes, write geometry files, etc.)\nis similar to the setup needed for the nonzero-frequency\ncodes in the \nscuff-em\n suite.\nThis is why it makes sense to package these codes together.\n\n\nHere is a brief \ntechnical memo\n\ndiscussing the implementation of \nscuff-static\n,\nincluding both the underlying BEM electrostatics formulation\nand the execution of the various types of calculation\n(capacitance, polarizability, etc.) that the code can do.\n\n\nTable of Contents\n\n\n1. \nscuff-static\n command-line options\n\n\nOptions defining the geometry\n\n\nOptions defining individual excitations for type-1 calculations\n\n\nOptions defining multiple excitations for type-1 calculations\n\n\nOptions defining outputs for type-1 calculation\n\n\nOptions requesting outputs for type-2 calculations\n\n\n\n\n\n\n2. Examples of calculations using \nscuff-static\n\n\n\n\n\n\n\n\n\n\n1. \nscuff-static\n command-line options\n\n\nOptions defining the geometry\n\n\n--geometry    MyGeometry.scuffgeo\n--substrate   MySubstrate.substrate\n--TransFile   Transformations.trans\n\n\n\n\nThe mandatory \n--geometry\n option specifies a\n \nscuff-em\n geometry file\n\ndefining one or more surface meshes that comprise\nyour geometry.\n\n\nThe optional \n--substrate\n option specifies an \nfile describing a substrate consisting of zero or\nmore dielectric layers stacked atop an optional\nground plane; see \nhere\n\nfor an example.\n\n\nThe optional \n--TransFile\n option specifies a list\nof \ngeometric transformations\n\nto be applied to your geometry; each output calculation\nyou request will be repeated once for each\ngeometric transformation.\n\n\nOptions defining individual excitations for type-1 calculations\n\n\n\n\nTo run a \"type-1\" calculation with just a single\nexcitation, you may specify any combination\nof the following options.\n\n\n--PotFile    MyPotFile\n--ConstField Ex Ey Ez\n--Monopole   x y z Q\n--Dipole     x y z Px Py Pz\n--PhiExt     PhiExpression(x,y,z)\n\n\n\n\nHere \nMyPotFile\n should be a simple text file\nconsisting of a list of (surface label, potential value) pairs,\nwhere the surface label is the label assigned to a surface\nin the \n.scuffgeo\n file. For example, if your geometry\ncontains conductors labeled \nUpperSurface\n and \nLowerSurface\n,\nwhich you wish to maintain at 1.2 volts and -3.4 volts\nrespectively, then \nMyPotFile\n would look like this:\n\n\n UpperSurface  1.2\n LowerSurface -3.4\n\n\n\n\nAny conductors that are not specified in the \n--PotFile\n\nare maintained at 0 volts by default.\n\n\n--ConstField Ex Ey Ez\n specifies a spatially-constant\n    external electrostatic field with components\n    \nE\n=(\nEx\n,\nEy\n,\nEz\n).\n\n\n--Monopole x y z Q\n specifies a point charge of strength \nQ\n\n    at cartesian coordinates (\nx\n,\ny\n,\nz\n).\n\n\n--Dipole x y z px py pz\n specifies a point dipole\n    at cartesian coordinates (\nx\n,\ny\n,\nz\n) \n    with dipole moment \np\n=(\npx\n,\npy\n,\npz\n).\n\n\n--PhiExt MyPhiExpression(x,y,z)\n specifies a spatially-varying\n    electrostatic potential defined by the given function of cartesian\n    coordinates \nx\n, \ny\n, \nz\n. Example: \n--PhiExt cos(3*x)*cosh(3*y)\n\n\nOptions defining multiple excitations for type-1 calculations\n\n\n\n\n --ExcitationFile MyExcitationFile\n\n\n\n\nSpecifies that \nMyExcitationFile\n contains a list of\nexcitations. The file should consist of one or more \nclauses of the form \nEXCITATION Label ... ENDEXCITATION\n\nwhere \nLabel\n is an arbitrary label you assign to the\nexcitation (which will be used to tag the corresponding\noutput data). Each clause should contain one or more\nlines, each defining either \n(a)\n a {ConductorLabel, PhiValue}\npair, or \n(b)\n an external-field specification.\n(Note that all external-field specifications defined within\na single \nEXCITATION\n clause are present \nsimultaneously\n\nwhen that excitation is active.)\n\n\nHere's an example of an excitation file for a geometry\ncontaining conductors labeled \nUpperSurface\n and \nLowerSurface\n:\n\n\n EXCITATION UpperOnly\n   UpperSurface   1\n ENDEXCITATION\n\n EXCITATION LowerOnly\n   LowerSurface  -1\n ENDEXCITATION\n\n EXCITATION Both\n   UpperSurface   1\n   LowerSurface  -1\n ENDEXCITATION\n\n EXCITATION BothWithMonopoles\n   UpperSurface   1\n   LowerSurface  -1\n   Monopole       0 0 +1 1\n   Monopole       0 0 -1 1\n ENDEXCITATION\n\n EXCITATION Ex\n   CONSTFIELD     1.0 0.0 0.0\n ENDEXCITATION\n\n EXCITATION EyAndDipole\n   CONSTFIELD     0.0  1.0 0.0\n   DIPOLE         -0.1 0.2 0.3 0.4 -0.5 0.2\n ENDEXCITATION\n\n\n\n\nOptions defining outputs for type-1 calculation\n\n\n--EPFile     MyEPFile\n\n\n\n\nRequests that the electrostatic potential and field \ncomponents be computed at each evaluation point\nlisted in the file \nMyEPFile\n, which is a simple text\nfile containing three numbers per line (the coordinates \nof a single evaluation point.) The resulting output file\nwill contain a header explaining how to interpret its contents.\n\n\n--FVMesh          MyFVMesh.msh\n--FVMeshTransFile MyFVMeshTransFile\n\n\n\n\nRequests that electrostatic fields be computed\non a \nF\nield-\nV\nisualization mesh described by the \n\ngmsh\n mesh\nfile \nMyFVMesh.msh.\n This will produce\nin an output file with extension \n.pp\n that can be opened directly\nin \ngmsh\n to visualize the fields in any region of space.\n\n\nThe optional \nFVMeshTransFile\n defines a list of\n \ngeometric transformations\n to be applied\nto \nMyFVMesh.msh.\n This allows you to obtain visualization data on a\nlarge region foliated by multiple translated or rotated copies of a\nsingle mesh screen.\n\n\n--PlotFile   MyPlotFile.pp\n\n\n\n\nRequests creation of a \ngmsh\n visualization file named \nMyPlotFile.pp\n\nplotting the induced charge density on all conducting and\ndielectric surfaces in the geometry.\n\n\nOptions requesting outputs for type-2 calculations\n\n\n--CapFile    MyCapacitanceMatrix.dat\n\n\n\n\nIf you specify a file name using \n--CapFile\n, \nscuff-static\n\nwill compute the full capacitance matrix for your geometry\nand write the data to the specified file. (The file will be\noverwritten if it already exists.)\n\n\n--PolFile    MyPolFile.dat\n\n\n\n\nIf you specify a file name using \n--PolFile\n, \nscuff-static\n\nwill compute the DC polarizability of each object in your\ngeometry and write the data to the specified file. (The file\nwill be overwritten if it already exists.)\n\n\n\n\n\n\n2. Examples of calculations using \nscuff-static\n\n\n\n\n\n\nPolarizability of platonic solids\n\n\n\n\n\n\nSelf- and mutual-capacitance of pairs of conductors\n\n\n\n\n\n\nElectrostatic fields in the vicinity of a complicated gate array", 
            "title": "scuff-static"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#options-defining-the-geometry", 
            "text": "--geometry    MyGeometry.scuffgeo\n--substrate   MySubstrate.substrate\n--TransFile   Transformations.trans  The mandatory  --geometry  option specifies a\n  scuff-em  geometry file \ndefining one or more surface meshes that comprise\nyour geometry.  The optional  --substrate  option specifies an \nfile describing a substrate consisting of zero or\nmore dielectric layers stacked atop an optional\nground plane; see  here \nfor an example.  The optional  --TransFile  option specifies a list\nof  geometric transformations \nto be applied to your geometry; each output calculation\nyou request will be repeated once for each\ngeometric transformation.", 
            "title": "Options defining the geometry"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#options-defining-individual-excitations-for-type-1-calculations", 
            "text": "To run a \"type-1\" calculation with just a single\nexcitation, you may specify any combination\nof the following options.  --PotFile    MyPotFile\n--ConstField Ex Ey Ez\n--Monopole   x y z Q\n--Dipole     x y z Px Py Pz\n--PhiExt     PhiExpression(x,y,z)  Here  MyPotFile  should be a simple text file\nconsisting of a list of (surface label, potential value) pairs,\nwhere the surface label is the label assigned to a surface\nin the  .scuffgeo  file. For example, if your geometry\ncontains conductors labeled  UpperSurface  and  LowerSurface ,\nwhich you wish to maintain at 1.2 volts and -3.4 volts\nrespectively, then  MyPotFile  would look like this:   UpperSurface  1.2\n LowerSurface -3.4  Any conductors that are not specified in the  --PotFile \nare maintained at 0 volts by default.  --ConstField Ex Ey Ez  specifies a spatially-constant\n    external electrostatic field with components\n     E =( Ex , Ey , Ez ).  --Monopole x y z Q  specifies a point charge of strength  Q \n    at cartesian coordinates ( x , y , z ).  --Dipole x y z px py pz  specifies a point dipole\n    at cartesian coordinates ( x , y , z ) \n    with dipole moment  p =( px , py , pz ).  --PhiExt MyPhiExpression(x,y,z)  specifies a spatially-varying\n    electrostatic potential defined by the given function of cartesian\n    coordinates  x ,  y ,  z . Example:  --PhiExt cos(3*x)*cosh(3*y)", 
            "title": "Options defining individual excitations for type-1 calculations"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#options-defining-multiple-excitations-for-type-1-calculations", 
            "text": "--ExcitationFile MyExcitationFile  Specifies that  MyExcitationFile  contains a list of\nexcitations. The file should consist of one or more \nclauses of the form  EXCITATION Label ... ENDEXCITATION \nwhere  Label  is an arbitrary label you assign to the\nexcitation (which will be used to tag the corresponding\noutput data). Each clause should contain one or more\nlines, each defining either  (a)  a {ConductorLabel, PhiValue}\npair, or  (b)  an external-field specification.\n(Note that all external-field specifications defined within\na single  EXCITATION  clause are present  simultaneously \nwhen that excitation is active.)  Here's an example of an excitation file for a geometry\ncontaining conductors labeled  UpperSurface  and  LowerSurface :   EXCITATION UpperOnly\n   UpperSurface   1\n ENDEXCITATION\n\n EXCITATION LowerOnly\n   LowerSurface  -1\n ENDEXCITATION\n\n EXCITATION Both\n   UpperSurface   1\n   LowerSurface  -1\n ENDEXCITATION\n\n EXCITATION BothWithMonopoles\n   UpperSurface   1\n   LowerSurface  -1\n   Monopole       0 0 +1 1\n   Monopole       0 0 -1 1\n ENDEXCITATION\n\n EXCITATION Ex\n   CONSTFIELD     1.0 0.0 0.0\n ENDEXCITATION\n\n EXCITATION EyAndDipole\n   CONSTFIELD     0.0  1.0 0.0\n   DIPOLE         -0.1 0.2 0.3 0.4 -0.5 0.2\n ENDEXCITATION", 
            "title": "Options defining multiple excitations for type-1 calculations"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#options-defining-outputs-for-type-1-calculation", 
            "text": "--EPFile     MyEPFile  Requests that the electrostatic potential and field \ncomponents be computed at each evaluation point\nlisted in the file  MyEPFile , which is a simple text\nfile containing three numbers per line (the coordinates \nof a single evaluation point.) The resulting output file\nwill contain a header explaining how to interpret its contents.  --FVMesh          MyFVMesh.msh\n--FVMeshTransFile MyFVMeshTransFile  Requests that electrostatic fields be computed\non a  F ield- V isualization mesh described by the  gmsh  mesh\nfile  MyFVMesh.msh.  This will produce\nin an output file with extension  .pp  that can be opened directly\nin  gmsh  to visualize the fields in any region of space.  The optional  FVMeshTransFile  defines a list of\n  geometric transformations  to be applied\nto  MyFVMesh.msh.  This allows you to obtain visualization data on a\nlarge region foliated by multiple translated or rotated copies of a\nsingle mesh screen.  --PlotFile   MyPlotFile.pp  Requests creation of a  gmsh  visualization file named  MyPlotFile.pp \nplotting the induced charge density on all conducting and\ndielectric surfaces in the geometry.", 
            "title": "Options defining outputs for type-1 calculation"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#options-requesting-outputs-for-type-2-calculations", 
            "text": "--CapFile    MyCapacitanceMatrix.dat  If you specify a file name using  --CapFile ,  scuff-static \nwill compute the full capacitance matrix for your geometry\nand write the data to the specified file. (The file will be\noverwritten if it already exists.)  --PolFile    MyPolFile.dat  If you specify a file name using  --PolFile ,  scuff-static \nwill compute the DC polarizability of each object in your\ngeometry and write the data to the specified file. (The file\nwill be overwritten if it already exists.)", 
            "title": "Options requesting outputs for type-2 calculations"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#2-examples-of-calculations-using-scuff-static", 
            "text": "Polarizability of platonic solids    Self- and mutual-capacitance of pairs of conductors    Electrostatic fields in the vicinity of a complicated gate array", 
            "title": "2. Examples of calculations using scuff-static"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/", 
            "text": "Analyzing objects and geometries with \nscuff-analyze\n\n\n\nThe \nscuff-em\n suite comes with a simple standalone utility named \n\nscuff-analyze\n that you can use to gather some quick statistics on\nmeshed objects and scattering geometries described by mesh files and \ngeometry files.\n\n\nThere are several situations in which this can be useful:\n\n\n\n\nYou want to know how much memory will be occupied by the BEM matrix \n    for a geometry described by a \n.scuffgeo\n file.\n\n\nYour \n.scuffgeo\n file contains multiple \nOBJECTs\n or \nSURFACEs\n, each \n    described by a separate surface mesh and possibly displaced, rotated, \n    or periodically replicated via \nLATTICE\n statements, and you want to \n    visualize the full geometry to make sure the file you wrote actually \n    describes what you want.\n\n\nYou have created a \n.trans\n file describing a list of \n    \ngeometrical transformations\n \n    to be applied to your geometry, and before running a full calculation \n    you want to do a quick sanity check by visualizing the geometry under\n    each of your transformations to make sure they are what you intended.\n\n\nYou want to delve into the innards of \nlibscuff\n by playing around \n    with the simultaneous linear BEM system it constructs. In this case \n    you will need to know how the RWG basis functions in your surface mesh \n    are ordered within the BEM matrices and vectors, i.e. you need the \n    correspondence between rows of the BEM matrix and interior edges in your \n    surface-mesh geometry.\n\n\n\n\nTable of Contents\n\n\nscuff-analyze Command-Line Options\n\n\nOptions specifying the file to analyze\n\n\nOption specifying a list of geometrical transformations\n\n\nOptions controlling the generation of visualization files\n\n\n\n\n\n\nscuff-analyze console output\n\n\nRunning scuff-analyze on a geometry file\n\n\nRunning scuff-analyze on a mesh file\n\n\n\n\n\n\nViewing gmsh visualization files\n\n\ngmsh Visualization of Full Geometries\n\n\ngmsh Visualization of Extended Geometries: The --neighbors Option\n\n\ngmsh Visualization of Individual Meshes\n\n\n\n\n\n\nViewing gnuplot visualization files\n\n\ngnuplot Visualization of Full Geometries\n\n\ngnuplot Visualization of Individual Meshes\n\n\n\n\n\n\n\n\n\n\n\n\nscuff-analyze Command-Line Options\n\n\nOptions specifying the file to analyze\n\n\n    --geometry MyGeometry.scuffgeo\n\n\n\n\nAnalyze a full geometry described by a\n\nscuff-em\n geometry file\n.\n\n\n    --mesh     MyObject.msh\n    --meshFile MyObject.mesh\n\n\n\n\nAnalyze a single object described by a surface mesh. (The\ntwo options are synonymous.)\n\n\nOption specifying a list of geometrical transformations\n\n\n    --TransFile MyTransFile.trans\n\n\n\n\nSpecify a list of \n\ngeometrical transformations\n \nto be applied to a geometry. This is useful for \n(a)\n checking\nthat your transformation file can be properly parsed by \n\nscuff-em\n, and \n(b)\n producing a visualization output file to \nconfirm that the transformations you got are the ones you wanted.\n\n\nOptions controlling the generation of visualization files\n\n\n    --WriteGMSHFiles \n\n\n\n\nWrite visualization files suitable for viewing with \n\ngmsh\n.\n\n\n    --WriteGMSHLabels \n\n\n\n\nAppend visualization data to \ngmsh\n visualization files that \nprovides information on how the geometry is represented internally \nwithin \nscuff-em\n. This option is automatically enabled when the \n\n--mesh\n option is used.\n\n\n    --Neighbors nn\n\n\n\n\n(For periodically repeated geometries only). If this option is specified, \nthe \ngmsh\n visualization files will include the first \nnn\n neighboring \ncells in all directions. (For example, \n--Neighbors 1\n will produce a \nplot showing the innermost 3x3 grid of unit cells, while \n--Neighbors 2\n \nwill show the innermost 5x5 grid of cells.) This is useful for visualizing \nhow your unit-cell meshes fit together with their images across unit-cell \nboundaries to comprise a periodically replicated lattice.\n\n\n    --EPFile MyEPFile\n\n\n\n\nThis option allows you to specify a list of individual points\nto be plotted in the visualization file together with the\nmeshed surfaces in your geometry. This is useful for double-checking\nthat the points at which you are requesting spatially-resolved\ninformation from a \nscuff-em\n code (for example, scattered\nand total field components in \n\nscuff-scatter\n,\nor Casimir-Polder potentials in\n\nscuff-caspol\n\nspatially-resolved Poynting flux in\n\nscuff-neq\n) are \nactually the points you wanted. The file \nMyEPFile\n\nis the same file you specify for the \n--EPFile\n option\nto any other \nscuff-em\n code: it\nshould contain 3 numbers per line (the cartesian \ncoordinates of the points).\n\n\n    --WriteGnuplotFiles \n\n\n\n\nWrite visualization files suitable for viewing with \n\ngnuplot\n.\n\n\n\n\nscuff-analyze\n console output\n\n\nRunning \nscuff-analyze\n on a geometry file\n\n\nRunning \nscuff-analyze\n on a typical \nscuff-em\n geometry file \nyields console output that looks like this:\n\n\n      % scuff-analyze --geometry CylinderRing.scuffgeo\n\n         ***********************************************\n         *  GEOMETRY CylinderRing.scuffgeo \n         ***********************************************\n               2 objects\n           22548 total basis functions\n          Size of BEM matrix: 3.84 GB\n\n         ***********************************************\n         *  OBJECT 0: Label = Ring\n         ***********************************************\n          Meshfile: Ring.msh \n          7360 panels\n          11040 total edges\n          22080 total basis functions\n          11040 interior edges\n          3680 total vertices (after eliminating 0 redundant vertices)\n          3680 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                       3680 -          11040 +   7360 = 0\n\n          Total area: 6.1547934e+00 \n          Avg area: 8.3624910e-04 // sqrt(Avg Area)=2.8917972e-02\n\n         ***********************************************\n         *  OBJECT 1: Label = Cylinder\n         ***********************************************\n          Meshfile: Cylinder.msh \n          156 panels\n          234 total edges\n          468 total basis functions\n          234 interior edges\n          80 total vertices (after eliminating 0 redundant vertices)\n          80 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                         80 -            234 +    156 = 2\n\n          Total area: 6.6885562e-01 \n          Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n         Thank you for your support.\n\n\n\n\nRunning \nscuff-analyze\n on a mesh file\n\n\nYou can also run \nscuff-analyze\n on a mesh file describing just a \nsingle object:\n\n\n      % scuff-analyze --mesh Cylinder.msh\n\n         Meshfile: Cylinder.msh \n         156 panels\n         234 total edges\n         234 total basis functions\n         234 interior edges\n         80 total vertices (after eliminating 0 redundant vertices)\n         80 interior vertices\n         0 boundary contours\n\n         interior vertices - interior edges + panels = euler characteristic\n                        80 -            234 +    156 = 2\n\n         Total area: 6.6885562e-01 \n         Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n        Thank you for your support.\n\n\n\n\nOne use of \nscuff-analyze\n is to generate visualization files that \nmay be opened in \ngnuplot\n \nor \ngmsh.\n In addition to showing you what \nyour geometry looks like, these files will also indicate the internal \nnumbering that \nscuff-em\n uses for the vertices, panels, and edges \nin the surface discretization. This information can be useful, for \nexample, in interpreting the BEM matrices exported by passing the \n\n--ExportBEMMatrix\n option to various \nscuff-em\n programs.\n\n\n\n\nViewing \ngmsh\n visualization files\n\n\nThe \ngmsh\n visualization files generated by \nscuff-analyze\n \ncontain different information depending on whether you use the \n\n--geometry\n option to specify a full \nscuff-em\n geometry \n(a \n.scuffgeo\n file) or the \n\n--mesh\n option to specify a single surface mesh for an \nindividual object (as described by a \ngmsh\n \n.msh\n file or \nother mesh file format).\n\n\ngmsh\n Visualization of Full Geometries\n\n\nIf you specify the \n--geometry\n option, the resulting \n.pp\n file \nwill contain only a single \"view\" giving you a graphical \nrepresentation of the various objects in the geometry. This is \nconvenient for confirming that objects are positioned relative \nto one another in the way that you intended. For instance, \nconsider the following geometry file (called \nSphereCube.scuffgeo\n), \nwhich describes a geometry involving a sphere and a cube, with the \ncube displaced and rotated vis-a-vis the base position and orientation \ndescribed by its \n.msh\n file:\n\n\n OBJECT TheSphere\n    MESHFILE  Sphere.msh\n    MATERIAL  Silicon\n ENDOBJECT\n\n OBJECT TheCube\n    MESHFILE  Cube.msh\n    MATERIAL  Teflon\n    ROTATED   45 ABOUT 0 0 1\n    DISPLACED 0.9 1.1 2.3\n ENDOBJECT\n\n\n\n\nTo visualize this configuration of objects, from the command line we can say\n\n\n    % scuff-analyze --geometry SphereCube.scuffgeo --WriteGMSHFiles\n    % gmsh SphereCube.pp\n\n\n\n\nThe first command here creates a file called \nSphereCube.pp\n (as well \nas a bunch of console output, which we omit), while the second line \nopens this file in \ngmsh\n, yielding this:\n\n\n\n\ngmsh\n Visualization of Extended Geometries: The \n--neighbors\n Option\n\n\nHere's an example in which we have a periodically extended geometry \nand we'd like to visualize how the unit cell described by our \n\n.scuffgeo\n file fits together with its images across the unit-cell \nboundaries. This geometry describes an array of nanospheres atop a \nsilicon substrate.\n\n\nThe \n.scuffgeo\n file:\n\n\nLATTICE \n    VECTOR 2.4 0.0 0.0 \n    VECTOR 0.0 2.4 0.0\nENDLATTICE \n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION LowerHalfSpace MATERIAL Silicon\nREGION SphereInterior MATERIAL Gold\n\nSURFACE Sphere\n    MESHFILE Sphere.msh\n    DISPLACED 1.2 1.2 1.85\n    REGIONS UpperHalfSpace SphereInterior\nENDSURFACE\n\n\nSURFACE Substrate\n    MESHFILE Square.msh\n    REGIONS UpperHalfSpace LowerHalfSpace\nENDSURFACE\n\n\n\n\nTo visualize the unit cell together with a few surrounding lattice \ncells, we use the \n--Neighbors\n option to \nscuff-analyze\n:\n\n\n    % scuff-analyze --geometry SphereSubstrateArray.scuffgeo --WriteGMSHFiles --Neigbors 2\n    % gmsh SphereSubstrateArray.pp\n\n\n\n\n\n\nNotice that the visualization plot here includes extra panels hanging off \ntwo of the four edges of each lattice cell. These are called \nstraddlers;\n \nthey are not present in the actual \n.msh\n file specified in your \n.scuffgeo\n \nfile, but are automatically added internally by \nscuff-em\n for contiguous \nsurfaces extending beyond the confines of the unit cell.\n\n\ngmsh Visualization of Individual Meshes\n\n\nOn the other hand, if you specify the \n--mesh\n option to \nscuff-analyze\n, \nthen the \n.pp\n files generated by the \n--WriteGMSHFiles\n option will contain \nvarious additional information. For example, suppose we wanted to get some \nmore information on the sphere mesh from the previous example:\n\n\n    % scuff-analyze --mesh Sphere.msh --WriteGMSHFiles\n    % gmsh Sphere.pp\n\n\n\n\nThe first command here creates a \ngmsh\n post-processing file called \n\nSphere.pp\n which contains several \"views,\" each providing a different \nset of information on how \nscuff-em\n internally processes the surface \nmesh. Within the gmsh GUI, you can zoom in and out, rotate and translate \nthe object, and click the little yellow squares in the menu window to \nturn on and off the display of individual views. (For clarity, the \nscreenshot below was generated using a more coarsely-meshed sphere than \nin the screenshot above.)\n\n\n\n\nThe first view here (the one named \"Sphere\") just plots the triangular \npanels that define the surface mesh. This is the same information that \nyou would get from running \nscuff-analyze\n with the \n--geometry\n option.\n\n\nThe remaining views contain the following additional information. (This \ninformation is probably only of interest to people who want to hack about \nin the internals of \nlibscuff\n and need to know the details of the internal \nrepresentation of objects and BEM quantities.)\n\n\n\n\nThe direction of the surface normal to each panel as read in from the \n.msh\n file.\nAt present this information is not used for anything inside \nlibscuff\n, because \nscuff-em\n\nmakes its own overriding decision about how to orient the surface normal.\n\n\nThe (zero-based) indices of the panels.\n\n\nThe (zero-based) indices of the internal edges. The internal edge whose \n    index is \nn\n corresponds to the \nn\nth RWG basis function for this object \n    and hence to the \nn\nth surface-current expansion coefficient (for PEC \n    objects) or the \n2n\nth and \n2n+1\nth surface-current expansion coefficients \n    (for non-PEC objects) in the portion of the BEM solution vector \n    corresponding to the object in question.\n\n\nThe (zero-based) indices of the exterior edges.\n\n\nThe (zero-based) indices of the vertices.\n\n\n\n\n\n\nViewing \ngnuplot\n visualization files\n\n\ngnuplot\n Visualization of Full Geometries\n\n\nRunning \nscuff-analyze\n with the \n--WriteGNUPLOTFiles\n option will \ncreate a file called \nMyGeometry.gp\n (where \nMyGeometry.scuffgeo\n was \nthe geometry file specified using the \n--geometry\n option) which you \ncan visualize in \ngnuplot\n using the command \nsplot 'MyGeometry.gp' w lp.\n\n\n    % scuff-analyze --geometry SphereCube.scuffgeo --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot\n splot 'SphereCube.gp' w lp\n\n\n\n\n\n\ngnuplot\n Visualization of Individual Meshes\n\n\nRunning \nscuff-analyze\n with the \n--WriteGNUPLOTFiles\n option will \ncreate a file called \nMyObject.gp\n (where \nMyObject.msh\n was the mesh \nfile specified using the \n--mesh\n option), together with a bunch of \nauxiliary files named, for instance, \nMyObject.gp.edgelabels\n. \nThese auxiliary files contain \ngnuplot\n commands to superpose \nvarious types of additional information atop the basic plots, and \nshould be used with the \nload\n command, like this:\n\n\nbash\n    % scuff-analyze --mesh Sphere.msh --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot\n load 'Sphere.gp.edgelabels'\n    gnuplot\n splot 'Sphere.gp' w lp\nbash", 
            "title": "scuff-analyze"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#options-specifying-the-file-to-analyze", 
            "text": "--geometry MyGeometry.scuffgeo  Analyze a full geometry described by a scuff-em  geometry file .      --mesh     MyObject.msh\n    --meshFile MyObject.mesh  Analyze a single object described by a surface mesh. (The\ntwo options are synonymous.)", 
            "title": "Options specifying the file to analyze"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#option-specifying-a-list-of-geometrical-transformations", 
            "text": "--TransFile MyTransFile.trans  Specify a list of  geometrical transformations  \nto be applied to a geometry. This is useful for  (a)  checking\nthat your transformation file can be properly parsed by  scuff-em , and  (b)  producing a visualization output file to \nconfirm that the transformations you got are the ones you wanted.", 
            "title": "Option specifying a list of geometrical transformations"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#options-controlling-the-generation-of-visualization-files", 
            "text": "--WriteGMSHFiles   Write visualization files suitable for viewing with  gmsh .      --WriteGMSHLabels   Append visualization data to  gmsh  visualization files that \nprovides information on how the geometry is represented internally \nwithin  scuff-em . This option is automatically enabled when the  --mesh  option is used.      --Neighbors nn  (For periodically repeated geometries only). If this option is specified, \nthe  gmsh  visualization files will include the first  nn  neighboring \ncells in all directions. (For example,  --Neighbors 1  will produce a \nplot showing the innermost 3x3 grid of unit cells, while  --Neighbors 2  \nwill show the innermost 5x5 grid of cells.) This is useful for visualizing \nhow your unit-cell meshes fit together with their images across unit-cell \nboundaries to comprise a periodically replicated lattice.      --EPFile MyEPFile  This option allows you to specify a list of individual points\nto be plotted in the visualization file together with the\nmeshed surfaces in your geometry. This is useful for double-checking\nthat the points at which you are requesting spatially-resolved\ninformation from a  scuff-em  code (for example, scattered\nand total field components in  scuff-scatter ,\nor Casimir-Polder potentials in scuff-caspol \nspatially-resolved Poynting flux in scuff-neq ) are \nactually the points you wanted. The file  MyEPFile \nis the same file you specify for the  --EPFile  option\nto any other  scuff-em  code: it\nshould contain 3 numbers per line (the cartesian \ncoordinates of the points).      --WriteGnuplotFiles   Write visualization files suitable for viewing with  gnuplot .", 
            "title": "Options controlling the generation of visualization files"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#scuff-analyze-console-output", 
            "text": "", 
            "title": "scuff-analyze console output"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#running-scuff-analyze-on-a-geometry-file", 
            "text": "Running  scuff-analyze  on a typical  scuff-em  geometry file \nyields console output that looks like this:        % scuff-analyze --geometry CylinderRing.scuffgeo\n\n         ***********************************************\n         *  GEOMETRY CylinderRing.scuffgeo \n         ***********************************************\n               2 objects\n           22548 total basis functions\n          Size of BEM matrix: 3.84 GB\n\n         ***********************************************\n         *  OBJECT 0: Label = Ring\n         ***********************************************\n          Meshfile: Ring.msh \n          7360 panels\n          11040 total edges\n          22080 total basis functions\n          11040 interior edges\n          3680 total vertices (after eliminating 0 redundant vertices)\n          3680 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                       3680 -          11040 +   7360 = 0\n\n          Total area: 6.1547934e+00 \n          Avg area: 8.3624910e-04 // sqrt(Avg Area)=2.8917972e-02\n\n         ***********************************************\n         *  OBJECT 1: Label = Cylinder\n         ***********************************************\n          Meshfile: Cylinder.msh \n          156 panels\n          234 total edges\n          468 total basis functions\n          234 interior edges\n          80 total vertices (after eliminating 0 redundant vertices)\n          80 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                         80 -            234 +    156 = 2\n\n          Total area: 6.6885562e-01 \n          Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n         Thank you for your support.", 
            "title": "Running scuff-analyze on a geometry file"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#running-scuff-analyze-on-a-mesh-file", 
            "text": "You can also run  scuff-analyze  on a mesh file describing just a \nsingle object:        % scuff-analyze --mesh Cylinder.msh\n\n         Meshfile: Cylinder.msh \n         156 panels\n         234 total edges\n         234 total basis functions\n         234 interior edges\n         80 total vertices (after eliminating 0 redundant vertices)\n         80 interior vertices\n         0 boundary contours\n\n         interior vertices - interior edges + panels = euler characteristic\n                        80 -            234 +    156 = 2\n\n         Total area: 6.6885562e-01 \n         Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n        Thank you for your support.  One use of  scuff-analyze  is to generate visualization files that \nmay be opened in  gnuplot  \nor  gmsh.  In addition to showing you what \nyour geometry looks like, these files will also indicate the internal \nnumbering that  scuff-em  uses for the vertices, panels, and edges \nin the surface discretization. This information can be useful, for \nexample, in interpreting the BEM matrices exported by passing the  --ExportBEMMatrix  option to various  scuff-em  programs.", 
            "title": "Running scuff-analyze on a mesh file"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#viewing-gmsh-visualization-files", 
            "text": "The  gmsh  visualization files generated by  scuff-analyze  \ncontain different information depending on whether you use the  --geometry  option to specify a full  scuff-em  geometry \n(a  .scuffgeo  file) or the  --mesh  option to specify a single surface mesh for an \nindividual object (as described by a  gmsh   .msh  file or \nother mesh file format).", 
            "title": "Viewing gmsh visualization files"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#gmsh-visualization-of-full-geometries", 
            "text": "If you specify the  --geometry  option, the resulting  .pp  file \nwill contain only a single \"view\" giving you a graphical \nrepresentation of the various objects in the geometry. This is \nconvenient for confirming that objects are positioned relative \nto one another in the way that you intended. For instance, \nconsider the following geometry file (called  SphereCube.scuffgeo ), \nwhich describes a geometry involving a sphere and a cube, with the \ncube displaced and rotated vis-a-vis the base position and orientation \ndescribed by its  .msh  file:   OBJECT TheSphere\n    MESHFILE  Sphere.msh\n    MATERIAL  Silicon\n ENDOBJECT\n\n OBJECT TheCube\n    MESHFILE  Cube.msh\n    MATERIAL  Teflon\n    ROTATED   45 ABOUT 0 0 1\n    DISPLACED 0.9 1.1 2.3\n ENDOBJECT  To visualize this configuration of objects, from the command line we can say      % scuff-analyze --geometry SphereCube.scuffgeo --WriteGMSHFiles\n    % gmsh SphereCube.pp  The first command here creates a file called  SphereCube.pp  (as well \nas a bunch of console output, which we omit), while the second line \nopens this file in  gmsh , yielding this:", 
            "title": "gmsh Visualization of Full Geometries"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#gmsh-visualization-of-extended-geometries-the-neighbors-option", 
            "text": "Here's an example in which we have a periodically extended geometry \nand we'd like to visualize how the unit cell described by our  .scuffgeo  file fits together with its images across the unit-cell \nboundaries. This geometry describes an array of nanospheres atop a \nsilicon substrate.  The  .scuffgeo  file:  LATTICE \n    VECTOR 2.4 0.0 0.0 \n    VECTOR 0.0 2.4 0.0\nENDLATTICE \n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION LowerHalfSpace MATERIAL Silicon\nREGION SphereInterior MATERIAL Gold\n\nSURFACE Sphere\n    MESHFILE Sphere.msh\n    DISPLACED 1.2 1.2 1.85\n    REGIONS UpperHalfSpace SphereInterior\nENDSURFACE\n\n\nSURFACE Substrate\n    MESHFILE Square.msh\n    REGIONS UpperHalfSpace LowerHalfSpace\nENDSURFACE  To visualize the unit cell together with a few surrounding lattice \ncells, we use the  --Neighbors  option to  scuff-analyze :      % scuff-analyze --geometry SphereSubstrateArray.scuffgeo --WriteGMSHFiles --Neigbors 2\n    % gmsh SphereSubstrateArray.pp   Notice that the visualization plot here includes extra panels hanging off \ntwo of the four edges of each lattice cell. These are called  straddlers;  \nthey are not present in the actual  .msh  file specified in your  .scuffgeo  \nfile, but are automatically added internally by  scuff-em  for contiguous \nsurfaces extending beyond the confines of the unit cell.", 
            "title": "gmsh Visualization of Extended Geometries: The --neighbors Option"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#gmsh-visualization-of-individual-meshes", 
            "text": "On the other hand, if you specify the  --mesh  option to  scuff-analyze , \nthen the  .pp  files generated by the  --WriteGMSHFiles  option will contain \nvarious additional information. For example, suppose we wanted to get some \nmore information on the sphere mesh from the previous example:      % scuff-analyze --mesh Sphere.msh --WriteGMSHFiles\n    % gmsh Sphere.pp  The first command here creates a  gmsh  post-processing file called  Sphere.pp  which contains several \"views,\" each providing a different \nset of information on how  scuff-em  internally processes the surface \nmesh. Within the gmsh GUI, you can zoom in and out, rotate and translate \nthe object, and click the little yellow squares in the menu window to \nturn on and off the display of individual views. (For clarity, the \nscreenshot below was generated using a more coarsely-meshed sphere than \nin the screenshot above.)   The first view here (the one named \"Sphere\") just plots the triangular \npanels that define the surface mesh. This is the same information that \nyou would get from running  scuff-analyze  with the  --geometry  option.  The remaining views contain the following additional information. (This \ninformation is probably only of interest to people who want to hack about \nin the internals of  libscuff  and need to know the details of the internal \nrepresentation of objects and BEM quantities.)   The direction of the surface normal to each panel as read in from the  .msh  file.\nAt present this information is not used for anything inside  libscuff , because  scuff-em \nmakes its own overriding decision about how to orient the surface normal.  The (zero-based) indices of the panels.  The (zero-based) indices of the internal edges. The internal edge whose \n    index is  n  corresponds to the  n th RWG basis function for this object \n    and hence to the  n th surface-current expansion coefficient (for PEC \n    objects) or the  2n th and  2n+1 th surface-current expansion coefficients \n    (for non-PEC objects) in the portion of the BEM solution vector \n    corresponding to the object in question.  The (zero-based) indices of the exterior edges.  The (zero-based) indices of the vertices.", 
            "title": "gmsh Visualization of Individual Meshes"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#viewing-gnuplot-visualization-files", 
            "text": "", 
            "title": "Viewing gnuplot visualization files"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#gnuplot-visualization-of-full-geometries", 
            "text": "Running  scuff-analyze  with the  --WriteGNUPLOTFiles  option will \ncreate a file called  MyGeometry.gp  (where  MyGeometry.scuffgeo  was \nthe geometry file specified using the  --geometry  option) which you \ncan visualize in  gnuplot  using the command  splot 'MyGeometry.gp' w lp.      % scuff-analyze --geometry SphereCube.scuffgeo --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot  splot 'SphereCube.gp' w lp", 
            "title": "gnuplot Visualization of Full Geometries"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#gnuplot-visualization-of-individual-meshes", 
            "text": "Running  scuff-analyze  with the  --WriteGNUPLOTFiles  option will \ncreate a file called  MyObject.gp  (where  MyObject.msh  was the mesh \nfile specified using the  --mesh  option), together with a bunch of \nauxiliary files named, for instance,  MyObject.gp.edgelabels . \nThese auxiliary files contain  gnuplot  commands to superpose \nvarious types of additional information atop the basic plots, and \nshould be used with the  load  command, like this:  bash\n    % scuff-analyze --mesh Sphere.msh --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot  load 'Sphere.gp.edgelabels'\n    gnuplot  splot 'Sphere.gp' w lp bash", 
            "title": "gnuplot Visualization of Individual Meshes"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/", 
            "text": "Integrating frequency-dependent data with \nscuff-integrate\n\n\n\nMany application codes in the \nscuff-em\n suite compute\nphysical quantities defined by definite integrals over real\nor imaginary frequencies, with the numerical value of the\nintegrand at each point obtained by solving individual\n\nscuff-em\n scattering problems at that frequency. For example,\n\n\n\n\n \nscuff-cas3d\n \n and \n\n \nscuff-caspol\n \n\ncompute zero-temperature Casimir quantities by integrating \ncontributions from imaginary frequencies \n\\xi\n:\n\n\n\n\n\n\n\n\n\n Q = \\int_0^\\infty I(\\xi) \\, d\\xi \n\n\n\n\nHere \nQ\n is a zero-temperature Casimir energy/force/torque (\nscuff-cas3d\n)\nor Casimir-Polder potential (\nscuff-caspol\n) and \nI(\\xi)\n is the \nspectral density of contributions to \nQ\n from fluctuations at \nimaginary frequency \n\\xi\n, which may be obtained by solving\n\nscuff-em\n scattering calculations at imaginary frequency \n\\xi\n.\n\n\n\n\n \nscuff-neq\n \n computes\nthe total rate of energy or momentum transfer\nfrom a source body \ns\n to a destination body \nd\n \nby integrating contributions from real frequencies \n\\omega\n:\n\n\n\n\n\n\n\n\n\n Q^{s\\rightarrow d}\n   = \\int_0^\\infty\n     \\Big[ \\Theta(T_s,\\omega) - \\Theta(T_\\text{env},\\omega) \\Big]\n     \\Phi^{s\\rightarrow d}(\\omega) \\, d\\omega\n   \\qquad (1)\n\n\n\n\nHere \nQ^{s\\rightarrow d}\n is the contribution of body \ns\n to\nquantity \nQ\n (a heat-transfer rate, force, or torque) for body \nd\n,\n\n\\Theta(T,\\omega)=\\frac{\\hbar\\omega}{e^{\\hbar\\omega/kT}-1}\n\nis the Bose-Einstein statistical factor, \nT_s\n and \nT_\\text{env}\n\nare the temperatures of the source body and the environment,\nand \n\\Phi(\\omega)\n is a \"generalized flux\" quantity that may be \ncomputed by solving \nscuff-em\n scattering calculations\nat frequency \n\\omega\n.\n\n\nThe integrals over \n\\xi\n and \n\\omega\n are evaluated by\nnumerical cubature---that is, as weighted sums of integrand\nsamples. In a perfect world, it would be possible for \n\nscuff-em\n application codes to choose appropriate \nintegration strategies automatically, hiding these details\nfrom the user and reporting just the frequency-integrated\nquantities \nQ\n. This is in fact the strategy that was\nadopted in early incarnations of the \nscuff-em\n codes.\n\n\nIn the real world, however, the behavior of integrand \nfunctions like \nI(\\xi)\n and \n\\Phi(\\omega)\n varies widely\nfrom problem to problem, depending on factors such\nas the shapes and materials of bodies in the scattering\ngeometry and the quantity being computed. For this reason,\nit's hard for \nscuff-em\n to make intelligent automatic\nchoices of integration strategies, and attempts to do so \nwithout user input may result in misleading or even\nflat-out incorrect data.\n\n\nFor this reason, the modern approach to frequency integration\nin \nscuff-em\n is to ask users to define a\nlist of frequencies at which to sample the integrand; this\nlist is passed to \nscuff-em\n application codes using the \n\n--XiFile\n or \n--OmegaFile\n command-line options, and in \nresponse the code produces an output file reporting values\nof the integrand at the specified points. The frequency \nintegral may then be calculated as as post-processing step\nusing the information reported in the frequency-resolved\ndata files, and this is the task for which \nscuff-integrate\n\nexists.\n\n\nTable of Contents\n\n\nscuff-integrate\n tutorial walkthrough\n\n\nIntegrating a single function of frequency\n\n\nIntegrating multiple functions of frequency\n\n\nGiving names to data columns\n\n\nIntegrating functions of frequency and other parameters\n\n\nIntegrating scuff-neq data\n\n\n\n\n\n\nscuff-integrate\n Command-Line Reference\n\n\nOnly numerical data columns are counted as columns\n\n\n\n\n\n\nscuff-integrate\n tutorial walkthrough\n\n\nIntegrating a single function of frequency\n\n\nThe simplest usage of \nscuff-integrate\n is to integrate\na single function of frequency \nf(x)\n\n[where \nx\n denotes either real or imaginary frequency].\nSuppose we have a file called \nfData\n in which\nare tabulated numerical pairs \n(x_n, f_n)\n, \nn=1,2,\\cdots,N\n, \nwhere \nf_n=f(x_n)\n:\n\n\nx1 f1 \nx2 f2 \n...\nxN fN \n\n\n\n\nThen to compute \n\\int_{x_1}^{x_N} f(x) \\, dx\n we can just \ngo like this:\n\n\n% scuff-integrate --datafile fData --freqColumn 1 --dataColumn 2\n\n\n\n\nThis will produce a file named \nfData.Integrated\n containing\na single line of data: the integrated value of \nf\n.\n\n\nIf the frequency and/or integrand values are printed in\ndifferent columns of the data file, just adjust the \n\n--freqColumn\n and \n--dataColumn\n options accordingly. For\nexample, if the data file looks like this: \n\n\nstuff\n \nstuff\n x1 \nstuff\n \nstuff\n f1 \nstuff\n ...\n\nstuff\n \nstuff\n x2 \nstuff\n \nstuff\n f2 \nstuff\n ...\n...\n\nstuff\n \nstuff\n xN \nstuff\n \nstuff\n fN \nstuff\n ...\n\n\n\n\nyou would use \n--freqcolumn 3 --datacolumn 6.\n \nIn this case, the content of the other columns (the \nstuff\n\nin the above snippet) is ignored.\n\n\nIntegrating multiple functions of frequency\n\n\nMore generally, frequency-resolved data files produced by\n\nscuff-em\n codes will contain data on multiple functions\n\nf_1, \\cdots, f_p(x)\n. (For example, in \nscuff-cas3d\n \neach line of the data file may contain data on both\nCasimir energy and Casimir force.)\n\n\nYou can integrate all of these\nat once simply by specifying multiple \n--dataColumn\n\noptions. For example, if you have functions \nf\n and \ng\n\nand you have a file named \nfgData\n with the format\n\n\nx1 f1 g1 \nx2 f2 g2 \n...\nxN fN gN \n\n\n\n\nthen you can say\n\n\n% scuff-integrate --datafile fgData --freqColumn 1 --dataColumn 2 --datacolumn 3\n\n\n\n\nand the resulting output file \nfgData.Integrated\n\nwill report values for both \n\\int f(x)\\,dx\n and \n\\int g(x)\\,dx\n.\n\n\nGiving names to data columns\n\n\nIn the legend at the top of the \n.Integrated\n output file,\nthe values of the various integrated functions will by default\nbe labeled \ndata 0\n, \ndata 1\n, etc. If you want to give more\ndescriptive names, just follow each \n--dataColumn\n option\nwith a \n--dataName\n option. \n\n\nFor example, if your force and torque\nintegrands are respectively reported on columns 8 and 11\nof your data file, say \n\n--dataColumn 8 --dataName Force --dataColumn 11 --dataName Torque\n.\n\n\nIntegrating functions of frequency and other parameters\n\n\nIn many cases we will have functions that depend on various\nparameters beside frequency. (In \nscuff-cas3d\n, for example,\nwe might compute Casimir forces between particles separated\nby various distances \nd\n, so the integrand function may \nbe thought of as a function \nf(d,x)\n of both distance and frequency.)\n\n\nFor example, suppose your data file is called \npxfgData\n and \nlooks something like\n\n\np1 x1 f11 g11\np1 x2 f12 g12\n....\np1 xN f1N g1N\np2 x1 f21 g21\np2 x2 f22 g22\n....\np2 xN f2N g2N\n....\npM xN fMN gMN\n\n\n\n\nwhere \np1,\n \np2,\n ..., \npM\n denote \nM\n distinct values\nof some parameter \np\n and \nfmn,gmn\n are the numerical\nintegrand values \nf(p_m, x_n), g(p_m,x_n)\n. \nIn this case you can't simply say\n\n--freqColumn2 --dataColumn 3 --dataColumn 4,\n because then\ndata for all parameter values will be mashed all together and \nintegrated as a single function of frequency, yielding nonsense.\n\n\nInstead, you handle this situation by specifying the additional\ncommand-line parameter \n--tagColumn 1\n to tell \nscuff-integrate\n\nto interpret data lines with different values in column 1 \nas samples of different functions:\n\n\n% scuff-integrate --datafile pxfgData --tagcolumn 1 --freqColumn 2 --dataColumn 3 --dataColumn 4\n\n\n\n\nIn this case, the output file \npxfgData.Integrated\n will report\n\nx\n-integrated values of \nf\n and \ng\n separately for each value of\n\np\n.\n\n\nIf your integrands depend on multiple parameters \n(p,q,\\cdots)\n,\nyou may specify multiple \n--tagColumn\n options to specify\nthe columns in which values of the various parameters live.\nThen each line of the \n.Integrated\n output file will report\n\nx\n-integrated values of all functions for a single tuple of \nparameter values \n(p,q,\\cdots).\n\n\n\n\nIntegrating \nscuff-neq\n data\n\n\nscuff-integrate\n incorporates special functionality\nfor handling the particular frequency-resolved data files\nproduced by \nscuff-neq\n.\nIn this case, for a geometry containing \nN\n bodies,\neach line of the \n.SIFlux\n output file is tagged with\na data field of the form \nsd\n (where \ns\n and \nd\n are\nintegers between 1 and \nN\n) to label the contributions\nof sources in body \ns\n to the power, force, and/or torque\n(PFT) on body \nd\n. (For example, lines for which this field reads\n\n13\n give contributions of body 1 to the PFT for body 3).\nThe actual data quantities reported in the\n\n.SIFlux\n file are the generalized fluxes \n\\Phi^{s\\rightarrow d}\n\nin equation (1) above, and to evaluate the \n\\omega\n integral\nhere we need to know the temperatures of the environment\nand of all bodies in the geometry, which enter through \nthe Bose-Einstein factors in (1).\n\n\nTo handle these complications, \nscuff-integrate\n\nsupports the following additional command-line options:\n\n\n\n\n\n\n--sdColumn xx\n \n\n\nSpecifies that the \nsd\n indicator field appears on\ncolumn \nxx\n of the data file. (The default is \n--sdColumn 3\n,\nmatching the default file format of the \n.SIFlux\n files\nproduced by \nscuff-neq\n, so for those files this option\nmay be omitted.)\n\n\n\n\n\n\n\n\n\n\n\n\n--Temperature N T\n\n\nIf \nN\\ge 1\n, this sets the temperature of the \nN\nth object/surface in the geometry to \nT\n\nKelvin.\n(Here objects/surfaces are indexed using a 1-based convention; to set the temperature\nof the first object/surface specified in the \n.scuffgeo\n file to room temperature\nyou would say \n--Temperature 1 300.\n)\n\n\nIf \nN=0\n, this instead sets the temperature of the environment to \nT\n.\n\n\n\n\n\n\n\n\n\n\n\n\n--TemperatureFile TFile\n\n\nSpecifies a file containing multiple temperature configurations\nat which to compute total PFTs. For an \nN\n-body geometry,\neach line of \nTFile\n should contain \nN+1\n space-separated\nnumbers in the same format as the arguments to the \n--Temperature\n\noption, i.e. \nTEnv T1 ... TN.\n\n\nFor example, to compute PFTs in a two-body geometry with the\ntemperature of body 1 scanned from 10 to 300 Kelvin, the\ntemperature of body 2 held fixed at room temperature, and the\nenvironment temperature fixed at 0, \nTFile\n would look like\n\n\n\n\n\n\n0 10  300\n0 20  300\n...\n0 300 300\n\n\n\n\nscuff-integrate\n Command-Line Reference\n\n\nOnly numerical data columns are counted as columns\n\n\nThere is one potentially confusing aspect of the way\n\nscuff-integrate\n interprets column indices as specified\nby command-line arguments such as \n--FreqColumn\n or \nDataColumn\n.\nThis is that \nscuff-integrate\n treats non-numerical data columns\nas white space\n, and in particular does not include data columns\ncontaining text strings when counting column indices.\n\n\nThus, for example, if your data file contains frequency and\nintegrand data in the second and third columns, with the first\ncolumn containing a character string, like this:\n\n\nDEFAULT 0.1 3.45e-5\nDEFAULT 0.2 7.82e-5\nDEFAULT 0.3 1.10e-4\n...\n\n\n\n\nthen \nscuff-integrate\n ignores the \nDEFAULT\n column and considers\nthe first column with numerical data to be column 1, so here\nyou would say \n--freqColumn 1 --dataColumn 2.\n\n\nIn contrast, if your data file looks instead like this: \n\n\n4.00000 0.1 3.45e-5\n4.00000 0.2 7.82e-5\n4.00000 0.3 1.10e-4\n...\n\n\n\n\nyou would want to say \n--freqColumn 2 --dataColumn 3.", 
            "title": "scuff-integrate"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#integrating-a-single-function-of-frequency", 
            "text": "The simplest usage of  scuff-integrate  is to integrate\na single function of frequency  f(x) \n[where  x  denotes either real or imaginary frequency].\nSuppose we have a file called  fData  in which\nare tabulated numerical pairs  (x_n, f_n) ,  n=1,2,\\cdots,N , \nwhere  f_n=f(x_n) :  x1 f1 \nx2 f2 \n...\nxN fN   Then to compute  \\int_{x_1}^{x_N} f(x) \\, dx  we can just \ngo like this:  % scuff-integrate --datafile fData --freqColumn 1 --dataColumn 2  This will produce a file named  fData.Integrated  containing\na single line of data: the integrated value of  f .  If the frequency and/or integrand values are printed in\ndifferent columns of the data file, just adjust the  --freqColumn  and  --dataColumn  options accordingly. For\nexample, if the data file looks like this:   stuff   stuff  x1  stuff   stuff  f1  stuff  ... stuff   stuff  x2  stuff   stuff  f2  stuff  ...\n... stuff   stuff  xN  stuff   stuff  fN  stuff  ...  you would use  --freqcolumn 3 --datacolumn 6.  \nIn this case, the content of the other columns (the  stuff \nin the above snippet) is ignored.", 
            "title": "Integrating a single function of frequency"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#integrating-multiple-functions-of-frequency", 
            "text": "More generally, frequency-resolved data files produced by scuff-em  codes will contain data on multiple functions f_1, \\cdots, f_p(x) . (For example, in  scuff-cas3d  \neach line of the data file may contain data on both\nCasimir energy and Casimir force.)  You can integrate all of these\nat once simply by specifying multiple  --dataColumn \noptions. For example, if you have functions  f  and  g \nand you have a file named  fgData  with the format  x1 f1 g1 \nx2 f2 g2 \n...\nxN fN gN   then you can say  % scuff-integrate --datafile fgData --freqColumn 1 --dataColumn 2 --datacolumn 3  and the resulting output file  fgData.Integrated \nwill report values for both  \\int f(x)\\,dx  and  \\int g(x)\\,dx .", 
            "title": "Integrating multiple functions of frequency"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#giving-names-to-data-columns", 
            "text": "In the legend at the top of the  .Integrated  output file,\nthe values of the various integrated functions will by default\nbe labeled  data 0 ,  data 1 , etc. If you want to give more\ndescriptive names, just follow each  --dataColumn  option\nwith a  --dataName  option.   For example, if your force and torque\nintegrands are respectively reported on columns 8 and 11\nof your data file, say  --dataColumn 8 --dataName Force --dataColumn 11 --dataName Torque .", 
            "title": "Giving names to data columns"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#integrating-functions-of-frequency-and-other-parameters", 
            "text": "In many cases we will have functions that depend on various\nparameters beside frequency. (In  scuff-cas3d , for example,\nwe might compute Casimir forces between particles separated\nby various distances  d , so the integrand function may \nbe thought of as a function  f(d,x)  of both distance and frequency.)  For example, suppose your data file is called  pxfgData  and \nlooks something like  p1 x1 f11 g11\np1 x2 f12 g12\n....\np1 xN f1N g1N\np2 x1 f21 g21\np2 x2 f22 g22\n....\np2 xN f2N g2N\n....\npM xN fMN gMN  where  p1,   p2,  ...,  pM  denote  M  distinct values\nof some parameter  p  and  fmn,gmn  are the numerical\nintegrand values  f(p_m, x_n), g(p_m,x_n) . \nIn this case you can't simply say --freqColumn2 --dataColumn 3 --dataColumn 4,  because then\ndata for all parameter values will be mashed all together and \nintegrated as a single function of frequency, yielding nonsense.  Instead, you handle this situation by specifying the additional\ncommand-line parameter  --tagColumn 1  to tell  scuff-integrate \nto interpret data lines with different values in column 1 \nas samples of different functions:  % scuff-integrate --datafile pxfgData --tagcolumn 1 --freqColumn 2 --dataColumn 3 --dataColumn 4  In this case, the output file  pxfgData.Integrated  will report x -integrated values of  f  and  g  separately for each value of p .  If your integrands depend on multiple parameters  (p,q,\\cdots) ,\nyou may specify multiple  --tagColumn  options to specify\nthe columns in which values of the various parameters live.\nThen each line of the  .Integrated  output file will report x -integrated values of all functions for a single tuple of \nparameter values  (p,q,\\cdots).", 
            "title": "Integrating functions of frequency and other parameters"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#integrating-scuff-neq-data", 
            "text": "scuff-integrate  incorporates special functionality\nfor handling the particular frequency-resolved data files\nproduced by  scuff-neq .\nIn this case, for a geometry containing  N  bodies,\neach line of the  .SIFlux  output file is tagged with\na data field of the form  sd  (where  s  and  d  are\nintegers between 1 and  N ) to label the contributions\nof sources in body  s  to the power, force, and/or torque\n(PFT) on body  d . (For example, lines for which this field reads 13  give contributions of body 1 to the PFT for body 3).\nThe actual data quantities reported in the .SIFlux  file are the generalized fluxes  \\Phi^{s\\rightarrow d} \nin equation (1) above, and to evaluate the  \\omega  integral\nhere we need to know the temperatures of the environment\nand of all bodies in the geometry, which enter through \nthe Bose-Einstein factors in (1).  To handle these complications,  scuff-integrate \nsupports the following additional command-line options:    --sdColumn xx    Specifies that the  sd  indicator field appears on\ncolumn  xx  of the data file. (The default is  --sdColumn 3 ,\nmatching the default file format of the  .SIFlux  files\nproduced by  scuff-neq , so for those files this option\nmay be omitted.)       --Temperature N T  If  N\\ge 1 , this sets the temperature of the  N th object/surface in the geometry to  T \nKelvin.\n(Here objects/surfaces are indexed using a 1-based convention; to set the temperature\nof the first object/surface specified in the  .scuffgeo  file to room temperature\nyou would say  --Temperature 1 300. )  If  N=0 , this instead sets the temperature of the environment to  T .       --TemperatureFile TFile  Specifies a file containing multiple temperature configurations\nat which to compute total PFTs. For an  N -body geometry,\neach line of  TFile  should contain  N+1  space-separated\nnumbers in the same format as the arguments to the  --Temperature \noption, i.e.  TEnv T1 ... TN.  For example, to compute PFTs in a two-body geometry with the\ntemperature of body 1 scanned from 10 to 300 Kelvin, the\ntemperature of body 2 held fixed at room temperature, and the\nenvironment temperature fixed at 0,  TFile  would look like    0 10  300\n0 20  300\n...\n0 300 300", 
            "title": "Integrating scuff-neq data"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#scuff-integrate-command-line-reference", 
            "text": "", 
            "title": "scuff-integrate Command-Line Reference"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#only-numerical-data-columns-are-counted-as-columns", 
            "text": "There is one potentially confusing aspect of the way scuff-integrate  interprets column indices as specified\nby command-line arguments such as  --FreqColumn  or  DataColumn .\nThis is that  scuff-integrate  treats non-numerical data columns\nas white space , and in particular does not include data columns\ncontaining text strings when counting column indices.  Thus, for example, if your data file contains frequency and\nintegrand data in the second and third columns, with the first\ncolumn containing a character string, like this:  DEFAULT 0.1 3.45e-5\nDEFAULT 0.2 7.82e-5\nDEFAULT 0.3 1.10e-4\n...  then  scuff-integrate  ignores the  DEFAULT  column and considers\nthe first column with numerical data to be column 1, so here\nyou would say  --freqColumn 1 --dataColumn 2.  In contrast, if your data file looks instead like this:   4.00000 0.1 3.45e-5\n4.00000 0.2 7.82e-5\n4.00000 0.3 1.10e-4\n...  you would want to say  --freqColumn 2 --dataColumn 3.", 
            "title": "Only numerical data columns are counted as columns"
        }, 
        {
            "location": "/tests/Overview/", 
            "text": "Overview of the \nscuff-em\n Validation Test Suite\n\n\nThe \nscuff-em\n distribution includes a number of validation tests\nthat use the various dedicated\n\napplication modules\n\nto solve physics problems with known analytical solutions.\n\n\nIn addition to demonstrating the core functionality of\nthe application modules in simple cases,\nthese to \nthese are used as unit tests to catch bugs and regressions\nin the \nscuff-em\n development process; you can\nalso use them to verify the correct performance of your \n\nscuff-em\n installation.\n\n\nDescriptions of the individual tests in the validation suite\n\n\nThe various tests in the test suite are described in detail\non the following pages, which also present comparisons\nof \nscuff-em\n results to known analytical solutions.\n\n\n\n\nMie scattering\n\n\nFresnel scattering\n\n\n\n\nEquilibrium Casimir forces between spheres\n\n\n\n\n\n\nEquilibrium Casimir forces between plates\n\n\n\n\nEquilibrium Casimir-Polder potential near a sphere\n\n\nEquilibrium Casimir-Polder potential near a plate\n\n\nHeat transfer and non-equilibrium Casimir forces between spheres\n\n\nLow-level tests of the \nscuff-em\n core library\n\n\n\n\nRunning the \nscuff-em\n tests\n\n\nThe \nscuff-em\n distribution includes a command-line test harness\napplication that you may use to run individual tests, or the entire\ntest suite, to verify correct performance of your \nscuff-em\n\ninstallation.\n\n\nThe test harness is named \nscuff-test-harness,\n and it lives\nin the \ntests\n subdirectory of the \nscuff-em\n repository.\nThe \ntests\n folder also contains\n\n\n\n\n\n\na collection of text files with file extension \n.scuffTest\n,\n  each of which describes a single validation test in a format\n  understood by \nscuff-test-harness\n\n\n\n\n\n\nvarious input files (geometry files, surface meshes, etc.) \n  needed to run the tests\n\n\n\n\n\n\na collection of data files with file extension \n.ref\n,\n  which contain the correct results of the validation tests\n  and are used by \nscuff-test-harness\n to determine whether \n  or not the test succeeded.\n\n\n\n\n\n\nRunning individual tests\n\n\nTo run an individual validation test, use the \n--test\n option\nto \nscuff-test-harness:\n\n\n % scuff-test-harness --test MieScattering\n\n\n\n\nThe argument passed to \n--test\n should be the base\nfile name of one of the \n.scuffTest\n files.\n\n\nRunning the full test suite or a subset\n\n\nTo run the entire suite of validation tests, use the \n--allTests\n\noption:\n\n\n % scuff-test-harness --allTests\n\n\n\n\nChecking the results of validation tests", 
            "title": "Overview of the test suite"
        }, 
        {
            "location": "/tests/Overview/#descriptions-of-the-individual-tests-in-the-validation-suite", 
            "text": "The various tests in the test suite are described in detail\non the following pages, which also present comparisons\nof  scuff-em  results to known analytical solutions.   Mie scattering  Fresnel scattering   Equilibrium Casimir forces between spheres    Equilibrium Casimir forces between plates   Equilibrium Casimir-Polder potential near a sphere  Equilibrium Casimir-Polder potential near a plate  Heat transfer and non-equilibrium Casimir forces between spheres  Low-level tests of the  scuff-em  core library", 
            "title": "Descriptions of the individual tests in the validation suite"
        }, 
        {
            "location": "/tests/Overview/#running-the-scuff-em-tests", 
            "text": "The  scuff-em  distribution includes a command-line test harness\napplication that you may use to run individual tests, or the entire\ntest suite, to verify correct performance of your  scuff-em \ninstallation.  The test harness is named  scuff-test-harness,  and it lives\nin the  tests  subdirectory of the  scuff-em  repository.\nThe  tests  folder also contains    a collection of text files with file extension  .scuffTest ,\n  each of which describes a single validation test in a format\n  understood by  scuff-test-harness    various input files (geometry files, surface meshes, etc.) \n  needed to run the tests    a collection of data files with file extension  .ref ,\n  which contain the correct results of the validation tests\n  and are used by  scuff-test-harness  to determine whether \n  or not the test succeeded.", 
            "title": "Running the scuff-em tests"
        }, 
        {
            "location": "/tests/Overview/#running-individual-tests", 
            "text": "To run an individual validation test, use the  --test  option\nto  scuff-test-harness:   % scuff-test-harness --test MieScattering  The argument passed to  --test  should be the base\nfile name of one of the  .scuffTest  files.", 
            "title": "Running individual tests"
        }, 
        {
            "location": "/tests/Overview/#running-the-full-test-suite-or-a-subset", 
            "text": "To run the entire suite of validation tests, use the  --allTests \noption:   % scuff-test-harness --allTests", 
            "title": "Running the full test suite or a subset"
        }, 
        {
            "location": "/tests/Overview/#checking-the-results-of-validation-tests", 
            "text": "", 
            "title": "Checking the results of validation tests"
        }, 
        {
            "location": "/tests/MieScattering/MieScattering/", 
            "text": "Power, force, and torque in Mie scattering\n\n\nThis test validates the algorithms implemented in\n\nscuff-em\n for computing the power, force, and torque (PFT)\non bodies irradiated by external fields. The test \nuses the \n[\nscuff-scatter\n][scuff-scatter] application module\nto compute the PFT for a lossy dielectric sphere\nirradiated by a circularly-polarized plane wave\nand compares the results to the predictions of \nMie scattering theory.", 
            "title": "Mie scattering"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/", 
            "text": "Fresnel Scattering\n\n\nThis test validates the \nscuff-transmission\n application module\nof the \nscuff-em\n code suite by using it to study the textbook\ncase of \nFresnel scattering\n: the transmission and reflection of\nplane waves at a dielectric interface.\n\n\nExact solution\n\n\nThe situation considered here is that of a plane wave impinging \nfrom below on a dielectric half-space (relative permittivity \n\\epsilon=10\n)\nfilling the region \nz>0\n. (More details on the setup for\n\nscuff-transmission\n calculations may be found in the document\n\nComputation of reflection and transmission coefficients in \nscuff-em\n.)\n\n\nFor this case, the transmission and reflection coefficients\nfor the TE and TM polarizations read \n\n\n\n\n t^{\\scriptsize{\\text{TE}}}\n   =\\frac{2\\cos\\theta}{\\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TE}}}\n   =\\frac{\\cos\\theta-\\cos\\theta^\\prime}{\\cos\\theta + \\cos\\theta^\\prime},\n\n\n\n\n   t^{\\scriptsize{\\text{TM}}}\n  =\\frac{2n\\cos\\theta}{n^2 \\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TM}}}\n  =\\frac{n^2\\cos\\theta-\\cos\\theta^\\prime}{n^2\\cos\\theta + \\cos\\theta^\\prime}\n\n\n\n\n\nwhere \n\\theta\n is the incident angle (\n\\theta=0\n for normal incidence), \nn=\\sqrt{\\epsilon}\n is the index of refraction, and \n\n\n\n\n \\cos\\theta^\\prime = \\sqrt{ \\epsilon - \\sin^2\\theta}.\n\n\n\n\nscuff-em\n solution\n\n\nThe transmission and reflection coefficients for the \n\n\\epsilon=10\n dielectric\nhalf-space problem may be computed using \nscuff-transmission\n\nas follows:\n\n\n % scuff-transmission --geometry E10HalfSpace_40.scuffgeo --Omega 1.0 --ThetaMin 0.0 --ThetaMax 88.0 --ThetaPoints 20\n\n\n\n\n\nHere the file\n\nE10HalfSpace_40.scuffgeo\n\ndescribes the \nscuff-em\"\n geometry\n \n(it refers to a mesh file named\n\nSquare_40.msh\n) \nand the command-line arguments ask for a calculation at \nangular frequency \n\\omega=1\\cdot 3\\times 10^{14}\n rad/sec\nand at 20 incident angles in the range \n0\\le \\theta\\le 88\n degrees.\n\n\nComparison\n\n\nRunning the above command yields the file\n\nE10HalfSpace_40.transmission\n.\nPlotting in \ngnuplot\n yields \na comparison of \nscuff-transmission\n data (point) to \ntheoretical predictions (curves):\n\n\n\n\nHere is the \ngnuplot\n script that I use to produce this \nplot: \nPlotFresnelData.gp\n.", 
            "title": "Fresnel scattering"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/#exact-solution", 
            "text": "The situation considered here is that of a plane wave impinging \nfrom below on a dielectric half-space (relative permittivity  \\epsilon=10 )\nfilling the region  z>0 . (More details on the setup for scuff-transmission  calculations may be found in the document Computation of reflection and transmission coefficients in  scuff-em .)  For this case, the transmission and reflection coefficients\nfor the TE and TM polarizations read     t^{\\scriptsize{\\text{TE}}}\n   =\\frac{2\\cos\\theta}{\\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TE}}}\n   =\\frac{\\cos\\theta-\\cos\\theta^\\prime}{\\cos\\theta + \\cos\\theta^\\prime},  \n   t^{\\scriptsize{\\text{TM}}}\n  =\\frac{2n\\cos\\theta}{n^2 \\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TM}}}\n  =\\frac{n^2\\cos\\theta-\\cos\\theta^\\prime}{n^2\\cos\\theta + \\cos\\theta^\\prime}   where  \\theta  is the incident angle ( \\theta=0  for normal incidence),  n=\\sqrt{\\epsilon}  is the index of refraction, and     \\cos\\theta^\\prime = \\sqrt{ \\epsilon - \\sin^2\\theta}.", 
            "title": "Exact solution"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/#scuff-em-solution", 
            "text": "The transmission and reflection coefficients for the  \\epsilon=10  dielectric\nhalf-space problem may be computed using  scuff-transmission \nas follows:   % scuff-transmission --geometry E10HalfSpace_40.scuffgeo --Omega 1.0 --ThetaMin 0.0 --ThetaMax 88.0 --ThetaPoints 20   Here the file E10HalfSpace_40.scuffgeo \ndescribes the  scuff-em\"  geometry  \n(it refers to a mesh file named Square_40.msh ) \nand the command-line arguments ask for a calculation at \nangular frequency  \\omega=1\\cdot 3\\times 10^{14}  rad/sec\nand at 20 incident angles in the range  0\\le \\theta\\le 88  degrees.", 
            "title": "scuff-em solution"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/#comparison", 
            "text": "Running the above command yields the file E10HalfSpace_40.transmission .\nPlotting in  gnuplot  yields \na comparison of  scuff-transmission  data (point) to \ntheoretical predictions (curves):   Here is the  gnuplot  script that I use to produce this \nplot:  PlotFresnelData.gp .", 
            "title": "Comparison"
        }, 
        {
            "location": "/tests/CasimirSpheres/CasimirSpheres/", 
            "text": "Equilibrium Casimir forces between spheres\n\n\nThis test validates the \nscuff-cas3d\n application module\nof the \nscuff-em\n code suite by using it to compute\nthe equilibrium Casimir force between identical spheres\nat various separation distances. We consider both\nperfectly electrically conducting (PEC) \nand dielectric spheres.\n\n\nAnalytical solution\n\n\nAn analytical formula for the distance-dependent Casimir energy\nof two identical PEC spheres of radius \nR\n separated by a\ndistance \nd\n was obtained by T. Emig et al. in this paper:\n\n\n\n\nT. Emig, N. Graham, R. L. Jaffe, and M. Kardar, \"Casimir forces between arbitrary compact objects.\" \nPhysical Review Letters\n \n99\n 170403 (2007).\n\n\n\n\nTheir asymptotic (\nd\\gg R\n) formula for the energy, and the force\nformula obtained by differentiating it, are\n\n\n\n\n E(d) = -\\frac{\\hbar c}{\\pi R}   \\sum_{n=7}^\\infty C_n \\left(\\frac{R}{d}\\right)^n \n\n\n F(d) = -\\frac{\\hbar c}{\\pi R^2} \\sum_{n=7}^\\infty n C_n \\left(\\frac{R}{d}\\right)^{n+1}\n\n\n\n\nwhere the first few \nC\n coefficients are\n\n\n\n\n\n\nfor PEC spheres:\n  \nC_7=\\frac{143}{16}, \\quad C_9=\\frac{7947}{160}, \\quad C_{10}=\\frac{2065}{32}\n\n\n\n\n\n\n\n\nfor dielectric spheres with static \n(\\omega \\to 0)\n \n  relative permittivity \n\\epsilon\n:\n  \nC_7=\\frac{23}{4}\\left(\\frac{\\epsilon-1}{\\epsilon+2}\\right)^2\n\n\n\n\n\n\n\n\nscuff-em\n solution\n\n\nThe Casimir energy and force between two PEC spheres\nand between two dielectric spheres may be computed\nusing \nscuff-cas3d\n as follows:\n\n\n % scuff-cas3d --geometry PECSpheres_501.scuffgeo --translist Spheres.trans --energy --zforce\n % scuff-cas3d --geometry E10Spheres_501.scuffgeo --translist Spheres.trans --energy --zforce\n\n\n\n\nHere the two \n.scuffgeo\n files \n(\nPECSpheres_501.scuffgeo\n and \nE10Spheres_501.scuffgeo\n]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius \nR=1\\, \\mu\nm \nseparated by an initial center-center distance of \nd\n=3 \n\\mu\nm) while\n\nSpheres.trans\n specifies the list of center-center \nseparation distances \nd\n at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere, \nSphere_327.msh\n.\n\n\nThe above calculations produce output files named \n\nPECSpheres_327.out\n and \n\nE10Spheres_327.out\n. Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:\n\n\n.\n\n\nHere's the \ngnuplot\n script I used to produce this \nplot: \nPlotter.gp\n.", 
            "title": "Equilibrium Casimir forces between spheres"
        }, 
        {
            "location": "/tests/CasimirSpheres/CasimirSpheres/#analytical-solution", 
            "text": "An analytical formula for the distance-dependent Casimir energy\nof two identical PEC spheres of radius  R  separated by a\ndistance  d  was obtained by T. Emig et al. in this paper:   T. Emig, N. Graham, R. L. Jaffe, and M. Kardar, \"Casimir forces between arbitrary compact objects.\"  Physical Review Letters   99  170403 (2007).   Their asymptotic ( d\\gg R ) formula for the energy, and the force\nformula obtained by differentiating it, are    E(d) = -\\frac{\\hbar c}{\\pi R}   \\sum_{n=7}^\\infty C_n \\left(\\frac{R}{d}\\right)^n    F(d) = -\\frac{\\hbar c}{\\pi R^2} \\sum_{n=7}^\\infty n C_n \\left(\\frac{R}{d}\\right)^{n+1}   where the first few  C  coefficients are    for PEC spheres:\n   C_7=\\frac{143}{16}, \\quad C_9=\\frac{7947}{160}, \\quad C_{10}=\\frac{2065}{32}     for dielectric spheres with static  (\\omega \\to 0)  \n  relative permittivity  \\epsilon :\n   C_7=\\frac{23}{4}\\left(\\frac{\\epsilon-1}{\\epsilon+2}\\right)^2", 
            "title": "Analytical solution"
        }, 
        {
            "location": "/tests/CasimirSpheres/CasimirSpheres/#scuff-em-solution", 
            "text": "The Casimir energy and force between two PEC spheres\nand between two dielectric spheres may be computed\nusing  scuff-cas3d  as follows:   % scuff-cas3d --geometry PECSpheres_501.scuffgeo --translist Spheres.trans --energy --zforce\n % scuff-cas3d --geometry E10Spheres_501.scuffgeo --translist Spheres.trans --energy --zforce  Here the two  .scuffgeo  files \n( PECSpheres_501.scuffgeo  and  E10Spheres_501.scuffgeo ]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius  R=1\\, \\mu m \nseparated by an initial center-center distance of  d =3  \\mu m) while Spheres.trans  specifies the list of center-center \nseparation distances  d  at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere,  Sphere_327.msh .  The above calculations produce output files named  PECSpheres_327.out  and  E10Spheres_327.out . Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:  .  Here's the  gnuplot  script I used to produce this \nplot:  Plotter.gp .", 
            "title": "scuff-em solution"
        }, 
        {
            "location": "/tests/CasimirPlates/CasimirPlates/", 
            "text": "", 
            "title": "Equilibrium Casimir forces between plates"
        }, 
        {
            "location": "/tests/CPSphere/CPSphere/", 
            "text": "", 
            "title": "Equilibrium Casimir-Polder potential near a sphere"
        }, 
        {
            "location": "/tests/CPPlate/CPPlate/", 
            "text": "", 
            "title": "Equilibrium Casimir-Polder potential near a plate"
        }, 
        {
            "location": "/tests/NEQSpheres/NEQSpheres/", 
            "text": "Non-equilibrium fluctuation-induced interactions between spheres: heat radiation and non-equilibrium Casimir forces\n\n\nThis test validates the \nscuff-neq\n application module\nof the \nscuff-em\n code suite by using it to compute\n\n(a)\n the temperature-dependent rate of heat radiation\nfrom individual spheres,\n\n(b)\n radiative heat-transfer rates and non-equilibrium\nCasimir forces between spheres at various separation \ndistances.\n\n\nAnalytical solution\n\n\nAnalytical formulas for single-sphere heat radiation\nand sphere-sphere heat-transfer rates and non-equilibrium \nCasimir forces were obtained by M. Krueger and are\ndiscussed in this paper:\n\n\n\n\nM. Krueger, G. Bimonte, T. Emig, and M. Kardar, \"Trace formulas for nonequilibrium {C}asimir interactions, heat radiation, and heat transfer for arbitrary objects\", Physical Review B \\textbf{86} 115423 (2012)\n\n\n\n\nThe formulas are a bit complicated to reproduce here, but here\nis a simple \njulia\n\ncode that implements them:\n\n\n\n\nKruegerFormulas.jl\n\n\n\n\nThis code may be used to\n\n\nscuff-em\n solution\n\n\nValues of the flux quantity $\\phi^{\\text{\\small \nheat radiation\nand between two dielectric spheres may be computed\nusing \nscuff-cas3d\n as follows:\n\n\n % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile OmegaFile\n\n\n\n\n % scuff-neq --geometry SiO2Spheres_501.scuffgeo --OmegaFile OmegaFile\n\n\n\n\nHere the two \n.scuffgeo\n files \n(\nPECSpheres_501.scuffgeo\n and \nE10Spheres_501.scuffgeo\n]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius \nR=1\\, \\mu\nm \nseparated by an initial center-center distance of \nd\n=3 \n\\mu\nm) while\n\nSpheres.trans\n specifies the list of center-center \nseparation distances \nd\n at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere, \nSphere_327.msh\n.\n\n\nThe above calculations produce output files named \n\nPECSpheres_327.out\n and \n\nE10Spheres_327.out\n. Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:\n\n\n.\n\n\nHere's the \ngnuplot\n script I used to produce this \nplot: \nPlotter.gp\n.", 
            "title": "Heat transfer and non-equilibrium Casimir forces between spheres"
        }, 
        {
            "location": "/tests/NEQSpheres/NEQSpheres/#analytical-solution", 
            "text": "Analytical formulas for single-sphere heat radiation\nand sphere-sphere heat-transfer rates and non-equilibrium \nCasimir forces were obtained by M. Krueger and are\ndiscussed in this paper:   M. Krueger, G. Bimonte, T. Emig, and M. Kardar, \"Trace formulas for nonequilibrium {C}asimir interactions, heat radiation, and heat transfer for arbitrary objects\", Physical Review B \\textbf{86} 115423 (2012)   The formulas are a bit complicated to reproduce here, but here\nis a simple  julia \ncode that implements them:   KruegerFormulas.jl   This code may be used to", 
            "title": "Analytical solution"
        }, 
        {
            "location": "/tests/NEQSpheres/NEQSpheres/#scuff-em-solution", 
            "text": "Values of the flux quantity $\\phi^{\\text{\\small \nheat radiation\nand between two dielectric spheres may be computed\nusing  scuff-cas3d  as follows:   % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile OmegaFile   % scuff-neq --geometry SiO2Spheres_501.scuffgeo --OmegaFile OmegaFile  Here the two  .scuffgeo  files \n( PECSpheres_501.scuffgeo  and  E10Spheres_501.scuffgeo ]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius  R=1\\, \\mu m \nseparated by an initial center-center distance of  d =3  \\mu m) while Spheres.trans  specifies the list of center-center \nseparation distances  d  at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere,  Sphere_327.msh .  The above calculations produce output files named  PECSpheres_327.out  and  E10Spheres_327.out . Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:  .  Here's the  gnuplot  script I used to produce this \nplot:  Plotter.gp .", 
            "title": "scuff-em solution"
        }, 
        {
            "location": "/tests/libscuff/libscuff/", 
            "text": "", 
            "title": "Low-level tests of the core library"
        }, 
        {
            "location": "/API/libscuff/", 
            "text": "libscuff\n: Access to \nscuff-em\n internals from C++ or python programs\n\n\nThis documentation has not yet been ported from its earlier \nversion. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "libscuff"
        }, 
        {
            "location": "/forDevelopers/Implementation/", 
            "text": "Under the hood: the algorithms implemented by \nscuff-em\n\n\nThis page offers some top-level overview sketches \nof the basic algorithms implemented by the various codes in \nthe \nscuff-em\n suite.\n\n\nFor more details on the implementation of these algorithms, see\n\nData Structures and Class Methods in \nscuff-em\n.\n\n\nFor further technical details on the \nscuff-em\n core library, check out the\n\nlibscuff\n Implementation Notes and Technical Reference\n,\navailable as a PDF document.\n\n\nThe core library (\nlibscuff\n)\n\n\nAt its heart, the \n\nscuff-em\n core library\n\nis an implementation of the surface-integral-equation /\n boundary-element method (SIE / BEM) \nfor solving electromagnetic scattering problems. \n\n\nMore specifically, \n\nscuff-em\n \nimplements the EFIE and PMCHW formulations of the SIE / BEM with \nRWG basis functions used to expand tangential currents on the \nsurfaces of compact 3D objects.\n\n\nIf all of those acronyms went by a little quickly, \nhere's a sketch of the basic problem addressed by the\n\nscuff-em\n core library.\nWe have a collection of homogeneous material objects (maybe \ngold or silicon spheres or cubes) embedded in some medium \n(generally vacuum or a dielectric liquid), we irradiate the \nconfiguration with some known electromagnetic disturbance \n(such as a plane wave), and we seek to compute the electromagnetic \nfields scattered from the objects.\nIn a surface-integral-equation (SIE) method, we do this by first \ncomputing the \nsurface currents\n induced on the object \nsurfaces by the incident field. (For perfectly conducting \nscatterers we have only electric surface currents \nK\n; \nfor general scatterers we have both electric and magnetic \n(\nN\n) surface currents.) Once we have solved for the \nsurface currents, we can use them to evaluate the scattered \nfields anywhere we like.\n\n\n\n\nTo solve for the surface currents, we write down an \n\nintegral equation\n relating the surface currents to\nthe incident field. This integral equation basically says \nthat the tangential components of the scattered field (the \nfield due to the surface currents) should precisely cancel \nthe tangential components of the \nincident field at the object surfaces. \n(This statement is more of a mnemonic than a rigorous description;\nsee the \n\ntechnical memo\n\nfor a more thorough treatment.) \nSchematically, the integral\nequation looks something like this:\n\n\n\n\n \\oint \n   \\boldsymbol{\\Gamma}(\\omega; \\mathbf{x}, \\mathbf{x}^\\prime)\n   \\cdot \\left(\\begin{array}{c} \\mathbf{K}(\\mathbf{x}^\\prime) \\\\\n                                \\mathbf{N}(\\mathbf{x}^\\prime)\n         \\end{array}\\right) d\\mathbf{x}^\\prime\n       = -\\left(\\begin{array}{c} \\mathbf{E}(\\mathbf{x}) \\\\\n                                 \\mathbf{H}(\\mathbf{x})\n          \\end{array}\\right)^{\\hbox{\\scriptsize{inc}}}\n\n\n\n\n\nwhere \n\\boldsymbol{\\Gamma}\n\ninvolves the dyadic Green's function for Maxwell's \nequations. Here the surface integral extends over the surfaces of\nall scattering objects in our scattering geometry, and the equation\nis required to hold at all points \nx\n on all object\nsurfaces. (The equation is understood to apply only to the \nsurface-tangential components of the vectors on the two sides.)\n\n\nThis is the surface-integral-equation (SIE) formulation of \nour scattering problem. To solve the integral equation \nnumerically, we now proceed to \ndiscretize\n it by \nexpanding the \nK\n and \nN\n surface currents in some \nbasis of expansion functions. The particular functions used \nby \nlibscuff\n are the \"RWG\" basis \nfunctions, which were defined in this paper:\n\n\n\n\n\"Electromagnetic Scattering by Surfaces of Arbitrary Shape,\"\nby S. Rao, D. Wilton, and A. Glisson, \n\nIEEE Transactions on Antennas and Propagation\n \n30\n\n409 (1982) \n\nhttp://dx.doi.org/10.1109/TAP.1982.1142818\n\n\n\n\nThe RWG basis functions are defined by meshing the surfaces \nof compact 3D objects into flat triangular panels, and assigning \nto each internal \nedge\n in the discretization a localized \nsurface current that is sourced and sunk at the panel vertices \nopposite that edge:\n\n\n\n\nHaving introduced a discrete basis of expansion functions,\nour integral equation becomes a simultaneous system of \nlinear equations: \n\n\n\n\nThis approach to solving surface integral equations is known \nas the \nboundary-element method\n (BEM), and the linear \nsystem in the equation above is sometimes known as the BEM \nsystem. The \nscuff-em\n core library provides\nroutines for assembling the BEM matrix \nM\n, and the right-hand \nside vector of incident-field expansion coefficients, for arbitrary \nscattering geometries and arbitrary incident fields at arbitrary \nfrequencies.\n\n\nThen, using the matrix and RHS vector assembled by the core\nlibrary, you can use external linear algebra software like\n\nlapack\n\nto solve the linear system, after which you can again use\nroutines provided by the \nscuff-em\n core library to compute the \nscattered fields at arbitrary points.", 
            "title": "Implementation"
        }, 
        {
            "location": "/forDevelopers/Implementation/#the-core-library-libscuff", 
            "text": "At its heart, the  scuff-em  core library \nis an implementation of the surface-integral-equation /\n boundary-element method (SIE / BEM) \nfor solving electromagnetic scattering problems.   More specifically,  scuff-em  \nimplements the EFIE and PMCHW formulations of the SIE / BEM with \nRWG basis functions used to expand tangential currents on the \nsurfaces of compact 3D objects.  If all of those acronyms went by a little quickly, \nhere's a sketch of the basic problem addressed by the scuff-em  core library.\nWe have a collection of homogeneous material objects (maybe \ngold or silicon spheres or cubes) embedded in some medium \n(generally vacuum or a dielectric liquid), we irradiate the \nconfiguration with some known electromagnetic disturbance \n(such as a plane wave), and we seek to compute the electromagnetic \nfields scattered from the objects.\nIn a surface-integral-equation (SIE) method, we do this by first \ncomputing the  surface currents  induced on the object \nsurfaces by the incident field. (For perfectly conducting \nscatterers we have only electric surface currents  K ; \nfor general scatterers we have both electric and magnetic \n( N ) surface currents.) Once we have solved for the \nsurface currents, we can use them to evaluate the scattered \nfields anywhere we like.   To solve for the surface currents, we write down an  integral equation  relating the surface currents to\nthe incident field. This integral equation basically says \nthat the tangential components of the scattered field (the \nfield due to the surface currents) should precisely cancel \nthe tangential components of the \nincident field at the object surfaces. \n(This statement is more of a mnemonic than a rigorous description;\nsee the  technical memo \nfor a more thorough treatment.) \nSchematically, the integral\nequation looks something like this:    \\oint \n   \\boldsymbol{\\Gamma}(\\omega; \\mathbf{x}, \\mathbf{x}^\\prime)\n   \\cdot \\left(\\begin{array}{c} \\mathbf{K}(\\mathbf{x}^\\prime) \\\\\n                                \\mathbf{N}(\\mathbf{x}^\\prime)\n         \\end{array}\\right) d\\mathbf{x}^\\prime\n       = -\\left(\\begin{array}{c} \\mathbf{E}(\\mathbf{x}) \\\\\n                                 \\mathbf{H}(\\mathbf{x})\n          \\end{array}\\right)^{\\hbox{\\scriptsize{inc}}}   where  \\boldsymbol{\\Gamma} \ninvolves the dyadic Green's function for Maxwell's \nequations. Here the surface integral extends over the surfaces of\nall scattering objects in our scattering geometry, and the equation\nis required to hold at all points  x  on all object\nsurfaces. (The equation is understood to apply only to the \nsurface-tangential components of the vectors on the two sides.)  This is the surface-integral-equation (SIE) formulation of \nour scattering problem. To solve the integral equation \nnumerically, we now proceed to  discretize  it by \nexpanding the  K  and  N  surface currents in some \nbasis of expansion functions. The particular functions used \nby  libscuff  are the \"RWG\" basis \nfunctions, which were defined in this paper:   \"Electromagnetic Scattering by Surfaces of Arbitrary Shape,\"\nby S. Rao, D. Wilton, and A. Glisson,  IEEE Transactions on Antennas and Propagation   30 \n409 (1982)  http://dx.doi.org/10.1109/TAP.1982.1142818   The RWG basis functions are defined by meshing the surfaces \nof compact 3D objects into flat triangular panels, and assigning \nto each internal  edge  in the discretization a localized \nsurface current that is sourced and sunk at the panel vertices \nopposite that edge:   Having introduced a discrete basis of expansion functions,\nour integral equation becomes a simultaneous system of \nlinear equations:    This approach to solving surface integral equations is known \nas the  boundary-element method  (BEM), and the linear \nsystem in the equation above is sometimes known as the BEM \nsystem. The  scuff-em  core library provides\nroutines for assembling the BEM matrix  M , and the right-hand \nside vector of incident-field expansion coefficients, for arbitrary \nscattering geometries and arbitrary incident fields at arbitrary \nfrequencies.  Then, using the matrix and RHS vector assembled by the core\nlibrary, you can use external linear algebra software like lapack \nto solve the linear system, after which you can again use\nroutines provided by the  scuff-em  core library to compute the \nscattered fields at arbitrary points.", 
            "title": "The core library (libscuff)"
        }, 
        {
            "location": "/forDevelopers/DataStructures/", 
            "text": "Data Structures and Class Methods in \nscuff-em\n\n\nThis page is intended to serve as a starting point for hackers \nseeking to understand, or extend, the nitty-gritty implementation\ndetails of the \nscuff-em\n core library.\n\n\nMore technical details may be found in the \n\nlibscuff\n Implementation Notes and Technical Reference\n, \navailable as a PDF document.\n\n\n\n\n\n \n Data Structures and Class Methods in \nscuff-em\n\n\n\n\n \n \n  Geometries, Regions, Surfaces\n\n \n \n      Panels, Edges, Vertices\n\n \n \n  Assembling the BEM Matrix\n\n \n \n     An Explicit Low-Level Example\n\n\n\n\n\n\n\n1. Geometries, Regions, Surfaces\n\n\nThe top-level data structure in \nlibscuff\n\nis a C++ class named \nRWGGeometry.\n The definition of this class is a \nlittle too big to present in full here (you can find it in the \nheader file \nlibscuff.h\n), but we will point out its\nmost important data fields and class methods.\n\n\nGeometries in \nscuff-em\n are represented\na collection of two or more contiguous \nthree-dimensional \nregions\n \nbounded by one or more two-dimensional \nsurfaces.\n\nMaterial properties (permittivity and permeability) are homogeneous \n(spatially constant) in each region and described by a single\n\nscuff-em\n material description\n.\n\n\nEach region is assigned an integer index starting from \n0.\n\nThe \nRWGGeometry\n includes the following data fields for \nidentifying physical regions.\n\n\nclass RWGGeometry \n   { \n      ... \n      int NumRegions;\n      char **RegionLabels;\n      MatProp **RegionMPs;\n      ... \n   }; \n\n\n\n\nHere \nRegionLabels[i]\n is a string description for the \n\ni\nth region in the problem, and \nRegionMPs[i]\n is\na pointer to an instance of \nMatProp\n describing its \nfrequency-dependent material properies. (\nMatProp\n is \na very simple class, implemented by the \n\nlibmatprop\n submodule of \nscuff-em\n, for\nhandling frequency-dependent material properties.)\n\n\nRWGGeometry\n always starts off with a single \nregion (region \n0\n) with label \nExterior\n \nand the material properties of vacuum. \nEach \nREGION\n statement in the\n\n.scuffgeo\n file\n\nthen creates a new region, starting with region \n1.\n\n(This is true unless the label specified to the \nREGION\n\nkeyword is \nExterior,\n in which case the \nstatement just redefines the material properties of region \n0\n.)\nEach \nOBJECT...ENDOBJECT\n section in the \n.scuffgeo\n\nfile also creates a single new region (for the interior of the object).\n\n\nRegions in a geometry are separated from one another by surfaces.\nEach surface is described by a C++ class named \nRWGSurface.\n\nThe \nRWGGeometry\n class maintains an internal array of \n\nRWGSurfaces:\n\n\nclass RWGGeometry \n   { \n      ... \n      int NumSurfaces;\n      RWGSurface **Surfaces;\n      ... \n   }; \n\n\n\n\nEach \nOBJECT...ENDOBJECT\n or \nSURFACE...ENDSURFACE\n\nsection in the \n.scuffgeo\n file adds a new \nRWGSurface\n\nstructure to the geometry. (Note that, in \nscuff-em\n \nparlance, an \"object\" is just a special case of a surface in which the \nsurface is \nclosed.\n) \n\n\nThe \nRWGSurface\n class is again slightly\ntoo complicated to list in full here, but we will discuss its most salient \nfields and methods. Among these are the \nRegionIndices\n field:\n\n\n class RWGSurface\n   { \n      ... \n      int RegionIndices[2];\n      ... \n   }; \n\n\n\n\nThese two integers are the indices of the regions on the two sides of the \nsurface. The \nfirst\n region (\nRegionIndex[0]\n) is \nthe \npositive\n region for the surface; this means that the electric\nand magnetic surface currents on the surface contribute to the fields \nin that region with a positive sign. The second region \n(\nRegionIndex[1]\n) is the \nnegative\n region; currents \non the surface contribute to the fields in that region with a negative\nsign.\n\n\nAnother way to think of this is that the surface normal vector \n\nn\n points \n\naway from\n \nRegionIndex[1]\n \nand \n\ninto\n \nRegionIndex[0]\n.\n\n\n\n\n2. Panels, Edges, Vertices\n\n\nThe mesh describing each surface in a geometry is structure is analyzed \ninto lists of \nvertices\n, triangular \npanels,\n and panel \n\nedges.\n Several internal data fields in the \nRWGSurface\n\nclass are devoted to storing this information. \n\n\nclass RWGSurface\n{ \n  ... \n  int NumVertices;\n  double *Vertices;\n\n  int NumPanels;\n  RWGPanel **Panels;\n\n  int NumEdges;            \n  RWGEdge **Edges;\n  ... \n\n};\n\n\n\n\nHere \nVertices\n is an array of \n3*NumVertices\n \n\ndouble\n values in which the cartesian coordinates of each \nvertex are stored one after another. Thus, the \nx, y, z\n \ncoordinates of the \nnv\nth vertex are \n\nVertices[3*nv+0], Vertices[3*nv+1], Vertices[3*nv+2].\n\n\nPanels\n and \nEdges\n are arrays of pointers\nto specialized data structures for storing geometric data.\n\n\nThe \nRWGPanel\n and \nRWGEdge\n structures\n\n\nThe elemental data structure in the \nscuff-em\n\ngeometry hierarchy is \nRWGPanel\n. Each instance of this structure\ndescribes a single triangular panel in the mesh discretization of an \n\nRWGSurface.\n\n\n \nRWGPanel\n definition \n\n\ntypedef struct RWGPanel\n { \n   int VI[3];            /* indices of vertices in Vertices array */\n   int EI[3];            /* indices of edges in Edges array */\n\n   double Centroid[3];   /* panel centroid */\n   double ZHat[3];       /* normal vector */\n   double Radius;        /* radius of enclosing sphere */\n   double Area;          /* panel area */\n\n   int Index;            /* index of this panel within RWGSurface */\n\n } RWGPanel;\n\n\n\n\nHere the elements of the \nVI\n array are the indices of the \nthree panel vertices within the list of vertices for the given \n\nRWGSurface.\n The \nIndex\n field in \nRWGPanel\n\nindicates that panel's index within the \nPanels\n array \nof the parent \nRWGSurface.\n The remaining fields tabulate some useful\ngeometric data on the panel.\n\n\nIn addition to an \nRWGPanel\n structure for each triangle \nin the surface mesh, we also create an \nRWGEdge\n structure\nfor each panel \nedge.\n\n\n \nRWGEdge\n definition \n\n\ntypedef struct RWGEdge \n { \n   int iV1, iV2, iQP, iQM;  /* indices of panel vertices (iV1\nlt;iV2) */\n   double Centroid[3];      /* edge centroid */\n   double Length;           /* length of edge */\n   double Radius;           /* radius of enclosing sphere */\n\n   int iPPanel;             /* index of PPanel within RWGSurface (0..NumPanels-1)*/\n   int iMPanel;             /* index of MPanel within RWGSurface (0..NumPanels-1)*/\n   int PIndex;              /* index of this edge within PPanel (0..2)*/\n   int MIndex;              /* index of this edge within MPanel (0..2)*/\n   int Index;               /* index of this edge within RWGSurface (0..NumEdges-1)*/\n\n   RWGEdge *Next;           /* pointer to next edge in linked list */\n\n } RWGEdge;\n\n\n\n\nThe \niQP, iV1, iV2, iQM\n fields here are indices into the \nlist of vertices for the parent \nRWGSurface.\n \n\niV1\n and \niV2\n are the actual endpoints of the edge.\n\niQP\n and \niQM\n denote respectively the current\n\nsource\n and \nsink\n vertices for the RWG basis function corresponding\nto this edge.\n\n\niPPanel\n and \niMPanel\n are the indices (into the \n\nPanels\n array of the parent \nRWGSurface\n) of the \n\npositive\n and \nnegative\n panels associated with the edge.\n(The positive panel is the one from which the RWG current emanates; \nits vertices are \niQP, iV1, iV2.\n\nThe negative panel is the one into which the RWG current is sunk;\nits vertices are \niQM, iV1, iV2.\n) \nThe \niPPanel\n and \niMPanel\n fields take values\nbetween \n0\n and \nNumPanels-1\n, where \n\nNumPanels\n is defined in the parent \nRWGSurface.\n\n\nPIndex\n and \nMIndex\n are the indices of the edge \nwithin the positive and negative \nRWGPanel\ns.\n(The index of an \nedge\n within a panel is defined as the index \nwithin the panel of the panel \nvertex\n opposite that edge; the \nindex of a vertex is its position in the \nVI\n array in the \n\nRWGPanel\n structure.)\n\n\nThe \nIndex\n field of \nRWGEdge\n is the index of \nthe structure within the \nEdges\n array of the parent \n\nRWGSurface.\n\n\nThe remaining fields store some geometric data on the edge.\nThe \nCentroid\n field stores the cartesian coordinates\nof the midpoint of the line segment between vertices \nV1\n\nand \nV2\n.\n\n\nHere's an example of two panels (panel indices \n17\n and \n\n39\n) in a surface mesh, and a single \nedge (edge index \n24\n) shared between them. \nPanel \n17\n is the positive panel for the edge, \nwhile panel \n39\n is the negative panel for the edge; the corresponding\ndirection of current flow is indicated by the arrows.\nThe larger red numbers near the vertices are the indices of those\nvertices in the \nVertices\n array. \nThe smaller magenta and cyan numbers are the indices of the vertices \nwithin the \nVI\n arrays in the two \nRWGPanels\n.\n(The other four edges of this panel pair would also have corresponding \n\nRWGEdge\n structures; these are not shown in the figure.)\n\n\n\n\n\n\n3. Assembling the BEM Matrix\n\n\nThe \nRWGGeometry\n class contains a hierarchy of \nroutines for assembling the BEM matrix. If you are simply\nusing the code to solve scattering problems, you will\nonly ever need to call the top-level routine \n\nAssembleBEMMatrix\n or perhaps the \nsecond-highest-level routine, \nAssembleBEMMatrixBlock.\n\nHowever, developers of surface-integral-equation methods \nmay wish to access the lower-level routines for \ncomputing the interactions of individual RWG basis functions\nor for computing certain integrals over triangular regions.\n\n\nAssembleBEMMatrix\n\n\nThe top-level matrix assembly routine is \n\nAssembleBEMMatrix.\n This routine loops over \nall unique pairs of \nRWGSurfaces\n in the geometry. \nFor each unique pair \nof surfaces, the routine calls \nAssembleBEMMatrixBlock\n \nto assemble the subblock of the BEM matrix corresponding to a single \npair of \nRWGSurfaces,\n then stamps this subblock \ninto the appropriate place in the overall BEM matrix. \n\n\nFor example, if a geometry contains three \nRWGSurfaces\n,\nthen its overall BEM matrix has the block structure\n\n\n\n\nwhere the \n\\mathbf{M}__{ij}\n subblock describes the\ninteractions of surfaces \ni\n and \nj\n.\nIn this case \nAssembleBEMMatrix\n proceeds by making 6 calls\nto \nAssembleBEMMatrixBlock\n, one for each of the \ndiagonal and above-diagonal blocks. (The below-diagonal\nblocks are related to their above-diagonal counterparts by \nsymmetry.)\n\n\nAssembleBEMMatrixBlock\n\n\nAssembleBEMMatrixBlock\n computes the subblock of the \nBEM matrix corresponding to a single pair of \nRWGSurface\ns.\nFor compact (non-periodic) geometries, this amounts to making just\na single call to \nSurfaceSurfaceInteractions\n. For \nperiodic geometries, this involves making multiple calls to \n\nSurfaceSurfaceInteractions\n in which one of the two \nsurfaces is displaced through various lattice vectors \nL\n to account\nfor the contribution of periodic images. \n\n\nThe contribution of the \nmatrix subblock computed by \nSurfaceSurfaceInteractions\n\nwith displacement vector \nL\n is weighted in the overall\nBEM matrix by a Bloch phase factor \n\n e^{i\\mathbf{k}\\cdot \\mathbf{L}}\n\nwhere \nk\n is the Bloch wavevector, i.e. we have \n\n\n\n\nwhere the \nL\n superscript indicates that the corresponding\nmatrix subblock is to be computed with one of the two surfaces \ndisplaced through translation vector \nL\n.\n\n\nSurfaceSurfaceInteractions\n\n\nSurfaceSurfaceInteractions\n loops over all \nRWGEdge\n\nstructures on each of the two surfaces it is considering.\nFor each pair of edges, it calls \nEdgeEdgeInteractions\n\nto compute the inner products of the RWG basis functions\nwith the \nG\n and \nC\n dyadic Green's functions\nfor each of the material regions through which the two surfaces\ninteract. (Surfaces may interact through 0, 1, or 2 material \nregions.)\nThen it stamps these values into their appropriate places\nin the BEM matrix subblock. \n\n\nFor example, if we have surfaces \n\nS\n and \nS\n that \ninteract through a single dielectric medium, the structure of \nthe corresponding matrix subblock is\n\n\n\n\nwhere e.g. \nb\nm\n is the \n\nm\nth basis function on surface \nS\n. \nThe kernels\nhere are scalar multiples of the \nG\n and \nC\n\ndyadics:\n\n\n\n\nwhere \nk\n, \nZ\n are the wavenumber and (absolute)\nwave impedance of the dielectric medium at the frequency\nin question.\n\n\nThe matrix structure above is for the case of two surfaces\ninteracting through a single material region (for example,\n\nS\n and \nS\n\nmight be the outer surfaces of two compact objects embedded \nin vacuum or in a homogeneous medium, in which case the \nsurfaces interact only throught that medium).\nIf the surfaces interact through \ntwo\n material regions\n(for example, if we have \n\nS\n=\nS\n\nand we are computing the self-interaction of the outer\nsurface of a dielectric object embedded in vacuum) then\neach matrix entry is actually a sum of \ntwo\n \ninner products, one involving the \n kernels for \nthe interior medium and one involving the kernels for \nthe exterior. (If the surfaces are PEC, then the dimension\nof the matrix is halved with only the \nEE\n terms\nretained.)\n\n\nEdgeEdgeInteractions\n\n\nEdgeEdgeInteractions\n considers a pair of RWG basis\nfunctions and computes the inner products of these basis functions\nwith the \nG\n and \nC\n dyadic Green's functions for a \nsingle material medium. Because each basis function is supported\non two triangles, the full inner products involve sums of four\ntriangle-pair contributions:\n\n\n\n\nHere \nl\nm\n,l\nn\n are the lengths of the\ninterior edges to which the RWG basis functions are associated, and\neach of the four terms in the sum is a four-dimensional integral \nover a single pair of panels, computed by \n\nPanelPanelInteractions.\n\n\nPanelPanelInteractions\n\n\nPanelPanelInteractions\n is the lowest-level routine in the \n\nscuff-em\n BEM matrix assembly hierarchy.\nThis routine computes the individual terms in equation (1) above,\ni.e. the contributions of a single pair of panels\nto the inner products of two RWG basis functions with the \nG\n and \n\nC\n dyadic Green's functions:\n\n\n\n\nNote that the RWG basis-function prefactor \nl/2A\n is broken\nup into two factors between equations (1) and (2): the \n1/2A\n\npart is included in the panel-panel integrals (2), while \nthe \nl\n part is included when summing the four panel-panel\ncontributions in equation (1) to obtain the overall inner product. \n\n\nIf the panels are far away from each other, \nPanelPanelInteractions\n \nuses low-order four-dimensional numerical cubature to compute the full\ninteractions. Otherwise, \nPanelPanelInteractions\n uses\nlow-order four-dimensional numerical cubature to compute the interactions\nwith \nsingularity-subtracted versions\n of the \nG\n and \nC\n \nkernels, then adds the contributions of the singular terms after \nlooking them up in an internally-stored cache.\n\n\n\n\n4. An Explicit Low-Level Example\n\n\nHere's a worked example of a matrix-element computation in a \nscuff-em\n run. \n\n\nThe geometry and the labeling of panels, edges, and vertices\n\n\nWe'll consider a\nscattering geometry consisting of a single cube of dielectric\nmaterial, with side length \nL=\n1 \nm, discretized into \ntriangles with minor side length \nL/10\n, yielding a total\nof 1200 triangles, 1800 interior edges, and 3600 RWG basis \nfunctions (1800 each for electric and magnetic currents) \nfor a dielectric geometry. The \n\ngmsh\n geometry file for this example is \n\nCube_N.geo\n,\nthe \ngmsh\n mesh file produced by running\n\ngmsh -2 Cube_N.geo\n is\n\nCube_10.msh\n,\nand a \nscuff-em\n geometry file describing\na geometry consisting of this discretized cube with interior dielectric\npermittivity \n=4 is\n\nDielectricCube.scuffgeo\n.\n\n\n\n\nFor low-level work it is convenient to have data on the internal \nindices that \nscuff-em\n assigns to \npanels, vertices, and edges when it reads in a geometry file.\nWe get this by running \nscuff-analyze\n on the mesh file\nin question with the \n--WriteGMSHLabels\n options:\n\n\n % scuff-analyze --mesh Cube_10.msh --WriteGMSHFiles --WriteGMSHLabels\n\n\n\n\nThis produces a file named \nCube_10.pp\n, which we open in \n\ngmsh\n to produce a graphical depiction of \nthe labeling of panels, edges, and vertices. Zooming in on the region\nnear the origin, we will focus on the two panels lying closest to the \norigin in the \nxy\n plane; we see that \n\nscuff-em\n has assigned these two panels\npanel indices \n0\n and \n1\n, respectively, while\nthe edge they share has been assigned interior-edge index \n0\n.\n\n\n\n\nRWG basis function \nb\n0\n\n\nHere's a schematic depiction of the panels that comprise the\nbasis function \nb\n0\n associated with interior edge\n\n0\n:\n\n\n\n\nIn this diagram, the edge length is \nL\n=0.1, \nO\n denotes \nthe origin of coordinates, and the vertices marked \n\nQ\n are the\nsource and sink vertices for the current distribution. \nThe RWG basis function \nb\n0\n associated with \ninterior edge 0 is \n\n\n\n\nwhere the RWG basis function edge length is \nl\n=\n2\nL\n\nand the panel areas are \n\nA\n0\n=A\n1\n=\nL\n2\n/2.\nNote that \n\nP\n0\n and\n\nP\n1\n are respectively the positive and negative\npanels associated with basis function \nb\n0\n.\n\n\nPanel-panel interactions\n\n\nHere's a \nC++\n code snippet that computes the \nquantities \n\nG\n00\n++\n \nand \n\nG\n00\n+-\n in equation (1a)\nabove, i.e. the contributions of the positive-positive \nand positive-negative panel pairs to the inner product of \n\nb\n0\n with itself through the \nG\n kernel,\nwith the wavenumber set to \nk=\n1.0;\nJust to be totally explicit, the numbers that are being \ncomputed here are\n\n\n\n\n\n // read in geometry from .scuffgeo file\n RWGGeometry *G = new RWGGeometry(\nDielectricCube.scuffgeo\n);\n RWGSurface *S = G-\nSurfaces[0];\n\n // initialize an argument structure for GetPanelPanelInteractions\n GetPPIArgStruct MyPPIArgs, *PPIArgs=\nMyPPIArgs;\n InitGetPPIArgs(PPIArgs);\n PPIArgs-\nSa = PPIArgs-\nSb = S;\n PPIArgs-\nk = 1.0;\n\n // fill in arguments to compute the positive-positive panel pair\n PPIArgs-\nnpa = 0;\n PPIArgs-\niQa = 1;\n PPIArgs-\nnpb = 0;\n PPIArgs-\niQb = 1;\n GetPanelPanelInteractions(PPIArgs);\n printf(\nG++ = %e + %ei\\n\n,real(PPIArgs-\nH[0]),imag(PPIArgs-\nH[0]));\n\n // fill in arguments to compute the positive-negative panel pair\n PPIArgs-\nnpa = 0;\n PPIArgs-\niQa = 1;\n PPIArgs-\nnpb = 1;\n PPIArgs-\niQb = 2;\n GetPanelPanelInteractions(PPIArgs);\n printf(\nG++ = %e + %ei\\n\n,real(PPIArgs-\nH[0]),imag(PPIArgs-\nH[0]));\n\n\n\n\nThis code produces the following output:\n\n\n\nG++ = -3.189105e+00 + -7.950381e-02i\nG+- = -1.537561e+00 + -7.956272e-02i\n\n\n\n\nNotice that, to compute a panel-panel interaction, you allocate\nand initialize an instance of a data structure called \n\nGetPPIArgs\n. This structure contains a large \nnumber of fields which in many cases can be set to default \nvalues; to ensure that these fields are properly initialized,\nalways call \nInitGetPPIArgs()\n on an newly-allocated\ninstance of \nGetPPIArgs\n.\n\n\nThen, you fill in the appropriate fields of this structure \nto specify the two panels over which you want to integrate.\nSpecifically, the fields \n\nSa\n, \nnpa\n\nspecify the first panel (the \nnpa\nth \nRWGPanel\n\nin the \nPanels\n array for surface \nSa\n), \nwhile the field \niQa\n (an integer in the range \n0..2\n)\nidentifies the index of the \nQ\n vertex (RWG current source/sink\nvertex) within the three vertices of the panel. \nThe fields \n\nSb\n, \nnpb\n, and \niQb\n\nsimilarly identify the second panel and source/sink vertex.\nInitialize the \nk\n field in the \n\nGetPPIArgs\n structure to the wavenumber parameter\nin the Helmholtz kernel. (\nk\n may be complex or purely imaginary.)\n\n\nEdge-panel interactions\n\n\nHere's a \nC++\n code snippet that computes the \nfull basis-function inner product\n\n \nb\n0\n | \nG\n | \nb\n0\n \n\nin equation (1a) above.\n\n\n GetEEIArgStruct MyEEIArgs, *EEIArgs=\nMyEEIArgs;\n InitGetEEIArgs(EEIArgs);\n EEIArgs-\nSa = EEIArgs-\nSb = S;\n EEIArgs-\nnea = EEIArgs-\nneb = 0;\n EEIArgs-\nk = 1.0;\n GetEdgeEdgeInteractions(EEIArgs);\n printf(\nlt;b|G|b\ngt; = %e + %ei\\n\n,real(EEIArgs-\nGC[0]),imag(EEIArgs-\nGC[0]));\n\n\n\n\nNote that, similar to the case of \nGetPanelPanelInteractions\n\ndiscussed above, the call to \nGetEdgeEdgeInteractions\n takes as\nargument a pointer to a struct of type \nGetEEIArgStruct\n.\nAs before, you should always call \nInitGetEEIArgs\n \nto initialize this structure, then set whichever fields you \nneed to specify.\nIn this case, the only fields we need to set are \n\nSa,Sb\n (indices of the \nRWGSurface\n), \n\nnea,neb\n \n(indices of the interior edges in the \nEdges\n array \ncorresponding to the RWG basis functions), and \nk\n \n(wavenumber parameter in the Helmholtz kernel). \nThe result of this code snippet is\n\n\n \nb|G|b\n = -6.606176e-02 + 2.356554e-06i\n\n\n\n\nUsing equation (1a) above, we can understand this result in conjunction \nwith the results printed out above for \nG++\n and \n\nG+-\n. For this particular basis function, only two \nof the four panel-panel interactions on the RHS of equation (1a) \nhave distinct values (because the two panels that comprise the \nbasis function have the same shapes and areas, so we have\n\nG-+ = G+-\n and \nG-- = G++\n), and the\n\nedge-length prefactors \nl\nm\n, \nl\nn\n \nboth have value 0.1\n2. Thus for this case \nequation (1a) reads\n\n\n \nb\n0\n | \nG\n | \nb\n0\n \n\n=2\n0.02\n(\nG++ - G+-\n)\n\n\nand, indeed, plugging in the numbers printed out above, we find\n\n\n{6.6e-02, 2.4e-06i} \n= 2\n0.02\n( {-3.19,-7.95e-2i} - {-1.54,7.96e-2i} ).", 
            "title": "Data Structures"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#1-geometries-regions-surfaces", 
            "text": "The top-level data structure in  libscuff \nis a C++ class named  RWGGeometry.  The definition of this class is a \nlittle too big to present in full here (you can find it in the \nheader file  libscuff.h ), but we will point out its\nmost important data fields and class methods.  Geometries in  scuff-em  are represented\na collection of two or more contiguous \nthree-dimensional  regions  \nbounded by one or more two-dimensional  surfaces. \nMaterial properties (permittivity and permeability) are homogeneous \n(spatially constant) in each region and described by a single scuff-em  material description .  Each region is assigned an integer index starting from  0. \nThe  RWGGeometry  includes the following data fields for \nidentifying physical regions.  class RWGGeometry \n   { \n      ... \n      int NumRegions;\n      char **RegionLabels;\n      MatProp **RegionMPs;\n      ... \n   };   Here  RegionLabels[i]  is a string description for the  i th region in the problem, and  RegionMPs[i]  is\na pointer to an instance of  MatProp  describing its \nfrequency-dependent material properies. ( MatProp  is \na very simple class, implemented by the  libmatprop  submodule of  scuff-em , for\nhandling frequency-dependent material properties.)  RWGGeometry  always starts off with a single \nregion (region  0 ) with label  Exterior  \nand the material properties of vacuum. \nEach  REGION  statement in the .scuffgeo  file \nthen creates a new region, starting with region  1. \n(This is true unless the label specified to the  REGION \nkeyword is  Exterior,  in which case the \nstatement just redefines the material properties of region  0 .)\nEach  OBJECT...ENDOBJECT  section in the  .scuffgeo \nfile also creates a single new region (for the interior of the object).  Regions in a geometry are separated from one another by surfaces.\nEach surface is described by a C++ class named  RWGSurface. \nThe  RWGGeometry  class maintains an internal array of  RWGSurfaces:  class RWGGeometry \n   { \n      ... \n      int NumSurfaces;\n      RWGSurface **Surfaces;\n      ... \n   };   Each  OBJECT...ENDOBJECT  or  SURFACE...ENDSURFACE \nsection in the  .scuffgeo  file adds a new  RWGSurface \nstructure to the geometry. (Note that, in  scuff-em  \nparlance, an \"object\" is just a special case of a surface in which the \nsurface is  closed. )   The  RWGSurface  class is again slightly\ntoo complicated to list in full here, but we will discuss its most salient \nfields and methods. Among these are the  RegionIndices  field:   class RWGSurface\n   { \n      ... \n      int RegionIndices[2];\n      ... \n   };   These two integers are the indices of the regions on the two sides of the \nsurface. The  first  region ( RegionIndex[0] ) is \nthe  positive  region for the surface; this means that the electric\nand magnetic surface currents on the surface contribute to the fields \nin that region with a positive sign. The second region \n( RegionIndex[1] ) is the  negative  region; currents \non the surface contribute to the fields in that region with a negative\nsign.  Another way to think of this is that the surface normal vector  n  points  away from   RegionIndex[1]  \nand  into   RegionIndex[0] .", 
            "title": "1. Geometries, Regions, Surfaces"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#2-panels-edges-vertices", 
            "text": "The mesh describing each surface in a geometry is structure is analyzed \ninto lists of  vertices , triangular  panels,  and panel  edges.  Several internal data fields in the  RWGSurface \nclass are devoted to storing this information.   class RWGSurface\n{ \n  ... \n  int NumVertices;\n  double *Vertices;\n\n  int NumPanels;\n  RWGPanel **Panels;\n\n  int NumEdges;            \n  RWGEdge **Edges;\n  ... \n\n};  Here  Vertices  is an array of  3*NumVertices   double  values in which the cartesian coordinates of each \nvertex are stored one after another. Thus, the  x, y, z  \ncoordinates of the  nv th vertex are  Vertices[3*nv+0], Vertices[3*nv+1], Vertices[3*nv+2].  Panels  and  Edges  are arrays of pointers\nto specialized data structures for storing geometric data.", 
            "title": "2. Panels, Edges, Vertices"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#the-rwgpanel-and-rwgedge-structures", 
            "text": "The elemental data structure in the  scuff-em \ngeometry hierarchy is  RWGPanel . Each instance of this structure\ndescribes a single triangular panel in the mesh discretization of an  RWGSurface.    RWGPanel  definition   typedef struct RWGPanel\n { \n   int VI[3];            /* indices of vertices in Vertices array */\n   int EI[3];            /* indices of edges in Edges array */\n\n   double Centroid[3];   /* panel centroid */\n   double ZHat[3];       /* normal vector */\n   double Radius;        /* radius of enclosing sphere */\n   double Area;          /* panel area */\n\n   int Index;            /* index of this panel within RWGSurface */\n\n } RWGPanel;  Here the elements of the  VI  array are the indices of the \nthree panel vertices within the list of vertices for the given  RWGSurface.  The  Index  field in  RWGPanel \nindicates that panel's index within the  Panels  array \nof the parent  RWGSurface.  The remaining fields tabulate some useful\ngeometric data on the panel.  In addition to an  RWGPanel  structure for each triangle \nin the surface mesh, we also create an  RWGEdge  structure\nfor each panel  edge.    RWGEdge  definition   typedef struct RWGEdge \n { \n   int iV1, iV2, iQP, iQM;  /* indices of panel vertices (iV1 lt;iV2) */\n   double Centroid[3];      /* edge centroid */\n   double Length;           /* length of edge */\n   double Radius;           /* radius of enclosing sphere */\n\n   int iPPanel;             /* index of PPanel within RWGSurface (0..NumPanels-1)*/\n   int iMPanel;             /* index of MPanel within RWGSurface (0..NumPanels-1)*/\n   int PIndex;              /* index of this edge within PPanel (0..2)*/\n   int MIndex;              /* index of this edge within MPanel (0..2)*/\n   int Index;               /* index of this edge within RWGSurface (0..NumEdges-1)*/\n\n   RWGEdge *Next;           /* pointer to next edge in linked list */\n\n } RWGEdge;  The  iQP, iV1, iV2, iQM  fields here are indices into the \nlist of vertices for the parent  RWGSurface.   iV1  and  iV2  are the actual endpoints of the edge. iQP  and  iQM  denote respectively the current source  and  sink  vertices for the RWG basis function corresponding\nto this edge.  iPPanel  and  iMPanel  are the indices (into the  Panels  array of the parent  RWGSurface ) of the  positive  and  negative  panels associated with the edge.\n(The positive panel is the one from which the RWG current emanates; \nits vertices are  iQP, iV1, iV2. \nThe negative panel is the one into which the RWG current is sunk;\nits vertices are  iQM, iV1, iV2. ) \nThe  iPPanel  and  iMPanel  fields take values\nbetween  0  and  NumPanels-1 , where  NumPanels  is defined in the parent  RWGSurface.  PIndex  and  MIndex  are the indices of the edge \nwithin the positive and negative  RWGPanel s.\n(The index of an  edge  within a panel is defined as the index \nwithin the panel of the panel  vertex  opposite that edge; the \nindex of a vertex is its position in the  VI  array in the  RWGPanel  structure.)  The  Index  field of  RWGEdge  is the index of \nthe structure within the  Edges  array of the parent  RWGSurface.  The remaining fields store some geometric data on the edge.\nThe  Centroid  field stores the cartesian coordinates\nof the midpoint of the line segment between vertices  V1 \nand  V2 .  Here's an example of two panels (panel indices  17  and  39 ) in a surface mesh, and a single \nedge (edge index  24 ) shared between them. \nPanel  17  is the positive panel for the edge, \nwhile panel  39  is the negative panel for the edge; the corresponding\ndirection of current flow is indicated by the arrows.\nThe larger red numbers near the vertices are the indices of those\nvertices in the  Vertices  array. \nThe smaller magenta and cyan numbers are the indices of the vertices \nwithin the  VI  arrays in the two  RWGPanels .\n(The other four edges of this panel pair would also have corresponding  RWGEdge  structures; these are not shown in the figure.)", 
            "title": "The RWGPanel and RWGEdge structures"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#3-assembling-the-bem-matrix", 
            "text": "The  RWGGeometry  class contains a hierarchy of \nroutines for assembling the BEM matrix. If you are simply\nusing the code to solve scattering problems, you will\nonly ever need to call the top-level routine  AssembleBEMMatrix  or perhaps the \nsecond-highest-level routine,  AssembleBEMMatrixBlock. \nHowever, developers of surface-integral-equation methods \nmay wish to access the lower-level routines for \ncomputing the interactions of individual RWG basis functions\nor for computing certain integrals over triangular regions.", 
            "title": "3. Assembling the BEM Matrix"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#assemblebemmatrix", 
            "text": "The top-level matrix assembly routine is  AssembleBEMMatrix.  This routine loops over \nall unique pairs of  RWGSurfaces  in the geometry. \nFor each unique pair \nof surfaces, the routine calls  AssembleBEMMatrixBlock  \nto assemble the subblock of the BEM matrix corresponding to a single \npair of  RWGSurfaces,  then stamps this subblock \ninto the appropriate place in the overall BEM matrix.   For example, if a geometry contains three  RWGSurfaces ,\nthen its overall BEM matrix has the block structure   where the  \\mathbf{M}__{ij}  subblock describes the\ninteractions of surfaces  i  and  j .\nIn this case  AssembleBEMMatrix  proceeds by making 6 calls\nto  AssembleBEMMatrixBlock , one for each of the \ndiagonal and above-diagonal blocks. (The below-diagonal\nblocks are related to their above-diagonal counterparts by \nsymmetry.)", 
            "title": "AssembleBEMMatrix"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#assemblebemmatrixblock", 
            "text": "AssembleBEMMatrixBlock  computes the subblock of the \nBEM matrix corresponding to a single pair of  RWGSurface s.\nFor compact (non-periodic) geometries, this amounts to making just\na single call to  SurfaceSurfaceInteractions . For \nperiodic geometries, this involves making multiple calls to  SurfaceSurfaceInteractions  in which one of the two \nsurfaces is displaced through various lattice vectors  L  to account\nfor the contribution of periodic images.   The contribution of the \nmatrix subblock computed by  SurfaceSurfaceInteractions \nwith displacement vector  L  is weighted in the overall\nBEM matrix by a Bloch phase factor   e^{i\\mathbf{k}\\cdot \\mathbf{L}} \nwhere  k  is the Bloch wavevector, i.e. we have    where the  L  superscript indicates that the corresponding\nmatrix subblock is to be computed with one of the two surfaces \ndisplaced through translation vector  L .", 
            "title": "AssembleBEMMatrixBlock"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#surfacesurfaceinteractions", 
            "text": "SurfaceSurfaceInteractions  loops over all  RWGEdge \nstructures on each of the two surfaces it is considering.\nFor each pair of edges, it calls  EdgeEdgeInteractions \nto compute the inner products of the RWG basis functions\nwith the  G  and  C  dyadic Green's functions\nfor each of the material regions through which the two surfaces\ninteract. (Surfaces may interact through 0, 1, or 2 material \nregions.)\nThen it stamps these values into their appropriate places\nin the BEM matrix subblock.   For example, if we have surfaces  S  and  S  that \ninteract through a single dielectric medium, the structure of \nthe corresponding matrix subblock is   where e.g.  b m  is the  m th basis function on surface  S . \nThe kernels\nhere are scalar multiples of the  G  and  C \ndyadics:   where  k ,  Z  are the wavenumber and (absolute)\nwave impedance of the dielectric medium at the frequency\nin question.  The matrix structure above is for the case of two surfaces\ninteracting through a single material region (for example, S  and  S \nmight be the outer surfaces of two compact objects embedded \nin vacuum or in a homogeneous medium, in which case the \nsurfaces interact only throught that medium).\nIf the surfaces interact through  two  material regions\n(for example, if we have  S = S \nand we are computing the self-interaction of the outer\nsurface of a dielectric object embedded in vacuum) then\neach matrix entry is actually a sum of  two  \ninner products, one involving the   kernels for \nthe interior medium and one involving the kernels for \nthe exterior. (If the surfaces are PEC, then the dimension\nof the matrix is halved with only the  EE  terms\nretained.)", 
            "title": "SurfaceSurfaceInteractions"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#edgeedgeinteractions", 
            "text": "EdgeEdgeInteractions  considers a pair of RWG basis\nfunctions and computes the inner products of these basis functions\nwith the  G  and  C  dyadic Green's functions for a \nsingle material medium. Because each basis function is supported\non two triangles, the full inner products involve sums of four\ntriangle-pair contributions:   Here  l m ,l n  are the lengths of the\ninterior edges to which the RWG basis functions are associated, and\neach of the four terms in the sum is a four-dimensional integral \nover a single pair of panels, computed by  PanelPanelInteractions.", 
            "title": "EdgeEdgeInteractions"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#panelpanelinteractions", 
            "text": "PanelPanelInteractions  is the lowest-level routine in the  scuff-em  BEM matrix assembly hierarchy.\nThis routine computes the individual terms in equation (1) above,\ni.e. the contributions of a single pair of panels\nto the inner products of two RWG basis functions with the  G  and  C  dyadic Green's functions:   Note that the RWG basis-function prefactor  l/2A  is broken\nup into two factors between equations (1) and (2): the  1/2A \npart is included in the panel-panel integrals (2), while \nthe  l  part is included when summing the four panel-panel\ncontributions in equation (1) to obtain the overall inner product.   If the panels are far away from each other,  PanelPanelInteractions  \nuses low-order four-dimensional numerical cubature to compute the full\ninteractions. Otherwise,  PanelPanelInteractions  uses\nlow-order four-dimensional numerical cubature to compute the interactions\nwith  singularity-subtracted versions  of the  G  and  C  \nkernels, then adds the contributions of the singular terms after \nlooking them up in an internally-stored cache.", 
            "title": "PanelPanelInteractions"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#4-an-explicit-low-level-example", 
            "text": "Here's a worked example of a matrix-element computation in a  scuff-em  run.", 
            "title": "4. An Explicit Low-Level Example"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#the-geometry-and-the-labeling-of-panels-edges-and-vertices", 
            "text": "We'll consider a\nscattering geometry consisting of a single cube of dielectric\nmaterial, with side length  L= 1  m, discretized into \ntriangles with minor side length  L/10 , yielding a total\nof 1200 triangles, 1800 interior edges, and 3600 RWG basis \nfunctions (1800 each for electric and magnetic currents) \nfor a dielectric geometry. The  gmsh  geometry file for this example is  Cube_N.geo ,\nthe  gmsh  mesh file produced by running gmsh -2 Cube_N.geo  is Cube_10.msh ,\nand a  scuff-em  geometry file describing\na geometry consisting of this discretized cube with interior dielectric\npermittivity  =4 is DielectricCube.scuffgeo .   For low-level work it is convenient to have data on the internal \nindices that  scuff-em  assigns to \npanels, vertices, and edges when it reads in a geometry file.\nWe get this by running  scuff-analyze  on the mesh file\nin question with the  --WriteGMSHLabels  options:   % scuff-analyze --mesh Cube_10.msh --WriteGMSHFiles --WriteGMSHLabels  This produces a file named  Cube_10.pp , which we open in  gmsh  to produce a graphical depiction of \nthe labeling of panels, edges, and vertices. Zooming in on the region\nnear the origin, we will focus on the two panels lying closest to the \norigin in the  xy  plane; we see that  scuff-em  has assigned these two panels\npanel indices  0  and  1 , respectively, while\nthe edge they share has been assigned interior-edge index  0 .", 
            "title": "The geometry and the labeling of panels, edges, and vertices"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#rwg-basis-function-b0", 
            "text": "Here's a schematic depiction of the panels that comprise the\nbasis function  b 0  associated with interior edge 0 :   In this diagram, the edge length is  L =0.1,  O  denotes \nthe origin of coordinates, and the vertices marked  Q  are the\nsource and sink vertices for the current distribution. \nThe RWG basis function  b 0  associated with \ninterior edge 0 is    where the RWG basis function edge length is  l = 2 L \nand the panel areas are  A 0 =A 1 = L 2 /2.\nNote that  P 0  and P 1  are respectively the positive and negative\npanels associated with basis function  b 0 .", 
            "title": "RWG basis function b0"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#panel-panel-interactions", 
            "text": "Here's a  C++  code snippet that computes the \nquantities  G 00 ++  \nand  G 00 +-  in equation (1a)\nabove, i.e. the contributions of the positive-positive \nand positive-negative panel pairs to the inner product of  b 0  with itself through the  G  kernel,\nwith the wavenumber set to  k= 1.0;\nJust to be totally explicit, the numbers that are being \ncomputed here are   \n // read in geometry from .scuffgeo file\n RWGGeometry *G = new RWGGeometry( DielectricCube.scuffgeo );\n RWGSurface *S = G- Surfaces[0];\n\n // initialize an argument structure for GetPanelPanelInteractions\n GetPPIArgStruct MyPPIArgs, *PPIArgs= MyPPIArgs;\n InitGetPPIArgs(PPIArgs);\n PPIArgs- Sa = PPIArgs- Sb = S;\n PPIArgs- k = 1.0;\n\n // fill in arguments to compute the positive-positive panel pair\n PPIArgs- npa = 0;\n PPIArgs- iQa = 1;\n PPIArgs- npb = 0;\n PPIArgs- iQb = 1;\n GetPanelPanelInteractions(PPIArgs);\n printf( G++ = %e + %ei\\n ,real(PPIArgs- H[0]),imag(PPIArgs- H[0]));\n\n // fill in arguments to compute the positive-negative panel pair\n PPIArgs- npa = 0;\n PPIArgs- iQa = 1;\n PPIArgs- npb = 1;\n PPIArgs- iQb = 2;\n GetPanelPanelInteractions(PPIArgs);\n printf( G++ = %e + %ei\\n ,real(PPIArgs- H[0]),imag(PPIArgs- H[0]));  This code produces the following output:  G++ = -3.189105e+00 + -7.950381e-02i\nG+- = -1.537561e+00 + -7.956272e-02i  Notice that, to compute a panel-panel interaction, you allocate\nand initialize an instance of a data structure called  GetPPIArgs . This structure contains a large \nnumber of fields which in many cases can be set to default \nvalues; to ensure that these fields are properly initialized,\nalways call  InitGetPPIArgs()  on an newly-allocated\ninstance of  GetPPIArgs .  Then, you fill in the appropriate fields of this structure \nto specify the two panels over which you want to integrate.\nSpecifically, the fields  Sa ,  npa \nspecify the first panel (the  npa th  RWGPanel \nin the  Panels  array for surface  Sa ), \nwhile the field  iQa  (an integer in the range  0..2 )\nidentifies the index of the  Q  vertex (RWG current source/sink\nvertex) within the three vertices of the panel. \nThe fields  Sb ,  npb , and  iQb \nsimilarly identify the second panel and source/sink vertex.\nInitialize the  k  field in the  GetPPIArgs  structure to the wavenumber parameter\nin the Helmholtz kernel. ( k  may be complex or purely imaginary.)", 
            "title": "Panel-panel interactions"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#edge-panel-interactions", 
            "text": "Here's a  C++  code snippet that computes the \nfull basis-function inner product   b 0  |  G  |  b 0   \nin equation (1a) above.   GetEEIArgStruct MyEEIArgs, *EEIArgs= MyEEIArgs;\n InitGetEEIArgs(EEIArgs);\n EEIArgs- Sa = EEIArgs- Sb = S;\n EEIArgs- nea = EEIArgs- neb = 0;\n EEIArgs- k = 1.0;\n GetEdgeEdgeInteractions(EEIArgs);\n printf( lt;b|G|b gt; = %e + %ei\\n ,real(EEIArgs- GC[0]),imag(EEIArgs- GC[0]));  Note that, similar to the case of  GetPanelPanelInteractions \ndiscussed above, the call to  GetEdgeEdgeInteractions  takes as\nargument a pointer to a struct of type  GetEEIArgStruct .\nAs before, you should always call  InitGetEEIArgs  \nto initialize this structure, then set whichever fields you \nneed to specify.\nIn this case, the only fields we need to set are  Sa,Sb  (indices of the  RWGSurface ),  nea,neb  \n(indices of the interior edges in the  Edges  array \ncorresponding to the RWG basis functions), and  k  \n(wavenumber parameter in the Helmholtz kernel). \nThe result of this code snippet is    b|G|b  = -6.606176e-02 + 2.356554e-06i  Using equation (1a) above, we can understand this result in conjunction \nwith the results printed out above for  G++  and  G+- . For this particular basis function, only two \nof the four panel-panel interactions on the RHS of equation (1a) \nhave distinct values (because the two panels that comprise the \nbasis function have the same shapes and areas, so we have G-+ = G+-  and  G-- = G++ ), and the \nedge-length prefactors  l m ,  l n  \nboth have value 0.1 2. Thus for this case \nequation (1a) reads    b 0  |  G  |  b 0   \n=2 0.02 ( G++ - G+- )  and, indeed, plugging in the numbers printed out above, we find  {6.6e-02, 2.4e-06i} \n= 2 0.02 ( {-3.19,-7.95e-2i} - {-1.54,7.96e-2i} ).", 
            "title": "Edge-panel interactions"
        }, 
        {
            "location": "/forDevelopers/Documentation/", 
            "text": "The \nscuff-em\n documentation system\n\n\nThe documentation for \nscuff-em\n is maintained in the form\nof plain-text (markdown) files stored in the \ndoc\n subdirectory\nof the \nscuff-em\n repository. These files are processed by\nthe wonderful open-source \nMkDocs\n system\nto build the web-based documentation hierarchy.\n\n\nA major reason for this choice of documentation system is to\nmake it easy for \nscuff-em\n users to edit the existing \ndocumentation and to contribute new documentation. If you \ndiscover incorrect or incomplete portions of the documentation,\nor if you would like to add new documentation, please consider\ncontributing to \nscuff-em\n by making the relevant changes\nin the \ndoc\n subdirectory of your \nscuff-em\n repository,\nthen \nsubmitting a pull request on GitHub.\n\n\nBuilding and serving your own local copy of the documentation\n\n\nIt's easy to build your own local copy of the entire \nscuff-em\n\ndocumentation hierarchy, which you can then view offline.\nThis allows you to access the documentation without Internet \naccess, and also to preview any changes you might make to\nthe documentation before submitting them in the form of a pull\nrequest.\n\n\nOne-time only setup operations\n\n\nTo build the \nscuff-em\n documentation, you will need a \npython\n\ninstallation on your system, and you will need the \nmkdocs\n and \n\npython-markdown-math\n packages. On my system I was able to \ninstall these using the following commands:\n\n\n% sudo pip install mkdocs\n% sudo pip install --upgrade pyinotify\n% git clone https://github.com/mitya57/python-markdown-math.git\n% cd python-markdown-math \n% python setup.py build\n% sudo python setup.py install\n\n\n\n\nBuilding the documentation\n\n\nTo build the documentation, starting from the top-level\ndirectory of your \nscuff-em\n repository, simply say\n\n\n% cd doc\n% mkdocs build\n\n\n\n\nThis will create the HTML hierarchy in the subdirectory\n\ndoc/site.\n\n\nServing the documentation\n\n\nA wonderfully convenient feature provided by MkDocs is the\nability to serve your local version of the documentation \nlocally to a web browser running on your machine, without\nhaving to mess around with configuring apache or any other\nwebserver software. To do this, starting from the \ndoc\n \nsubdirectory of the \nscuff-em\n repository you simply go\nlike this:\n\n\n% cd doc\n% mkdocs serve\n\n\n\n\nThen direct your favorite web browser to the site\n\n127.0.0.1:8000\n, i.e.\n\n\n% google-chrome 127.0.0.1:8000\n\n\n\n\nThis should pull up the top-level page of the \nscuff-em\n\ndocumentation tree, with internal links pointing to \nyour local copies of the various pages.\n\n\nThe great thing about this is that, whenever you save changes \nto a file in the \ndoc\n subdirectory of your \nscuff-em\n \nrepository, the documentation is automatically rebuilt and\nthe webserver automatically refreshed. This allows you to\nedit the \nscuff-em\n documentation in WYSIWIG fashion, \nsimply by working on an \n.md\n file in a text editor in one window,\nwhile having a web browser open to the corresponding subpage\nof \n127.0.0.1:8000\n in another window. Then, every time\nyou save changes to the text file, the web page is automatically\nupdated! I love this brilliant system.", 
            "title": "Documentation"
        }, 
        {
            "location": "/forDevelopers/Documentation/#building-and-serving-your-own-local-copy-of-the-documentation", 
            "text": "It's easy to build your own local copy of the entire  scuff-em \ndocumentation hierarchy, which you can then view offline.\nThis allows you to access the documentation without Internet \naccess, and also to preview any changes you might make to\nthe documentation before submitting them in the form of a pull\nrequest.", 
            "title": "Building and serving your own local copy of the documentation"
        }, 
        {
            "location": "/forDevelopers/Documentation/#one-time-only-setup-operations", 
            "text": "To build the  scuff-em  documentation, you will need a  python \ninstallation on your system, and you will need the  mkdocs  and  python-markdown-math  packages. On my system I was able to \ninstall these using the following commands:  % sudo pip install mkdocs\n% sudo pip install --upgrade pyinotify\n% git clone https://github.com/mitya57/python-markdown-math.git\n% cd python-markdown-math \n% python setup.py build\n% sudo python setup.py install", 
            "title": "One-time only setup operations"
        }, 
        {
            "location": "/forDevelopers/Documentation/#building-the-documentation", 
            "text": "To build the documentation, starting from the top-level\ndirectory of your  scuff-em  repository, simply say  % cd doc\n% mkdocs build  This will create the HTML hierarchy in the subdirectory doc/site.", 
            "title": "Building the documentation"
        }, 
        {
            "location": "/forDevelopers/Documentation/#serving-the-documentation", 
            "text": "A wonderfully convenient feature provided by MkDocs is the\nability to serve your local version of the documentation \nlocally to a web browser running on your machine, without\nhaving to mess around with configuring apache or any other\nwebserver software. To do this, starting from the  doc  \nsubdirectory of the  scuff-em  repository you simply go\nlike this:  % cd doc\n% mkdocs serve  Then direct your favorite web browser to the site 127.0.0.1:8000 , i.e.  % google-chrome 127.0.0.1:8000  This should pull up the top-level page of the  scuff-em \ndocumentation tree, with internal links pointing to \nyour local copies of the various pages.  The great thing about this is that, whenever you save changes \nto a file in the  doc  subdirectory of your  scuff-em  \nrepository, the documentation is automatically rebuilt and\nthe webserver automatically refreshed. This allows you to\nedit the  scuff-em  documentation in WYSIWIG fashion, \nsimply by working on an  .md  file in a text editor in one window,\nwhile having a web browser open to the corresponding subpage\nof  127.0.0.1:8000  in another window. Then, every time\nyou save changes to the text file, the web page is automatically\nupdated! I love this brilliant system.", 
            "title": "Serving the documentation"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/", 
            "text": "Computation of Singular Integrals in \nscuff-em\n\n\n\nA key feature of \nscuff-em\n is an accurate and \nefficient code for computing singular four-dimensional integrals over pairs \nof triangles.\nThe algorithm that \nscuff-em\n\nuses for this purpose---which I call the \"generalized Taylor-Duffy method\"\nin honor of the progenitors of some earlier methods that inspired it---is\ndiscussed in detail in\nthis paper:\n\n\n\n\n\n\n``Generalized Taylor\u2013Duffy Method for Efficient Evaluation of \n    Galerkin Integrals in Boundary-Element Method Computations'',\n    \nIEEE Transactions on Antennas and Propagation\n\n    \n63\n 195 (2015). \n\n\nDOI: \n10.1109/TAP.2014.2367492\n\n\nArXiV: \nhttp://arxiv.org/abs/1312.1703\n.\n\n\n\n\n\n\nThe code that evaluates singular integrals is packaged\nwith the \nscuff-em\n distribution;\nit is contained in a single \nC++\n file named\n\nTaylorDuffy.cc\n (around 1,500 lines).\nThis code calls the \npcubature\n code from \n\nSteven G. Johnson's numerical cubature package.\n\n\nThis page is intended for developers who would like \nto use the \nscuff-em\n implementation of the generalized Taylor-Duffy\nmethod in their own codes.\n\n\nTable of Contents\n\n\n1. What the code actually computes\n\n\n2. C++ calling convention\n\n\nThread Safety\n\n\nFields in TaylorDuffyArgStruct\n\n\nValues of the PIndex field\n\n\nValues of the KIndex field\n\n\n\n\n\n\n3. Simple demonstration program\n\n\n\n\n\n\n1. What the code actually computes\n\n\nThe code provides a \nC++\n function named \nTaylorDuffy\n\nwhich computes the following four-dimensional integral over a triangle-product\ndomain:\n\n \\mathcal{I}=\n   \\frac{1}{4AA^\\prime}\n   \\int_{\\mathcal T} \\, d\\mathbf x \\, \n   \\int_{\\mathcal T^\\prime} \\, d\\mathbf x^\\prime \\,\n   P\\big(\\mathbf x, \\mathbf x^\\prime\\big) K\\big(|\\mathbf x-\\mathbf x^\\prime|\\big)\n   \\qquad (1)\n\n\n\n\n\nIn this expression,\n\n\n\n\n\n\n\\mathcal T\n and \n\\mathcal T^\\prime\n are \n  triangles with at least one common vertex.\n  (You supply to \nTaylorDuffy\n the cartesian coordinates\n  of the triangle vertices.)\n\n\n\n\n\n\n\n\nP\n is a polynomial function of 6 variables (the Cartesian\n  components of \nx,x'\n). Although the underlying algorithm works \n  for arbitrary polynomials \nP\n, in the implementation of \n  \nTaylorDuffy\n provided below you will select one of \n  a predetermined set of possible polynomials (see below).\n  Modifying the code to support other polynomials would be \n  a relatively straightforward, if tedious, task.\n\n\n\n\n\n\n\n\nK\n is a \nkernel\n function of a single scalar variable\n  \nr.\n Although the algorithm works for a fairly wide family of \n   kernel functions, in the implementation of \nTaylorDuffy\n\n   provided below you will select one of a predetermined set of \n   possible kernels (see below). Again, it should be relatively \n   straightforward to modify the code to support other kernels.\n\n\n\n\nActually, it is more accurate to say that \nTaylorDuffy\n \n   computes \nmultiple\n simultaneous integrals of the form (1);\n   in a single call to \nTaylorDuffy\n you can specify, for \n   the same triangle pair \nT,T'\n, more than one \n   (polynomial, kernel) pair, i.e. \n   \n{P\nn\n, K\nn\n}\n \n   for \nn=1,2,...,N\n, and \n   \nTaylorDuffy\n will compute all \nN\n integrals at once.\n   This is faster than making \nN\n separate calls due to the \n   reuse of computational overhead.\n\n\n2. C++ calling convention\n\n\nThe \nTaylorDuffy\n routine has many input\narguments (many of which may be set to default values)\nand multiple output values. For this reason, instead\nof the typical calling convention in which you specify\nmultiple input arguments to a \nC++\n function\nand get back a single output value,\n\nTaylorDuffy\n accepts as its argument a\n(pointer to a) single big argument \nstructure\n.\n\n\nThus, within a \nC/C++\n program, \nto evaluate one or more integrals of the form (1) for a given\npair of triangles you will \n\n\n\n\n\n\ninstantiate and initialize a data structure of type \nTaylorDuffyArgStruct\n, which stores all input and output arguments, and then \n\n\n\n\n\n\nsimply call \nTaylorDuffy()\n with a pointer to your argument structure as the only parameter. On return, the results (the values of the integral) will be stored in the argument structure.\n\n\n\n\n\n\nThe process looks like this: \n\n\n // instantiate and initialize argument structure \n TaylorDuffyArgStruct MyTDArgs, *TDArgs=\nMyTDArgs;\n InitTaylorDuffyArgs(TDArgs); // always call this!\n\n // fill in necessary fields \n TDArgs-\nWhichCase = TD_COMMONVERTEX\n TDArgs-\nNumPKs    = 1; \n ...\n\n // evaluate the integral\n TaylorDuffy(TDArgs);\n\n // results are now available inside TDArgs\n printf(\nResult: %e \\n\n, real(TDArgs-\nResult[0]) );\n\n\n\n\nThread Safety\n\n\nTaylorDuffy()\n is thread-safe; you may call it \nfrom multiple simultaneously-executing threads without fear\nof crosstalk or race conditions. (Indeed, \n\nscuff-em\n does just this if compiled\nwith support for \nopenmp\n\nor \npthreads\n.)\n\n\nFields in \nTaylorDuffyArgStruct\n\n\nThe table below details all fields in the argument structure\npassed to \nTaylorDuffy.\n\n\nIn general, you should always call \nInitTaylorDuffyArgs\n\nfirst to set all optional fields to default values, then fill in \nyour desired values for mandatory fields (and overwrite the default\nvalues for any optional fields you wish to tweak).\n\n\n\n\n    \n\n    \n\n      \n Field \n\n      \n Description \n\n    \n\n\n    \n\n    \n \n       \n \n           \nMandatory input fields describing the triangles\n\n       \n \n    \n\n\n    \n\n    \n\n      \n \nint WhichCase;\n \n\n      \n Counts the number of common vertices between the \n           two triangles. You should set this to 1, 2, or 3 \n           for the common-vertex, common-edge, or common-triangle\n           cases. (The file \nTaylorDuffy.h\n defines\n           the constants \n           \nTD_COMMONVERTEX=1\n,\n           \nTD_COMMONEDGE=2\n,\n           \nTD_COMMONTRIANGLE=3\n).\n      \n\n    \n\n\n    \n\n    \n\n      \n \n\n            \ndouble *V1, *V2, *V3;\n\n            \ndouble *V2P, *V3P;\n\n           \n\n      \n\n      \n Pointers to caller-allocated arrays of length 3 \n           containing the \nx,y,z\n coordinates of the \n           triangle vertices.\n\n           \n\n           \nV1, V2, V3\n are the vertices of triangle \n           \nT\n. For example, \nV2[0,1,2]\n\n           are the \nx,y,z\n coordinates of the \n           second vertex.\n\n           \n\n           \nV2P, V3P\n are the vertices of triangle\n           \nT'\n that are \nnot\n shared with triangle \n           \nT\n. It is not always necessary to initialize \n           these fields. In particular,\n\n           \n\n            \n\n            \n In the common-triangle case (\nWhichCase=3\n),\n                 neither \nV2P\n nor \nV3P\n\n                 is referenced.\n            \n In the common-edge case (\nWhichCase=2\n),\n                 only \nV3P\n is referenced; \nV2P\n\n                 is ignored.\n            \n In the common-vertex case (\nWhichCase=1\n),\n                 both \nV2P\n and \nV3P\n\n                 are referenced.\n            \n\n\n      \n\n    \n\n\n    \n\n    \n \n       \n \n           \nMandatory input fields describing the \nP\n \n              and \nK\n functions\n\n       \n\n    \n\n\n    \n\n    \n\n      \n \n\n            \nint NumPKs;\n\n            \nint *PIndex;\n\n            \nint *KIndex;\n\n            \nint *KParam;\n\n           \n\n      \n\n      \n \n           \n\n           \nNumPKs\n specifies the number of \n           integrals of the form (1) you wish to compute \n           (that is, the number of pairings of a polynomial\n           \nP\n with a kernel \nK\n) for the given\n           pair of triangles.\n           If you only need to compute a single integral,\n           set \nNumPKs=1.\n\n\n           \n\n           \nPIndex\n and \nKIndex\n \n           are pointers to caller-allocated arrays\n           of length \nNumPKs\n. The \nn\nth\n           entries in these arrays are the indices \n           (in the tables below) of the \n           \nn\nth \nP\n and \nK\n\n           functions.\n\n           \n\n           \nKParam\n is a pointer to a \n           caller-allocated array of length\n           \nNumPKs\n containing values of \n           certain parameters that enter the kernel\n           functions. The entries of this array are \n           interpreted in different ways depending on \n           the corresponding entries in the \n           \nKIndex\n array:\n\n           \n\n            \n If \nKIndex[n]==TD_RP\n \n                 (the \nr\np\n kernel),\n                 then \nKParam[n]\n is\n                 interpreted as the parameter \np\n,\n                 i.e. the integer power to which \nr\n\n                 is raised. (The \ncdouble-\nvalued\n                 quantity\n                 \nKParam[n]\n is converted to\n                 \nint\n inside \nTaylorDuffy.\n)\n            \n \n                 For all other kernels,\n                 \nKParam[n]\n is interpreted as \n                 the parameter \nk\n, i.e. the \n                 Helmholtz wavenumber. This quantity can\n                 be purely real, purely imaginary, or complex.\n           \n\n      \n \n    \n\n\n    \n\n    \n \n       \n \n           \nInput fields that are required for certain \n              \nP\n functions\n\n       \n\n    \n\n\n    \n\n    \n\n      \n \ndouble *Q, *QP;\n\n      \n\n      \n Pointers to caller-allocated arrays of length 3 \n           containing the \nx,y,z\n coordinates of the \n           RWG source/sink vertices \nQ,Q'\n. These are \n           only referenced if any entry in the \nPIndex\n\n           array corresponds to one of the polynomials in the \n           table below whose definition involves \nQ,Q'.\n\n      \n\n    \n\n\n    \n\n    \n\n      \n \ndouble *nHat;\n\n      \n\n      \n Pointers to caller-allocated arrays of length 3 \n           containing the \nx,y,z\n components of the \n           unit normal vector \nn\n. This is only referenced\n           if any entry in the \nPIndex\n array \n           corresponds to one of the polynomials in the \n           table below whose definition involves \nn.\n\n      \n\n    \n\n\n    \n\n    \n \n       \n \n           \nOptional input fields controlling integration behavior \n           \n\n       \n\n    \n\n\n    \n\n    \n\n      \n \ndouble AbsTol, RelTol;\n\n      \n\n      \n The absolute and relative error tolerances to which\n           the adaptive integrator will attempt to compute \n           the integral. (The defaults are \nAbsTol=0.0\n\n           and \nRelTol=1.0e-10\n.) \n      \n\n    \n\n\n    \n\n    \n\n      \n \nint MaxEval;\n\n      \n\n      \n An upper bound on the number of function samples\n           the adaptive integrator may compute. (The default \n           is \nMaxEval=1000.\n) Reducing this \n           number will cause the code to run more quickly,\n           possibly at the expense of lower accuracy.\n      \n\n    \n\n\n    \n\n    \n \n       \n \n           \nOutput fields \n           \n\n       \n\n    \n\n\n    \n\n    \n\n      \n \ncdouble *Result, *Error;\n\n      \n\n      \n Pointers to caller-allocated output buffers \n           with enough space to store \nNumPKs\n \n           values of type \ncdouble\n. On return,\n           \nResult[n]\n is the value of the \n           integral for the \nn\nth \nP,K\n pairing,\n           and \nError[n]\n is an estimate of \n           the error incurred by the numerical quadrature.\n      \n\n    \n\n\n    \n\n    \n\n      \n \nint nCalls;\n \n      \n\n      \n The number of function evaluations used to evaluate\n           the numerical cubature.\n           This number will not exceed \nMaxEval.\n\n      \n\n    \n\n\n\n\n\n\nValues of the \nPIndex\n field\n\n\nThe implementation of \nTaylorDuffy\n provided here\ncontains support for the following choices of the \nP\n\npolynomial in equation (1). (The values of the \nPIndex\n\nfield here are constants defined in \nTaylorDuffy.h\n.)\n\n\n\n\nIn this table, the quantities \nQ, Q', n\n are vector-valued\nparameters that you specify by setting fields in the argument\nstructure for the \nTaylorDuffy\n routine (see above).\nAlso, in the final three table entries, the tilde symbol above\na vector-valued quantity indicates the result of crossing that\nquantity with the normal vector you specify via the \nnHat\n \nfield in the argument structure (see above):\n\n\n\n\n\n\\widetilde{\\mathbf x} \\equiv \\mathbf{\\hat n} \\times \\mathbf x, \\qquad \n\\widetide{\\mathbf Q} \\equiv \\mathbf{\\hat n} \\times \\mathbf Q\n\n\n\n\n\nFor RWG basis-function enthusiasts, note that the last 5 entries \nin the table are appropriate for computing matrix elements of the \nEFIE and MFIE operators between RWG basis functions, but observe\ncarefully that the prefactor \n\\frac{1}{4AA'}\n in the definition (1)\nis only \npart\n\nof the full prefactor that arises for RWG basis functions; there \nis also a factor \nll'\n (product of edge lengths) \nwhich is missing from these calculations, and you must put that \nin yourself, by hand.\n\n\nValues of the \nKIndex\n field\n\n\nThe implementation of \nTaylorDuffy\n provided here\ncontains support for the following choices of the \nK\n\nkernel in equation (1). (The values of the \nKIndex\n\nfield here are constants defined in \nTaylorDuffy.h\n.)\n\n\n\n\nIn this table, the values of the parameters \np\n and \n\nk\n are what you put into the \nKParam\n\narray in the \nTaylorDuffyArgStruct\n. \n\n\n3. Simple demonstration program\n\n\nHere is a little test program that you can download and compile\nagainst the\n\nscuff-em\n core library\n\nto test the code:\n\n\n\n\nTestTaylorDuffy.cc\n\n\n\n\nSample output:\n\n\n% TestTaylorDuffy \nIntegrand sampled at 33 points.\nIntegral 1: +3.56771698e-01  (estimated error: 6.0e-12)\nIntegral 2: +1.57003236e-03  (estimated error: 1.2e-11)\nComputation time: 1.209307e+02 microseconds\n\n\n\n\nHere is a listing of the program:\n\n\n#include \nTaylorDuffy.h\n\nusing namespace scuff;\n\nint main(int argc, char *argv[])\n{\n  /* panel vertices */\n  int WhichCase = 2; // 2 common vertices\n  double V1[3]  =  { 0.0,  0.0,  0.0 };\n  double V2[3]  =  { 0.1,  0.0,  0.0 };\n  double V3[3]  =  { 0.05, 0.1,  0.0 };\n  double V3P[3] =  { 0.07, -0.08, 0.03 };\n\n  double *Q     = V3;  // source/sink vertex, triangle 1\n  double *QP    = V3P; // source/sink vertex, triangle 2\n\n  /* specification of which integrals we want */\n  int NumPKs        = 2;\n  int PIndex[2]     = {TD_UNITY, TD_PMCHWC};\n  int KIndex[2]     = {TD_RP,    TD_RP};\n  cdouble KParam[2] = {-1.0,    -3.0};\n\n  /* output buffers */\n  cdouble Result[2], Error[2];\n\n  /* fill in argument structure with problem description */\n  TaylorDuffyArgStruct MyTDArgs, *TDArgs=\nMyTDArgs;\n  InitTaylorDuffyArgs(TDArgs);\n  TDArgs-\nWhichCase = WhichCase;\n  TDArgs-\nV1        = V1;\n  TDArgs-\nV2        = V2;\n  TDArgs-\nV3        = V3;\n  TDArgs-\nV3P       = V3P;\n  TDArgs-\nQ         = Q;\n  TDArgs-\nQP        = QP;\n  TDArgs-\nNumPKs    = NumPKs;\n  TDArgs-\nPIndex    = PIndex;\n  TDArgs-\nKIndex    = KIndex;\n  TDArgs-\nKParam    = KParam;\n  TDArgs-\nResult    = Result;\n  TDArgs-\nError     = Error;  \n\n  /* specify desired error tolerance */\n  TDArgs-\nRelTol    = 1.0e-10;   // request 10-digit accuracy\n  TDArgs-\nMaxEval   = 25;        // upper limit on integrand samples\n\n  /* calculate the integral */\n  TaylorDuffy( TDArgs );\n\n  /* print the results */\n  printf(\nIntegrand sampled at %i points.\\n\n,TDArgs-\nnCalls);\n  printf(\nIntegral 1: {%+.8e, %+.8e} (estimated error {%.1e.,%.1e}) \\n\n,\n          real(Result[0]),imag(Result[0]),real(Error[0]),imag(Error[0]));\n  printf(\nIntegral 2: {%+.8e, %+.8e} (estimated error {%.1e.,%.1e}) \\n\n,\n          real(Result[1]),imag(Result[1]),real(Error[1]),imag(Error[1]));\n\n  /* uncomment the following line to report computation time */\n//#define MEASURE_RUNTIME\n#ifdef MEASURE_RUNTIME\n#define REPETITIONS 100\n  Tic();\n  for(int n=0; n\nREPETITIONS; n++)\n   TaylorDuffy( TDArgs );\n  double TimeElapsed = Toc() / REPETITIONS;\n  printf(\nComputation time: %e microseconds\\n\n,1.0e6*TimeElapsed);\n#endif\n\n}\n\n\n\n\nAnd here is a simple \nMakefile\n\nthat compiles and links against the \nscuff-em\n installation \non your system (you'll need to modify a few lines at the top \nof this file appropriately for your system):\n\n\n# top of SCUFF-EM src tree\nSCUFF_SRC=$(HOME)/work/scuff-em\n\n# SCUFF-EM installation prefix (set with --prefix when running configure)\nSCUFF_INSTALL=$(HOME)/work/scuff-em-installation\n\n# HDF5 / Lapack libraries\nHDF5_LIBS=-lhdf5_hl -lhdf5\nMATH_LIBS=-lopenblas -lgomp -lgfortran -lpthread\n\n##################################################\n# shouldn't need to modify the rest\n##################################################\nCPPFLAGS+=-I$(SCUFF_SRC)/src/libs/libscuff \nCPPFLAGS+=-I$(SCUFF_INSTALL)/include/scuff-em\n\nLIBDIR=$(SCUFF_INSTALL)/lib\nLDFLAGS+=-L$(LIBDIR) -Wl,-rpath,$(LIBDIR)\n\nSCUFF_LIBS=-lscuff\nLIBS=$(SCUFF_LIBS) $(HDF5_LIBS) $(MATH_LIBS)\n\nTestTaylorDuffy:        TestTaylorDuffy.o\n                $(CXX) $(LDFLAGS) -o $@ $^ $(LIBS)", 
            "title": "Code for computing singular integrals"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/#2-c-calling-convention", 
            "text": "The  TaylorDuffy  routine has many input\narguments (many of which may be set to default values)\nand multiple output values. For this reason, instead\nof the typical calling convention in which you specify\nmultiple input arguments to a  C++  function\nand get back a single output value, TaylorDuffy  accepts as its argument a\n(pointer to a) single big argument  structure .  Thus, within a  C/C++  program, \nto evaluate one or more integrals of the form (1) for a given\npair of triangles you will     instantiate and initialize a data structure of type  TaylorDuffyArgStruct , which stores all input and output arguments, and then     simply call  TaylorDuffy()  with a pointer to your argument structure as the only parameter. On return, the results (the values of the integral) will be stored in the argument structure.    The process looks like this:    // instantiate and initialize argument structure \n TaylorDuffyArgStruct MyTDArgs, *TDArgs= MyTDArgs;\n InitTaylorDuffyArgs(TDArgs); // always call this!\n\n // fill in necessary fields \n TDArgs- WhichCase = TD_COMMONVERTEX\n TDArgs- NumPKs    = 1; \n ...\n\n // evaluate the integral\n TaylorDuffy(TDArgs);\n\n // results are now available inside TDArgs\n printf( Result: %e \\n , real(TDArgs- Result[0]) );", 
            "title": "2. C++ calling convention"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/#thread-safety", 
            "text": "TaylorDuffy()  is thread-safe; you may call it \nfrom multiple simultaneously-executing threads without fear\nof crosstalk or race conditions. (Indeed,  scuff-em  does just this if compiled\nwith support for  openmp \nor  pthreads .)", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/#fields-in-taylorduffyargstruct", 
            "text": "The table below details all fields in the argument structure\npassed to  TaylorDuffy.  In general, you should always call  InitTaylorDuffyArgs \nfirst to set all optional fields to default values, then fill in \nyour desired values for mandatory fields (and overwrite the default\nvalues for any optional fields you wish to tweak).  \n\n     \n     \n        Field  \n        Description  \n     \n\n     \n      \n         \n            Mandatory input fields describing the triangles \n         \n     \n\n     \n     \n         int WhichCase;   \n        Counts the number of common vertices between the \n           two triangles. You should set this to 1, 2, or 3 \n           for the common-vertex, common-edge, or common-triangle\n           cases. (The file  TaylorDuffy.h  defines\n           the constants \n            TD_COMMONVERTEX=1 ,\n            TD_COMMONEDGE=2 ,\n            TD_COMMONTRIANGLE=3 ).\n       \n     \n\n     \n     \n         \n             double *V1, *V2, *V3; \n             double *V2P, *V3P; \n            \n       \n        Pointers to caller-allocated arrays of length 3 \n           containing the  x,y,z  coordinates of the \n           triangle vertices.\n\n            \n            V1, V2, V3  are the vertices of triangle \n            T . For example,  V2[0,1,2] \n           are the  x,y,z  coordinates of the \n           second vertex.\n\n            \n            V2P, V3P  are the vertices of triangle\n            T'  that are  not  shared with triangle \n            T . It is not always necessary to initialize \n           these fields. In particular,\n\n            \n             \n              In the common-triangle case ( WhichCase=3 ),\n                 neither  V2P  nor  V3P \n                 is referenced.\n              In the common-edge case ( WhichCase=2 ),\n                 only  V3P  is referenced;  V2P \n                 is ignored.\n              In the common-vertex case ( WhichCase=1 ),\n                 both  V2P  and  V3P \n                 are referenced.\n             \n\n       \n     \n\n     \n      \n         \n            Mandatory input fields describing the  P  \n              and  K  functions \n        \n     \n\n     \n     \n         \n             int NumPKs; \n             int *PIndex; \n             int *KIndex; \n             int *KParam; \n            \n       \n        \n            \n            NumPKs  specifies the number of \n           integrals of the form (1) you wish to compute \n           (that is, the number of pairings of a polynomial\n            P  with a kernel  K ) for the given\n           pair of triangles.\n           If you only need to compute a single integral,\n           set  NumPKs=1. \n\n            \n            PIndex  and  KIndex  \n           are pointers to caller-allocated arrays\n           of length  NumPKs . The  n th\n           entries in these arrays are the indices \n           (in the tables below) of the \n            n th  P  and  K \n           functions.\n\n            \n            KParam  is a pointer to a \n           caller-allocated array of length\n            NumPKs  containing values of \n           certain parameters that enter the kernel\n           functions. The entries of this array are \n           interpreted in different ways depending on \n           the corresponding entries in the \n            KIndex  array:\n\n            \n              If  KIndex[n]==TD_RP  \n                 (the  r p  kernel),\n                 then  KParam[n]  is\n                 interpreted as the parameter  p ,\n                 i.e. the integer power to which  r \n                 is raised. (The  cdouble- valued\n                 quantity\n                  KParam[n]  is converted to\n                  int  inside  TaylorDuffy. )\n              \n                 For all other kernels,\n                  KParam[n]  is interpreted as \n                 the parameter  k , i.e. the \n                 Helmholtz wavenumber. This quantity can\n                 be purely real, purely imaginary, or complex.\n            \n        \n     \n\n     \n      \n         \n            Input fields that are required for certain \n               P  functions \n        \n     \n\n     \n     \n         double *Q, *QP; \n       \n        Pointers to caller-allocated arrays of length 3 \n           containing the  x,y,z  coordinates of the \n           RWG source/sink vertices  Q,Q' . These are \n           only referenced if any entry in the  PIndex \n           array corresponds to one of the polynomials in the \n           table below whose definition involves  Q,Q'. \n       \n     \n\n     \n     \n         double *nHat; \n       \n        Pointers to caller-allocated arrays of length 3 \n           containing the  x,y,z  components of the \n           unit normal vector  n . This is only referenced\n           if any entry in the  PIndex  array \n           corresponds to one of the polynomials in the \n           table below whose definition involves  n. \n       \n     \n\n     \n      \n         \n            Optional input fields controlling integration behavior \n            \n        \n     \n\n     \n     \n         double AbsTol, RelTol; \n       \n        The absolute and relative error tolerances to which\n           the adaptive integrator will attempt to compute \n           the integral. (The defaults are  AbsTol=0.0 \n           and  RelTol=1.0e-10 .) \n       \n     \n\n     \n     \n         int MaxEval; \n       \n        An upper bound on the number of function samples\n           the adaptive integrator may compute. (The default \n           is  MaxEval=1000. ) Reducing this \n           number will cause the code to run more quickly,\n           possibly at the expense of lower accuracy.\n       \n     \n\n     \n      \n         \n            Output fields \n            \n        \n     \n\n     \n     \n         cdouble *Result, *Error; \n       \n        Pointers to caller-allocated output buffers \n           with enough space to store  NumPKs  \n           values of type  cdouble . On return,\n            Result[n]  is the value of the \n           integral for the  n th  P,K  pairing,\n           and  Error[n]  is an estimate of \n           the error incurred by the numerical quadrature.\n       \n     \n\n     \n     \n         int nCalls;  \n       \n        The number of function evaluations used to evaluate\n           the numerical cubature.\n           This number will not exceed  MaxEval.", 
            "title": "Fields in TaylorDuffyArgStruct"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/#values-of-the-pindex-field", 
            "text": "The implementation of  TaylorDuffy  provided here\ncontains support for the following choices of the  P \npolynomial in equation (1). (The values of the  PIndex \nfield here are constants defined in  TaylorDuffy.h .)   In this table, the quantities  Q, Q', n  are vector-valued\nparameters that you specify by setting fields in the argument\nstructure for the  TaylorDuffy  routine (see above).\nAlso, in the final three table entries, the tilde symbol above\na vector-valued quantity indicates the result of crossing that\nquantity with the normal vector you specify via the  nHat  \nfield in the argument structure (see above):   \n\\widetilde{\\mathbf x} \\equiv \\mathbf{\\hat n} \\times \\mathbf x, \\qquad \n\\widetide{\\mathbf Q} \\equiv \\mathbf{\\hat n} \\times \\mathbf Q   For RWG basis-function enthusiasts, note that the last 5 entries \nin the table are appropriate for computing matrix elements of the \nEFIE and MFIE operators between RWG basis functions, but observe\ncarefully that the prefactor  \\frac{1}{4AA'}  in the definition (1)\nis only  part \nof the full prefactor that arises for RWG basis functions; there \nis also a factor  ll'  (product of edge lengths) \nwhich is missing from these calculations, and you must put that \nin yourself, by hand.", 
            "title": "Values of the PIndex field"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/#values-of-the-kindex-field", 
            "text": "The implementation of  TaylorDuffy  provided here\ncontains support for the following choices of the  K \nkernel in equation (1). (The values of the  KIndex \nfield here are constants defined in  TaylorDuffy.h .)   In this table, the values of the parameters  p  and  k  are what you put into the  KParam \narray in the  TaylorDuffyArgStruct .", 
            "title": "Values of the KIndex field"
        }, 
        {
            "location": "/forDevelopers/SingularIntegrals/#3-simple-demonstration-program", 
            "text": "Here is a little test program that you can download and compile\nagainst the scuff-em  core library \nto test the code:   TestTaylorDuffy.cc   Sample output:  % TestTaylorDuffy \nIntegrand sampled at 33 points.\nIntegral 1: +3.56771698e-01  (estimated error: 6.0e-12)\nIntegral 2: +1.57003236e-03  (estimated error: 1.2e-11)\nComputation time: 1.209307e+02 microseconds  Here is a listing of the program:  #include  TaylorDuffy.h \nusing namespace scuff;\n\nint main(int argc, char *argv[])\n{\n  /* panel vertices */\n  int WhichCase = 2; // 2 common vertices\n  double V1[3]  =  { 0.0,  0.0,  0.0 };\n  double V2[3]  =  { 0.1,  0.0,  0.0 };\n  double V3[3]  =  { 0.05, 0.1,  0.0 };\n  double V3P[3] =  { 0.07, -0.08, 0.03 };\n\n  double *Q     = V3;  // source/sink vertex, triangle 1\n  double *QP    = V3P; // source/sink vertex, triangle 2\n\n  /* specification of which integrals we want */\n  int NumPKs        = 2;\n  int PIndex[2]     = {TD_UNITY, TD_PMCHWC};\n  int KIndex[2]     = {TD_RP,    TD_RP};\n  cdouble KParam[2] = {-1.0,    -3.0};\n\n  /* output buffers */\n  cdouble Result[2], Error[2];\n\n  /* fill in argument structure with problem description */\n  TaylorDuffyArgStruct MyTDArgs, *TDArgs= MyTDArgs;\n  InitTaylorDuffyArgs(TDArgs);\n  TDArgs- WhichCase = WhichCase;\n  TDArgs- V1        = V1;\n  TDArgs- V2        = V2;\n  TDArgs- V3        = V3;\n  TDArgs- V3P       = V3P;\n  TDArgs- Q         = Q;\n  TDArgs- QP        = QP;\n  TDArgs- NumPKs    = NumPKs;\n  TDArgs- PIndex    = PIndex;\n  TDArgs- KIndex    = KIndex;\n  TDArgs- KParam    = KParam;\n  TDArgs- Result    = Result;\n  TDArgs- Error     = Error;  \n\n  /* specify desired error tolerance */\n  TDArgs- RelTol    = 1.0e-10;   // request 10-digit accuracy\n  TDArgs- MaxEval   = 25;        // upper limit on integrand samples\n\n  /* calculate the integral */\n  TaylorDuffy( TDArgs );\n\n  /* print the results */\n  printf( Integrand sampled at %i points.\\n ,TDArgs- nCalls);\n  printf( Integral 1: {%+.8e, %+.8e} (estimated error {%.1e.,%.1e}) \\n ,\n          real(Result[0]),imag(Result[0]),real(Error[0]),imag(Error[0]));\n  printf( Integral 2: {%+.8e, %+.8e} (estimated error {%.1e.,%.1e}) \\n ,\n          real(Result[1]),imag(Result[1]),real(Error[1]),imag(Error[1]));\n\n  /* uncomment the following line to report computation time */\n//#define MEASURE_RUNTIME\n#ifdef MEASURE_RUNTIME\n#define REPETITIONS 100\n  Tic();\n  for(int n=0; n REPETITIONS; n++)\n   TaylorDuffy( TDArgs );\n  double TimeElapsed = Toc() / REPETITIONS;\n  printf( Computation time: %e microseconds\\n ,1.0e6*TimeElapsed);\n#endif\n\n}  And here is a simple  Makefile \nthat compiles and links against the  scuff-em  installation \non your system (you'll need to modify a few lines at the top \nof this file appropriately for your system):  # top of SCUFF-EM src tree\nSCUFF_SRC=$(HOME)/work/scuff-em\n\n# SCUFF-EM installation prefix (set with --prefix when running configure)\nSCUFF_INSTALL=$(HOME)/work/scuff-em-installation\n\n# HDF5 / Lapack libraries\nHDF5_LIBS=-lhdf5_hl -lhdf5\nMATH_LIBS=-lopenblas -lgomp -lgfortran -lpthread\n\n##################################################\n# shouldn't need to modify the rest\n##################################################\nCPPFLAGS+=-I$(SCUFF_SRC)/src/libs/libscuff \nCPPFLAGS+=-I$(SCUFF_INSTALL)/include/scuff-em\n\nLIBDIR=$(SCUFF_INSTALL)/lib\nLDFLAGS+=-L$(LIBDIR) -Wl,-rpath,$(LIBDIR)\n\nSCUFF_LIBS=-lscuff\nLIBS=$(SCUFF_LIBS) $(HDF5_LIBS) $(MATH_LIBS)\n\nTestTaylorDuffy:        TestTaylorDuffy.o\n                $(CXX) $(LDFLAGS) -o $@ $^ $(LIBS)", 
            "title": "3. Simple demonstration program"
        }
    ]
}