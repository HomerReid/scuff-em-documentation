{
    "docs": [
        {
            "location": "/", 
            "text": "scuff-em\n documentation: Table of contents\n\n \n\n\n\n\nIf you find any inconsistencies or missing bits in the documentation, please\n  \nfile an issue on the \nscuff-em\n GitHub page\n.\n\n\nGeneral reference\n\n\n\n\nTop-level overview\n\n\nInstallation\n\n\nGeometry files\n\n\nMaterial descriptions\n\n\nGeometrical transformations\n\n\nIncident Fields\n\n\nBrillouin-zone integration\n\n\nFAQ\n\n\n\n\nTutorial Examples\n\n\n\n\nMie scattering\n\n\nElectrostatics of a spherical dielectric shell\n\n\nSpatially-resolved study of plane-wave transmission through an infinite-area thin dielectric film\n\n\nImaging diffraction patterns of discs, disc arrays, and hole arrays in metal screens\n\n\nCasimir forces in a compact geometry\n\n\nCasimir forces in a 1D extended geometry\n\n\nCasimir forces in a 2D extended geometry\n\n\nThermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres\n\n\nSpatial distribution of heat flux from a warm tip over a cold substrate\n\n\nLDOS and dyadic Green functions above an infinite aluminum half-space\n\n\nElectrostatic polarizability of platonic solids\n\n\n\n\nCommand-line application reference\n\n\n\n\n\n\nGeneral reference for \nscuff-em\n command-line applications\n\n\n\n\n\n\nNanophotonics codes\n\n\n\n\nscuff-scatter\n: general-purpose electromagnetic scattering\n\n\nscuff-ldos\n                  - photonic \nl\nocal \nd\nensity \no\nf \ns\ntates\n\n\nscuff-transmission\n  - plane-wave transmission through 2D extended structures\n\n\nscuff-tmatrix\n            - T-matrices of arbitrary compact objects in the spherical-wave basis  \n\n\n\n\n\n\n\n\nEquilibrium Casimir codes\n\n\n\n\nscuff-cas3d\n   - Casimir energies, forces, and torques\n\n\nscuff-caspol\n - Casimir-Polder potentials\n\n\n\n\n\n\n\n\nNon-equilibrium Casimir/ heat-transfer code\n\n\n\n\nscuff-neq\n       - radiative heat transfer and non-equilibrium Casimir forces/torques\n\n\n\n\n\n\n\n\nRF / microwave engineering code\n\n\n\n\nscuff-rf\n         - multiport network parameters\n                                 (S- and impedance parameters),\n                                 and radiated fields, for passive RF\n                                 and microwave structures.\n\n\n\n\n\n\n\n\nElectrostatics code\n\n\n\n\nscuff-static\n - pure electrostatics problems:\n                                 capacitance matrices, DC polarizabilities,\n                                 electrostatic potentials and fields\n\n\n\n\n\n\n\n\nUtility codes\n\n\n\n\nscuff-analyze\n - diagnostic tool to print info on \nscuff-em\n geometries\n\n\nscuff-integrate\n - utility tool to integrate functions using samples tabulated in data files\n\n\n\n\n\n\n\n\nValidation Test Suite\n\n\n\n\nOverview of the \nscuff-em\n test suite\n\n\nMie scattering\n\n\nFresnel scattering\n\n\nEquilibrium Casimir forces between spheres\n\n\nEquilibrium Casimir forces between plates\n\n\nEquilibrium Casimir-Polder potential near a sphere\n\n\nEquilibrium Casimir-Polder potential near a plate\n\n\nHeat transfer and non-equilibrium Casimir forces between spheres\n\n\nLow-level tests of the \nscuff-em\n core library\n\n\n\n\nAPI reference\n\n\n\n\nlibscuff\n - Accessing \nscuff-em\n from C++ and python programs\n\n\n\n\nDeveloper reference\n\n\n\n\nImplementation\n - how \nscuff-em\n works\n\n\nDataStructures\n - data structures and methods inside the \nscuff-em\n core library\n\n\nDocumentation\n   - about the \nscuff-em\n documentation\n\n\n\n\nFAQ\n\n\n\n\nFAQ\n - frequently asked questions about \nscuff-em\n\n\n\n\nTechnical memos\n\n\n\n\nlibscuff\n Implementation and Technical Details\n - a technical memo describing many details of the core library implementation\n\n\nComputation of power, force, and torque in \nscuff-em\n - a technical memo describing methods for computing power, force and torque, with applications to both classical scattering and non-equilibrium fluctuational electrodynamics\n\n\nComputation of fields near panels in \nscuff-em\n - a technical memo describing the computation of fields near triangular panels in discretized surface meshes\n\n\nComputation of Green's Functions and LDOS in \nscuff-em\n - a technical memo describing the implementation of the \nscuff-ldos\n code for computing dyadic Green's functions and local photonic densities of states\n\n\nComputation of reflection and transmission coefficients in \nscuff-em\n - a technical memo describing the implementation of the \nscuff-transmission\n code for computing plane-wave transmission and reflection coefficients\n\n\nscuff-static:\n Pure electrostatics in \nscuff-em\n -- a technical memo describing the implementation of the \nscuff-static\n code for electrostatics", 
            "title": "SCUFF-EM documentation"
        }, 
        {
            "location": "/#tutorial-examples", 
            "text": "Mie scattering  Electrostatics of a spherical dielectric shell  Spatially-resolved study of plane-wave transmission through an infinite-area thin dielectric film  Imaging diffraction patterns of discs, disc arrays, and hole arrays in metal screens  Casimir forces in a compact geometry  Casimir forces in a 1D extended geometry  Casimir forces in a 2D extended geometry  Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres  Spatial distribution of heat flux from a warm tip over a cold substrate  LDOS and dyadic Green functions above an infinite aluminum half-space  Electrostatic polarizability of platonic solids", 
            "title": "Tutorial Examples"
        }, 
        {
            "location": "/#command-line-application-reference", 
            "text": "General reference for  scuff-em  command-line applications    Nanophotonics codes   scuff-scatter : general-purpose electromagnetic scattering  scuff-ldos                   - photonic  l ocal  d ensity  o f  s tates  scuff-transmission   - plane-wave transmission through 2D extended structures  scuff-tmatrix             - T-matrices of arbitrary compact objects in the spherical-wave basis       Equilibrium Casimir codes   scuff-cas3d    - Casimir energies, forces, and torques  scuff-caspol  - Casimir-Polder potentials     Non-equilibrium Casimir/ heat-transfer code   scuff-neq        - radiative heat transfer and non-equilibrium Casimir forces/torques     RF / microwave engineering code   scuff-rf          - multiport network parameters\n                                 (S- and impedance parameters),\n                                 and radiated fields, for passive RF\n                                 and microwave structures.     Electrostatics code   scuff-static  - pure electrostatics problems:\n                                 capacitance matrices, DC polarizabilities,\n                                 electrostatic potentials and fields     Utility codes   scuff-analyze  - diagnostic tool to print info on  scuff-em  geometries  scuff-integrate  - utility tool to integrate functions using samples tabulated in data files", 
            "title": "Command-line application reference"
        }, 
        {
            "location": "/#validation-test-suite", 
            "text": "Overview of the  scuff-em  test suite  Mie scattering  Fresnel scattering  Equilibrium Casimir forces between spheres  Equilibrium Casimir forces between plates  Equilibrium Casimir-Polder potential near a sphere  Equilibrium Casimir-Polder potential near a plate  Heat transfer and non-equilibrium Casimir forces between spheres  Low-level tests of the  scuff-em  core library", 
            "title": "Validation Test Suite"
        }, 
        {
            "location": "/#api-reference", 
            "text": "libscuff  - Accessing  scuff-em  from C++ and python programs", 
            "title": "API reference"
        }, 
        {
            "location": "/#developer-reference", 
            "text": "Implementation  - how  scuff-em  works  DataStructures  - data structures and methods inside the  scuff-em  core library  Documentation    - about the  scuff-em  documentation", 
            "title": "Developer reference"
        }, 
        {
            "location": "/#faq", 
            "text": "FAQ  - frequently asked questions about  scuff-em", 
            "title": "FAQ"
        }, 
        {
            "location": "/#technical-memos", 
            "text": "libscuff  Implementation and Technical Details  - a technical memo describing many details of the core library implementation  Computation of power, force, and torque in  scuff-em  - a technical memo describing methods for computing power, force and torque, with applications to both classical scattering and non-equilibrium fluctuational electrodynamics  Computation of fields near panels in  scuff-em  - a technical memo describing the computation of fields near triangular panels in discretized surface meshes  Computation of Green's Functions and LDOS in  scuff-em  - a technical memo describing the implementation of the  scuff-ldos  code for computing dyadic Green's functions and local photonic densities of states  Computation of reflection and transmission coefficients in  scuff-em  - a technical memo describing the implementation of the  scuff-transmission  code for computing plane-wave transmission and reflection coefficients  scuff-static:  Pure electrostatics in  scuff-em  -- a technical memo describing the implementation of the  scuff-static  code for electrostatics", 
            "title": "Technical memos"
        }, 
        {
            "location": "/examples/MieScattering/MieScattering/", 
            "text": "Plane-wave scattering from a dielectric sphere (Mie scattering)\n\n\nWe first demonstrate how to use \nscuff-scatter\n to solve the canonical textbook \nproblem of \nMie scattering\n -- the scattering of a plane wave from a dielectric \nsphere. The files for this example are in \nthe \nshare/scuff-em/examples/SolidSphere\n subdirectory of the \nscuff-em\n\nsource distribution.\n\n\nWe begin by creating a \ngmsh\n geometry file for the \nsphere \n(\nSphere.geo\n)\n. We turn this geometry file into a mesh \nfile by running the following command:\n\n\n % gmsh -2 -clscale 1.0 Sphere.geo\n\n\n\n\nThis produces a file named \nSphere.msh\n which looks like this:\n\n\n\n\nYou can adjust the fineness of the surface mesh by varying the \n-clscale\n parameter \n(which stands for \"characteristic length scale\"); finer meshes will be more accurate \nbut will take longer to simulate.\n\n\nNext we create a \nscuff-em\n geometry file\n\nthat will tell \nscuff-scatter\n about our geometry, including both the surface mesh \nand the material properties (dielectric function) of the sphere. As a first example, \nwe'll use a dielectric model for silicon carbide that expresses the relative \npermittivity as a rational function of \u03c9; in this case we'll call the geometry \nfile \nSiCSphere.scuffgeo.\n\n\nMATERIAL SiliconCarbide\n\n   EpsInf = 6.7;\n   a0     = -3.32377e28;\n   a1     = +8.93329e11;\n   b0     = -2.21677e28;\n   b1     = 8.93329e11;\n   Eps(w) = EpsInf * (a0 + i*a1*w + w*w) / ( b0 + i*b1*w + w*w);\n\nENDMATERIAL \n\nOBJECT TheSphere\n        MESHFILE Sphere.msh\n        MATERIAL SiliconCarbide\nENDOBJECT\n\n\n\n\nWe create a simple file called \nOmegaValues.dat\n containing a \nlist of angular frequencies at which to run the scattering problem:\n\n\n    0.010\n    0.013\n    ...\n    10.0\n\n\n\n\n(We pause to note one subtlety here: Angular frequencies specified \nusing the \n--Omega\n or \n--OmegaFile\n arguments are interpreted in \nunits of \nc / 1 \\mu\nm = \n3\\cdot 10^{14}\n rad/sec.\nThese are natural \nfrequency units to use for problems involving micron-sized objects; \nin particular, for Mie scattering from a sphere of radius 1 \u03bcm, as \nwe are considering here, the numerical value of \nOmega\n is just the \nquantity \nkR\n (wavenumber times radius) known as the \n\"size parameter\" in the Mie scattering literature. In contrast, \nwhen specifying functions of angular frequency like \nEps(w)\n in \n\nMATERIAL...ENDMATERIAL\n sections of geometry files or in any other \n\nscuff-em\n material description\n, \nthe \nw\n variable \nis always interpreted in units of \n1 \nrad/sec\n, because these are \nthe units in which tabulated material properties and functional forms \nfor model dielectric functions are typically expressed.)\n\n\nFinally, we'll create a little text file called \nArgs\n that will contain \na list of command-line options for \nscuff-scatter\n; these will include \n\n(1)\n a specification of the geometry, \n(2)\n the frequency list, \n\n(3)\n the name of an output file for the power, force, and torque \n\n(4)\n the name of a cache file for geometric data (this file doesn't \nexist yet, but will be created by our first run of \nscuff-scatter\n), \nand \n(5)\n a specification of the incident field.\n\n\n    geometry SiCSphere.scuffgeo\n    OmegaFile OmegaValues.dat\n    PFTFile SiCSphere.PFT\n    Cache Sphere.cache\n    pwDirection 0 0 1\n    pwPolarization 1 0 0\n\n\n\n\n\nAnd now we just pipe this little file into the standard input of \n\nscuff-scatter\n:\n\n\n    % scuff-scatter \n Args \n\n\n\n\nThis produces the file \nSiCSphere.PFT\n, which contains one line per simulated \nfrequency; each line contains data on the scattered and total power, the force, \nand the torque on the particle at that frequency. (Look at the first few lines\nof the file for a text description of how to interpret it.)\n\n\n(On my fairly standard workstation (8 Xeon E5420 cores, 2.5 GHz), this calculation \ntakes a few minutes to run. You can monitor its progress by following the \nscuff-scatter.log\n \nfile. Note that, during computationally-intensive operations such as the BEM matrix assembly, \nthe code should be using all available CPU cores on your workstation; if you find that this is \nnot the case (for example, by monitoring CPU usage using \n\nhtop\n) \nyou may need to \n[reconfigure and recompile with different openmp/pthreads configuration options.][scuffEMInstallation.shtml]\n\n\nHere's a comparison of the \nscuff-scatter\n results with the analytical Mie series, as computed \nusing \nthis Mathematica script.\n [Like most Mie codes, this script computes the \nabsorption and scattering \ncross-sections\n, which we multiply by the incoming beam flux (\n\\frac{1}{2Z_0}\n for a unit-strength plane wave in vacuum) to get \nvalues for the absorbed and scattered \npower\n.]\n\n\n\n\nNow let's redo the calculation for a sphere made of gold instead of silicon carbide.  In this case we will name our \nscuff-em\n geometry file \nGoldSphere.scuffgeo\n:\n\n\n    MATERIAL Gold\n      wp = 1.37e16;\n      gamma = 5.32e13;\n      Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\n    ENDMATERIAL\n\n    OBJECT TheSphere\n        MESHFILE Sphere.msh\n        MATERIAL Gold\n    ENDOBJECT\n\n\n\n\n\nSince most of the command-line arguments to \nscuff-scatter\n will be the same as before, \nwe can reuse the same \nArgs\n file, with the options that need to be given new values \nspecified on the command line:\n\n\n% scuff-scatter --geometry GoldSphere.scuffgeo --PFTFile GoldSphere.PFT \n Args\n\n\n\n\n\n(Note that we don't have to change the name of the cache file specified with the \nCache\n \noption; because we are using the same surface mesh as before, and because \n\ncached geometric data in \nscuff-em\n are independent of material properties\n, \nwe can take advantage of geometric data computed during the earlier run for the silicon carbide sphere.)\n\n\nNow our data look like this:\n\n\n\n\nIn some cases it's useful to look at how the induced surface currents vary over the surface of the object. \nLet's re-run the SiC example, now at just the single angular frequency of \u03c9=0.1, and ask for a surface current plot.\n\n\n% scuff-scatter --geometry SiCSphere.scuffgeo --Omega 0.1 --Cache Sphere.cache --pwDirection 0 0 1 --pwPolarization 1 0 0 --PlotSurfaceCurrents\n\n\n\n\nThis produces a file named \nSiCSphere.0.1.pp\n, which we can open in gmsh like this:\n\n\n % gmsh SiCSphere.0.1.pp", 
            "title": "Mie scattering"
        }, 
        {
            "location": "/examples/DielectricShell/DielectricShell/", 
            "text": "Electrostatics of a spherical dielectric shell\n\n\nFor our next trick, we'll consider a spherical shell of dielectric material illuminated \nby a plane wave of such low frequency that we may think of the incident field as a \nspatially constant DC electric field. In this case it is easy to obtain an \n\nexact analytical solution of the scattering problem,\n \nwhich we will reproduce numerically using \nscuff-scatter\n. We will take the outer and \ninner radii to be \nR\nout\n=1\n and \nR\nin\n=0.5.\n The files for this example \nare in the \nshare/scuff-em/examples/SphericalShell\n subdirectory of the \nscuff-em\n \nsource distribution.\n\n\nTo represent a spherical shell in \nscuff-em\n, we need two surface meshes, one each for \nthe inner and outer spherical surfaces. These are described by \ngmsh\n mesh files \n\nSphere_R1P0.msh\n and \nSphere_R0P5.msh\n We describe the shell as an inner vacuum sphere \nembedded in the outer sphere; the geometry file for this situation is \n\nSphericalShell.scuffgeo:\n\n\n OBJECT OuterSphere \n     MESHFILE Sphere_R1P0.msh\n     MATERIAL CONST_EPS_10\n ENDOBJECT \n\n OBJECT InnerSphere \n     MESHFILE Sphere_R0P5.msh\n     MATERIAL Vacuum\n ENDOBJECT \n\n\n\n\n\n\nWe will run two separate calculations. First, we will fix the relative permittivity \nof the shell at \u03b5\nr\n=10 and look at the \nz\n component of the electric field \nat points on the \nz\n axis ranging from the origin (the center of the concentric spheres) \nto the exterior medium. We create a file called \nLineOfPoints\n which \nlists the Cartesian coordinates of each evaluation point:\n\n\n      0.0 0.0 0.000\n      0.0 0.0 0.025\n      0.0 0.0 0.050\n      ...\n      0.0 0.0 2.000\n\n\n\n\nWe will pass this file to \nscuff-scatter\n using the \n--EPFile\n option:\n\n\n     % scuff-scatter --EPFile LineOfPoints \n Args\n\n\n\n\nwhere the \nArgs\n file looks like this:\n\n\n      geometry       SphericalShell.scuffgeo\n      cache          SphericalShell.cache\n      omega          0.001\n      pwDirection    1.0 0.0 0.0\n      pwPolarization 0.0 0.0 1.0\n\n\n\n\nNote that we choose a frequency low enough to ensure we are well within the \nelectrostatic limit, and that the constant \nz\n-directed electrostatic field \ndescribed in the memo above becomes a linearly polarized plane wave traveling \nin the \nx-\n direction.\n\n\nThis run of the code produces files \nSphericalShell.scattered\n and \nSphericalShell.total\n. \nPlotting the 8th vs. the 3rd column of the latter file (look at the first few lines\nof the file for a description of which column is which) yields plot \nof the real part of \nE\nz\n vs. \nz\n and \nyields good agreement with the analytical calculation, \nmodulo some funkiness at points on or near the boundary surfaces which is to be \nexpected in an SIE/BEM calculation:\n\n\n\n\nNext, we will vary the shell permittivity and look at the electric field \nat the center of the shell. In this case the \n\nanalytical solution\n\nmakes the interesting prediction\n\n\n\n\nwhich we will try to verify numerically.\n\n\nThis calculation is slightly trickier than the last one, because \nscuff-scatter\n doesn't offer \ncommand-line options for varying the dielectric constant of an object. One way around this is to \nuse the python interface to \nscuff-em\n, as discussed \n\non this page\n.\nHere we will pursue a different solution involving a shell script that modifies \nthe \n.scuffgeo\n file for each different value of \u03b5 we want to simulate. That script \nlooks like this:\n\n\n#!/bin/bash\n\ncat EpsValues | while read EPS\ndo\n\n  # copy the .scuffgeo file with EPS_10 replaced by EPS_xx\n  sed \ns/EPS_10/EPS_${EPS}/\n SphericalShell.scuffgeo \n temp.scuffgeo\n\n  # run scuff-scatter to get E-field at origin\n  /bin/rm -f CenterPoint.total\n  /bin/rm -f CenterPoint.scattered\n  scuff-scatter --geometry temp.scuffgeo --EPFile CenterPoint \n Args\n\n  # extract the z-component of the field from the output file\n  EZ=`awk '{print $8}' CenterPoint.total`\n  echo \n${EPS} ${EZ}\n \n EzVsEps.dat\n\ndone\n\n\n\n\n(Here \nEpsValues\n is a file containing the values of \u03b5 \nthat we want to simulate, and \nCenterPoint\n is a file containing \njust the first line of the file \nLineOfPoints\n for the cartesian \ncoordinates of the origin.)\n\n\nThe result of the calculation looks like this:", 
            "title": "Electrostatics of a spherical dielectric shell"
        }, 
        {
            "location": "/examples/ThinFilm/ThinFilm/", 
            "text": "Spatially-resolved study of plane-wave transmission through an (infinite-area) thin dielectric film\n\n\nThe previous examples dealt with \ncompact\n scatterers. We'll next consider an \n\nextended\n geometry -- namely, a thin dielectric film of \nfinite thickness in the \nz\n direction but infinite extent in the \nx\n and \ny\n \ndirections. This is the same geometry for which we used \nscuff-transmission\n \nto look at the plane-wave transmission and reflection coefficients as a function \nof frequency in \nthis example\n,\nbut here we'll do a different calculation -- namely, we'll pick a single \nfrequency and look at how the electric and magnetic fields vary in space, \nboth inside and outside the thin film. (The files for this example may be \nfound in the \nshare/scuff-em/examples/ThinFilm\n directory of your \nscuff-em\n\ninstallation.)\n\n\nThe mesh file and \n.scuffgeo\n file for this geometry are discussed in the \n\ndocumentation for \nscuff-transmission\n.\nThe geometry consists of a film of thickness \nT\n=1\u03bcm, with relative dielectric \nconstant \n\\epsilon^r=100\n, illuminated from below by a plane wave at normal \nincidence. (We'll take the incident field to be linearly polarized with \nE\n field \npointing in the \nx\n direction.) The lower and upper surfaces of the film are at \n\nz=0\n and \nz=T.\n For this geometry it is easy to solve Maxwell's equation directly \nto obtain the \nE\n and \nH\n fields directly at points below, within, and above \nthe film:\n\n\n\n\nWe will try to reproduce this behavior using \n\nscuff-scatter\n. \n\n\nFirst create a little text file \n(\nThinFilm.EvalPoints\n) containing the \ncoordinates of a bunch of points on a straight line passing \nfrom below the film to above the film. Then put the following \ncommand-line arguments into a file called \nThinFilm_58.args:\n\n\n geometry ThinFilm_58.scuffgeo\n cache ThinFilm_58.scuffcache\n omega 1.0\n EPFile ThinFilm.EvalPoints\n pwDirection 0 0 1\n pwPolarization 1 0 0\n\n\n\n\nand pipe it into \nscuff-scatter\n:\n\n\n scuff-scatter \n scuff-scatter.args\n\n\n\n\nThis produces files named \nThinFilm.scattered\n and \n\nThinFilm.total\n. Looking at the first few lines of these\nfiles, we see that the 3rd data column on each line is \nthe \nz\n coordinate of the evaluation point, the 4th column\nis the real part of \nE_x\n, and the 12th column is \nthe real part of \nH_x\n. Thus, plotting the 4th vs. 3rd\nand 12th vs. 3rd columns of the \n.total\n file yields plots of\nthe total \nelectric and magnetic field vs. \nz\n, whereupon we find good\nagreement with theory:", 
            "title": "Spatially-resolved study of plane-wave transmission through an infinite-area thin dielectric film"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/", 
            "text": "Diffraction patterns for discs, disc arrays, and hole arrays in metal screens\n\n\nIn this example, we shine a laser beam (or a plane wave) on an \n(infinite-area) metal screen perforated by a square-lattice\narray of circular holes, and produce images of the diffraction \npatterns as observed on a visualization surface located behind the \nperforated screen. Here's a schematic depiction of the configuration:\n\n\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/DiffractionPatterns\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file and surface mesh for the screen unit cell\n\n\nThe \ngmsh\n geometry file \nHoleyScreenUnitCell.geo\n\ndescribes an (infinitely thin) square metallic screen, \nof dimensions 1\nm \n 1\nm, with a hole of radius 0.25 \nm\ncentered at the center of the square. I produce coarser and \nfiner surface meshes for this geometry by saying\n\n\n% gmsh -2 -clscale 1 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh\n% gmsh -2 -clscale 0.75 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh\n\n\n\n\n(where \nRenameMesh\n is a simple \n\nbash\n script that uses \nscuff-analyze\n to count the number \nof interior edges in a surface mesh and rename the mesh file \naccordingly.)\nThis produces the files \nHoleyScrenUnitCell_1228.msh\n\nand \nHoleyScreenUnitCell_2318.msh,\n\nwhich you can visualize by opening in \ngmsh\n::\n\n\n% gmsh HoleyScreenUnitCell_1228.msh\n% gmsh HoleyScreenUnitCell_2318.msh\n\n\n\n\n\n\n\n\nNote that finer meshing resolution is obtained by specifying\nthe \n-clscale\n argument to \ngmsh\n (it stands\nfor \"characteristic length scale\"), which specifies an overall\nscaling factor for all triangle edges.\n\n\n\n\nscuff-em\n geometry files\n\n\nThe \nscuff-em\n geometry files\n\nHoleyScreen_1228.scuffgeo\n\nand\n\nHoleyScreen_2318.scuffgeo\n\ndescribe infinite square lattices with unit\ncells defined by the unit-cell meshes we created\nabove. The \nN\n=1228 guy looks like this:\n\n\nLATTICE\n        VECTOR 1 0\n        VECTOR 0 1\nENDLATTICE    \n\nOBJECT HoleyScreen\n        MESHFILE HoleyScreenUnitCell_1228.msh\nENDOBJECT\n\n\n\n\nNote that we don't have to specify a \nMATERIAL\n\nfor the screen, since PEC is the default.\n\n\nWe can use \nscuff-analyze\n to produce an image\nof what the full geometry looks like, including\nthe lattice repetitions:\n\n\n% scuff-analyze --geometry HoleyScreen_1228.scuffgeo --WriteGMSHFiles --Neighbors 2\n\n\n\n\nThis produces the file \nHoleyScreen_1228.pp\n, which you \ncan view by opening it in \ngmsh\n:\n\n\n% gmsh HoleyScreen_1228.pp\n\n\n\n\n\n\n\n\nField visualization mesh\n\n\nThe next step is to create a meshed representation of the\nsurface on which we will visualize the diffraction patterns.\nHere's a \ngmsh\n file called\n\nFVMesh.geo\n that describes a square of\nside length 1 micron, parallel to the \nxy\n plane and\nlocated at a height of \nz\n=1 micron, thus corresponding\nto the region enclosed by the dotted line in the schematic\nfigure above. (\"FVMesh\" stands for \"field-visualization\nmesh.\") This \n.geo\n file contains a user-specifiable\nparameter \nN\n that sets the number of triangle edges per\nunit length in the mesh representation; I would\nlike to set this number to 50, so I say\n\n\n% gmsh -2 -setnumber N 50 FVMesh.geo -o FVMesh.msh\n% RenameMesh FVMesh.msh\n\n\n\n\nThis produces the file \nFVMesh_7400.msh\n:\n\n\n\n\n\n\nRunning \nscuff-scatter\n\n\nNow all that's left is to run the calculation.\nPut the following content into a little text\nfile called \nscuff-scatter.args\n and pipe it into\nthe standard input of \nscuff-scatter\n:\n\n\ngeometry        HoleyScreen_1228.scuffgeo\nFVMesh          FVMesh_7400.msh\nLambda          0.3751\nLambda          0.2501\nLambda          0.1251\npwDirection     0 0 1\npwPolarization  1 0 0 \n\n\n\n\nNote that I have chosen wavelengths of \n\n\\lambda=\\{1.5,1.0,0.5\\}R\n where \nR=0.25\\,\\mu\nm is \nthe hole radius. In each case I have shifted the wavelength by a \ntiny amount away from being commensurate with the lattice period\nto avoid numerical instabilities associated with Wood anomalies.\n\n\n % scuff-scatter \n scuff-scatter.args\n % scuff-scatter --geometry HoleyScreen_2318.scuffgeo \n scuff-scatter.args\n\n\n\n\nIn the second command line here, the command-line specified \ngeometry overrides the geometry in the \n.args\n file. \n\n\nThis produces the files \nHoleyScreen_1228.FVMesh_7400.pp\n\nand \nHoleyScreen_2318.FVMesh_7400.pp\n, which can be\nvisualized by opening them in \ngmsh\n.\n\n\n\n \n\n  \n \n\n  \n \n\n \n\n \n\n  \n \n=1.5 R (coarse mesh)\n  \n \n=1.5 R (fine mesh)\n \n\n \n\n  \n \n\n  \n \n\n \n\n \n\n  \n \n=1.0 R (coarse mesh)\n  \n \n=1.0 R (fine mesh)\n \n\n \n\n  \n \n\n  \n \n\n \n\n \n\n  \n \n=0.5 R (coarse mesh)\n  \n \n=0.5 R (fine mesh)", 
            "title": "Imaging diffraction patterns of discs, disc arrays, and hole arrays in metal screens"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#gmsh-geometry-file-and-surface-mesh-for-the-screen-unit-cell", 
            "text": "The  gmsh  geometry file  HoleyScreenUnitCell.geo \ndescribes an (infinitely thin) square metallic screen, \nof dimensions 1 m   1 m, with a hole of radius 0.25  m\ncentered at the center of the square. I produce coarser and \nfiner surface meshes for this geometry by saying  % gmsh -2 -clscale 1 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh\n% gmsh -2 -clscale 0.75 HoleyScreenUnitCell.geo\n% RenameMesh HoleyScreenUnitCell.msh  (where  RenameMesh  is a simple  bash  script that uses  scuff-analyze  to count the number \nof interior edges in a surface mesh and rename the mesh file \naccordingly.)\nThis produces the files  HoleyScrenUnitCell_1228.msh \nand  HoleyScreenUnitCell_2318.msh, \nwhich you can visualize by opening in  gmsh ::  % gmsh HoleyScreenUnitCell_1228.msh\n% gmsh HoleyScreenUnitCell_2318.msh    Note that finer meshing resolution is obtained by specifying\nthe  -clscale  argument to  gmsh  (it stands\nfor \"characteristic length scale\"), which specifies an overall\nscaling factor for all triangle edges.", 
            "title": "gmsh geometry file and surface mesh for the screen unit cell"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#scuff-em-geometry-files", 
            "text": "The  scuff-em  geometry files HoleyScreen_1228.scuffgeo \nand HoleyScreen_2318.scuffgeo \ndescribe infinite square lattices with unit\ncells defined by the unit-cell meshes we created\nabove. The  N =1228 guy looks like this:  LATTICE\n        VECTOR 1 0\n        VECTOR 0 1\nENDLATTICE    \n\nOBJECT HoleyScreen\n        MESHFILE HoleyScreenUnitCell_1228.msh\nENDOBJECT  Note that we don't have to specify a  MATERIAL \nfor the screen, since PEC is the default.  We can use  scuff-analyze  to produce an image\nof what the full geometry looks like, including\nthe lattice repetitions:  % scuff-analyze --geometry HoleyScreen_1228.scuffgeo --WriteGMSHFiles --Neighbors 2  This produces the file  HoleyScreen_1228.pp , which you \ncan view by opening it in  gmsh :  % gmsh HoleyScreen_1228.pp", 
            "title": "scuff-em geometry files"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#field-visualization-mesh", 
            "text": "The next step is to create a meshed representation of the\nsurface on which we will visualize the diffraction patterns.\nHere's a  gmsh  file called FVMesh.geo  that describes a square of\nside length 1 micron, parallel to the  xy  plane and\nlocated at a height of  z =1 micron, thus corresponding\nto the region enclosed by the dotted line in the schematic\nfigure above. (\"FVMesh\" stands for \"field-visualization\nmesh.\") This  .geo  file contains a user-specifiable\nparameter  N  that sets the number of triangle edges per\nunit length in the mesh representation; I would\nlike to set this number to 50, so I say  % gmsh -2 -setnumber N 50 FVMesh.geo -o FVMesh.msh\n% RenameMesh FVMesh.msh  This produces the file  FVMesh_7400.msh :", 
            "title": "Field visualization mesh"
        }, 
        {
            "location": "/examples/DiffractionPatterns/DiffractionPatterns/#running-scuff-scatter", 
            "text": "Now all that's left is to run the calculation.\nPut the following content into a little text\nfile called  scuff-scatter.args  and pipe it into\nthe standard input of  scuff-scatter :  geometry        HoleyScreen_1228.scuffgeo\nFVMesh          FVMesh_7400.msh\nLambda          0.3751\nLambda          0.2501\nLambda          0.1251\npwDirection     0 0 1\npwPolarization  1 0 0   Note that I have chosen wavelengths of  \\lambda=\\{1.5,1.0,0.5\\}R  where  R=0.25\\,\\mu m is \nthe hole radius. In each case I have shifted the wavelength by a \ntiny amount away from being commensurate with the lattice period\nto avoid numerical instabilities associated with Wood anomalies.   % scuff-scatter   scuff-scatter.args\n % scuff-scatter --geometry HoleyScreen_2318.scuffgeo   scuff-scatter.args  In the second command line here, the command-line specified \ngeometry overrides the geometry in the  .args  file.   This produces the files  HoleyScreen_1228.FVMesh_7400.pp \nand  HoleyScreen_2318.FVMesh_7400.pp , which can be\nvisualized by opening them in  gmsh .  \n  \n     \n     \n  \n  \n     =1.5 R (coarse mesh)\n     =1.5 R (fine mesh)\n  \n  \n     \n     \n  \n  \n     =1.0 R (coarse mesh)\n     =1.0 R (fine mesh)\n  \n  \n     \n     \n  \n  \n     =0.5 R (coarse mesh)\n     =0.5 R (fine mesh)", 
            "title": "Running scuff-scatter"
        }, 
        {
            "location": "/examples/CubeTorus/", 
            "text": "Casimir forces between compact objects: A cube--torus geometry\n\n\nThis section of the \nscuff-em\n documentation has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of this section of the documentation.", 
            "title": "Casimir forces in a compact geometry"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/", 
            "text": "Casimir forces between infinitely extended silicon beams (1D periodicity)\n\n\n\nIn this example, we exploit \nscuff-em\n's \nsupport for 1D periodic geometries\nto compute the equilibrium Casimir force per unit length \nbetween infinitely extended silicon beams of \nrounded rectangular cross section.\nThe files for this example may be found in the\n\nshare/scuff-em/examples/SiliconBeams\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file for unit-cell geometry\n\n\nThe \ngmsh\n geometry file \n\nRoundedBeamUnitCell.geo\n\ndescribes the portion of the surface of a single\nbeam that lies within the \nunit cell,\n\ni.e. the cell that is infinitely periodically\nreplicated to yield the full geometry.\nTo produce a discretized surface-mesh\nrepresentation of this geometry, we run it through \n\ngmsh\n:\n\n\n% gmsh -2 RoundedBeamUnitCell.geo\n\n\n\n\nThis produces the file \nRoundedBeamUnitCell.msh\n, which\nI rename to \nRoundedBeamUnitCell_192.msh\n because 192\nis the number of interior edges (this information may be \nfound, for example, by running \n\nscuff-analyze --mesh RoundedBeamUnitCell.msh\n).\nYou can open the \n.msh\n file in \ngmsh\n to visualize\nthe unit-cell mesh:\n\n\n% gmsh RoundedBeamUnitCell_192.msh\n\n\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 1D periodic geometries in \nscuff-em\n, the direction\n   of infinite extent must be the \nx\n direction.\n\n\n\n\n\n\nOnly the sidewall of the cylinder is meshed;\n   the endcaps must not be meshed.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on the unit-cell boundary must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nIn this case the unit cell is 1 \n\\mu\nm long.\n   (More generally, the unit cell could have any \n   length you like.)\n\n\n\n\n\n\n\n\nscuff-em\n geometry file\n\n\nThe \nscuff-em\n \n\ngeometry file\n \ndescribing our two infinite-length silicon beams is\n\nSiliconBeams_192.scuffgeo\n.\nThis specifies a geometry consisting of two identical\nsilicon beams, of infinite extent in the \nx\n direction,\nseparated by a distance of 2 \n\\mu\nm in the \nz\n direction.\nThe infinite beams consist of the finite-length unit-cell\ngeometry, periodically replicated infinitely many times.\n(The length of the lattice vector specified by the \nLATTICE\n\nstatement should agree with the length of the unit cell as \ndefined in the \ngmsh\n geometry file.)\n\n\nLATTICE\n    VECTOR 1.0 0.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT Beam1\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\nENDOBJECT\n\nOBJECT Beam2\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\n    DISPLACED 0 0 2\nENDOBJECT\n\n\n\n\nWe can use \nscuff-analyze\n to visualize the geometry \ndescribed by this \n.scuffgeo\n file:\n\n\n% scuff-analyze --geometry SiliconBeams_192.scuffgeo --WriteGMSHFiles --Neighbors 2\n\n\n\n\n[The option \n--Neighbors 2\n requests that, in addition to the unit-cell\ngeometry, the first 2 periodic images of the unit cell \nin both the \npositive and negative directions\n (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file \nSiliconBeams_192.pp\n, which you \ncan view in \ngmsh\n:\n\n\n% gmsh SiliconBeams_192.pp\n\n\n\n\n\n\nNote that the visualization file produced by \nscuff-analyze\n includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called \nstraddlers\n,\nand they are added automatically by \nscuff-em\n to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.\n\n\n\n\nscuff-em\n transformation file\n\n\nIn Casimir problems we typically want to compute\nforces (or torques, or energies) at multiple\nvalues of the surface--surface separation.\nThis is done by writing a \n\ntransformation file\n.\nIn this case we'll request the Casimir force between\nthe beams for 9 distinct values of the surface-surface\nseparation ranging between 1-5\n\\mu\nm.\nThe file that specifies this is called\n\nBeams.trans\n:\n\n\nTRANS 1.00 OBJECT Beam2 DISP 0 0 0.00\nTRANS 1.50 OBJECT Beam2 DISP 0 0 0.50\nTRANS 2.00 OBJECT Beam2 DISP 0 0 1.00\nTRANS 2.50 OBJECT Beam2 DISP 0 0 1.50\nTRANS 3.00 OBJECT Beam2 DISP 0 0 2.00\nTRANS 3.50 OBJECT Beam2 DISP 0 0 2.50\nTRANS 4.00 OBJECT Beam2 DISP 0 0 3.00\nTRANS 4.50 OBJECT Beam2 DISP 0 0 3.50\nTRANS 5.00 OBJECT Beam2 DISP 0 0 4.00\n\n\n\n\nFor full details on \nscuff-em\n\ntransformation files, see \n\nthis reference page\n.\nFor the time being, note the following:\n\n\n\n\n\n\nThe text \nTRANS 4.00\n specifies the string \n4.00\n\n   as the \nname\n of this transformation. This is the string\n   that will be written to output files to identify\n   the Casimir quantities corresponding to each \n   geometrical transformation. This can be any \n   string not including spaces (in particular, it \n   need not be a number), but it's usually convenient\n   to label transformations by numbers so that we can \n   subsequently plot e.g. force vs. distance.\n\n\n\n\n\n\nThe text \nOBJECT Beam2 DISP 0 0 3.00\n specifies \n   that, in this particular geometrical transformation,\n   the object labeled \nBeam2\n in the \n.scuffgeo\n file \n   is to be displaced 3 \n\\mu\nm in the \nz\n direction.\n\n\n\n\n\n\nWhy do we assign the label \n4.00\n to a transformation\n   in which the displacement is 3 \n\\mu\nm? Because \n   transformations are \nrelative\n to the configuration\n   described in the \n.scuffgeo\n file, and in the \n   \n.scuffgeo\n file discussed above the second beam\n   is already displaced a distance of 2 \n\\mu\nm from\n   the first beam, which means the default\n   surface-surface separation is 1 \n\\mu\nm.\n   Applying an addition 3 \n\\mu\nm displacement then\n   yields a surface-surface separation of 4 \n\\mu\nm.\n\n\n\n\n\n\nYou can use \nscuff-analyze\n to obtain a \nvisualization of what your geometry looks \nlike under each transformation:\n\n\n% scuff-analyze --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans\n\n\n\n\nThis produces a file named \nSiliconBeams_192.transformed.pp\n, which\nyou can open in \ngmsh\n to confirm that the transformations you\ngot are the ones you wanted.\n\n\n\n\nA first trial run of \nscuff-cas3d\n at a single frequency\n\n\nTo compute the full Casimir force per unit length\nbetween the beams (call this quantity \n\\mathcal F\n), \n\nscuff-cas3d\n numerically evaluates an\nintegral over both imaginary frequencies \n\\xi\n and Bloch \nwavenumbers \nk\n:\n\n \\mathcal F \n  = \\int_0^\\infty d\\xi\n           \\underbrace{\\left [ \\frac{1}{V_{\\scriptsize{BZ}}}\n                                \\int_{V_{\\scriptsize{BZ}}}\n                                f(\\xi, k) dk \\,\n                       \\right]\n                      }_{\\equiv F(\\xi)}\n\n\nwhere the \nk\n integral is over the Brillouin zone (BZ)\nand \nV_{\\scriptsize{BZ}}\n is the one-dimensional volume \nof the BZ. For a 1D periodic geometry, the Brillouin \nzone is the 1D interval \n0\\le k \\le \\frac{2\\pi}{L}\n,\nand its one-dimensional volume (its length) is \n\\frac{2\\pi}{L}\n,\nwhere \nL=1\\, \\mu\nm is the length of the real-space unit cell.\n,\nBecause the full calculation can be somewhat time-consuming,\nit's often useful to run a quick \nsingle-frequency\n\ncalculation just to make sure things are making sense\nbefore launching the full run. We do this by \nspecifying the \n--Xi\n command-line option to\n\nscuff-cas3d\n, which requests a calculation\nof just the quantity \nF(\\xi)\n in the above\nequation at a single imaginary frequency \n\\xi\n.\n(Note that, for our 1D periodic geometry,\nthis single-frequency calculation still entails a \nwavenumber integration over the 1D Brillouin zone.)\n\n\n % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce --xi 0.7\n\n\n\n\nThis produces (among other files) files called \n\nSiliconBeams_192.byXi\n\nand \n\nSiliconBeams_192.byXikBloch.\n\nThe former file reports values of the quantity \nF(\\xi)\n,\nat the requested value of \n\\xi\n, for each of the\ntransformations in the \n.trans\n file. The latter\nfile gives more granular information: it reports \nvalues of the quantity \nf(\\xi,k)\n at the requested \nvalue of \n\\xi\n and at each \nk\n point sampled by \nthe built-in numerical integrator.\n\n\nThe file \nSiliconBeams_192.byXi\n looks like this:\n\n\n# scuff-cas3D run on superhr1 at 06/07/15::01:01:38\n# data file columns: \n#1: transform tag\n#2: imaginary angular frequency\n#3: z-force Xi integrand\n#4: z-force error due to numerical Brillouin-zone integration \n1.00 7.000000e-01 1.53365587e-02 1.10343992e-05\n1.50 7.000000e-01 3.27174955e-03 6.54894735e-06\n...\n5.00 7.000000e-01 2.84878401e-06 4.63609357e-08\n\n\n\n\nAs the file header says, the first column here is the\ntransform tag (the surface--surface separation), \nthe second column is the imaginary angular frequency \nin units of \n\\xi_0=3\\cdot 10^{14}\n rad/sec, and the\nthird column is the Casimir force per unit length \nper unit frequency (in units of \n \n\\hbar c/(\\omega_0 L_0^3)=31.6 (\\text{fN/micron})/\\omega_0\n\n)\nwhere \nL_0=1\\mu\\text{m}\n and \nwhere \n\\text{fN}\n=femtoNewtons.\n\n\n\n\nThe full run\n\n\nNow just launch the full run:\n\n\n % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce\n\n\n\n\n(This is the same command line as before, just without the \n\n--Xi\n option.) \n\n\nAfter some computation, this produces the output file \n\nSiliconBeams_192.out\n. You can plot the force (per unit length)\nversus surface--surface separation using e.g. \ngnuplot\n:\n\n\n% gnuplot\ngnuplot\n set xlabel 'Surface--surface separation (microns)'\ngnuplot\n set ylabel 'Casimir force per unit length (31.6 fN/micron)'\ngnuplot\n set logscale y\ngnuplot\n plot 'SiliconBeams_192.out' u 1:3 w lp pt 7 ps 1.5", 
            "title": "Casimir forces in a 1D extended geometry"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#scuff-em-geometry-file", 
            "text": "The  scuff-em   geometry file  \ndescribing our two infinite-length silicon beams is SiliconBeams_192.scuffgeo .\nThis specifies a geometry consisting of two identical\nsilicon beams, of infinite extent in the  x  direction,\nseparated by a distance of 2  \\mu m in the  z  direction.\nThe infinite beams consist of the finite-length unit-cell\ngeometry, periodically replicated infinitely many times.\n(The length of the lattice vector specified by the  LATTICE \nstatement should agree with the length of the unit cell as \ndefined in the  gmsh  geometry file.)  LATTICE\n    VECTOR 1.0 0.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT Beam1\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\nENDOBJECT\n\nOBJECT Beam2\n    MESHFILE RoundedBeamUnitCell_192.msh\n    MATERIAL Silicon\n    DISPLACED 0 0 2\nENDOBJECT  We can use  scuff-analyze  to visualize the geometry \ndescribed by this  .scuffgeo  file:  % scuff-analyze --geometry SiliconBeams_192.scuffgeo --WriteGMSHFiles --Neighbors 2  [The option  --Neighbors 2  requests that, in addition to the unit-cell\ngeometry, the first 2 periodic images of the unit cell  in both the \npositive and negative directions  (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file  SiliconBeams_192.pp , which you \ncan view in  gmsh :  % gmsh SiliconBeams_192.pp   Note that the visualization file produced by  scuff-analyze  includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called  straddlers ,\nand they are added automatically by  scuff-em  to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.", 
            "title": "scuff-em geometry file"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#scuff-em-transformation-file", 
            "text": "In Casimir problems we typically want to compute\nforces (or torques, or energies) at multiple\nvalues of the surface--surface separation.\nThis is done by writing a  transformation file .\nIn this case we'll request the Casimir force between\nthe beams for 9 distinct values of the surface-surface\nseparation ranging between 1-5 \\mu m.\nThe file that specifies this is called Beams.trans :  TRANS 1.00 OBJECT Beam2 DISP 0 0 0.00\nTRANS 1.50 OBJECT Beam2 DISP 0 0 0.50\nTRANS 2.00 OBJECT Beam2 DISP 0 0 1.00\nTRANS 2.50 OBJECT Beam2 DISP 0 0 1.50\nTRANS 3.00 OBJECT Beam2 DISP 0 0 2.00\nTRANS 3.50 OBJECT Beam2 DISP 0 0 2.50\nTRANS 4.00 OBJECT Beam2 DISP 0 0 3.00\nTRANS 4.50 OBJECT Beam2 DISP 0 0 3.50\nTRANS 5.00 OBJECT Beam2 DISP 0 0 4.00  For full details on  scuff-em \ntransformation files, see  this reference page .\nFor the time being, note the following:    The text  TRANS 4.00  specifies the string  4.00 \n   as the  name  of this transformation. This is the string\n   that will be written to output files to identify\n   the Casimir quantities corresponding to each \n   geometrical transformation. This can be any \n   string not including spaces (in particular, it \n   need not be a number), but it's usually convenient\n   to label transformations by numbers so that we can \n   subsequently plot e.g. force vs. distance.    The text  OBJECT Beam2 DISP 0 0 3.00  specifies \n   that, in this particular geometrical transformation,\n   the object labeled  Beam2  in the  .scuffgeo  file \n   is to be displaced 3  \\mu m in the  z  direction.    Why do we assign the label  4.00  to a transformation\n   in which the displacement is 3  \\mu m? Because \n   transformations are  relative  to the configuration\n   described in the  .scuffgeo  file, and in the \n    .scuffgeo  file discussed above the second beam\n   is already displaced a distance of 2  \\mu m from\n   the first beam, which means the default\n   surface-surface separation is 1  \\mu m.\n   Applying an addition 3  \\mu m displacement then\n   yields a surface-surface separation of 4  \\mu m.    You can use  scuff-analyze  to obtain a \nvisualization of what your geometry looks \nlike under each transformation:  % scuff-analyze --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans  This produces a file named  SiliconBeams_192.transformed.pp , which\nyou can open in  gmsh  to confirm that the transformations you\ngot are the ones you wanted.", 
            "title": "scuff-em transformation file"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#a-first-trial-run-of-scuff-cas3d-at-a-single-frequency", 
            "text": "To compute the full Casimir force per unit length\nbetween the beams (call this quantity  \\mathcal F ),  scuff-cas3d  numerically evaluates an\nintegral over both imaginary frequencies  \\xi  and Bloch \nwavenumbers  k :  \\mathcal F \n  = \\int_0^\\infty d\\xi\n           \\underbrace{\\left [ \\frac{1}{V_{\\scriptsize{BZ}}}\n                                \\int_{V_{\\scriptsize{BZ}}}\n                                f(\\xi, k) dk \\,\n                       \\right]\n                      }_{\\equiv F(\\xi)} \nwhere the  k  integral is over the Brillouin zone (BZ)\nand  V_{\\scriptsize{BZ}}  is the one-dimensional volume \nof the BZ. For a 1D periodic geometry, the Brillouin \nzone is the 1D interval  0\\le k \\le \\frac{2\\pi}{L} ,\nand its one-dimensional volume (its length) is  \\frac{2\\pi}{L} ,\nwhere  L=1\\, \\mu m is the length of the real-space unit cell.\n,\nBecause the full calculation can be somewhat time-consuming,\nit's often useful to run a quick  single-frequency \ncalculation just to make sure things are making sense\nbefore launching the full run. We do this by \nspecifying the  --Xi  command-line option to scuff-cas3d , which requests a calculation\nof just the quantity  F(\\xi)  in the above\nequation at a single imaginary frequency  \\xi .\n(Note that, for our 1D periodic geometry,\nthis single-frequency calculation still entails a \nwavenumber integration over the 1D Brillouin zone.)   % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce --xi 0.7  This produces (among other files) files called  SiliconBeams_192.byXi \nand  SiliconBeams_192.byXikBloch. \nThe former file reports values of the quantity  F(\\xi) ,\nat the requested value of  \\xi , for each of the\ntransformations in the  .trans  file. The latter\nfile gives more granular information: it reports \nvalues of the quantity  f(\\xi,k)  at the requested \nvalue of  \\xi  and at each  k  point sampled by \nthe built-in numerical integrator.  The file  SiliconBeams_192.byXi  looks like this:  # scuff-cas3D run on superhr1 at 06/07/15::01:01:38\n# data file columns: \n#1: transform tag\n#2: imaginary angular frequency\n#3: z-force Xi integrand\n#4: z-force error due to numerical Brillouin-zone integration \n1.00 7.000000e-01 1.53365587e-02 1.10343992e-05\n1.50 7.000000e-01 3.27174955e-03 6.54894735e-06\n...\n5.00 7.000000e-01 2.84878401e-06 4.63609357e-08  As the file header says, the first column here is the\ntransform tag (the surface--surface separation), \nthe second column is the imaginary angular frequency \nin units of  \\xi_0=3\\cdot 10^{14}  rad/sec, and the\nthird column is the Casimir force per unit length \nper unit frequency (in units of \n  \\hbar c/(\\omega_0 L_0^3)=31.6 (\\text{fN/micron})/\\omega_0 \n)\nwhere  L_0=1\\mu\\text{m}  and \nwhere  \\text{fN} =femtoNewtons.", 
            "title": "A first trial run of scuff-cas3d at a single frequency"
        }, 
        {
            "location": "/examples/SiliconBeams/SiliconBeams/#the-full-run", 
            "text": "Now just launch the full run:   % scuff-cas3d --geometry SiliconBeams_192.scuffgeo --TransFile Beams.trans --zforce  (This is the same command line as before, just without the  --Xi  option.)   After some computation, this produces the output file  SiliconBeams_192.out . You can plot the force (per unit length)\nversus surface--surface separation using e.g.  gnuplot :  % gnuplot\ngnuplot  set xlabel 'Surface--surface separation (microns)'\ngnuplot  set ylabel 'Casimir force per unit length (31.6 fN/micron)'\ngnuplot  set logscale y\ngnuplot  plot 'SiliconBeams_192.out' u 1:3 w lp pt 7 ps 1.5", 
            "title": "The full run"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/", 
            "text": "Casimir forces between infinite-area silicon slabs (2D periodicity)\n\n\n\nIn this example, we exploit \nscuff-em\n's\n\nsupport for 2D periodic geometries\n\nto compute the equilibrium Casimir force per unit area\nbetween silicon slabs of infinite surface area.\nThe files for this example may be found in the\n\nshare/scuff-em/examples/SiliconSlabs\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file for unit-cell geometry\n\n\nThe \ngmsh\n geometry file \nSquare_N.geo\n\ndescribes the portion of the surface of a single\nslab that lies within the \nunit cell,\n\ni.e. the cell that is infinitely periodically\nreplicated to yield the full geometry.\nIn this case, the slab is infinitely thick (it is a \nhalf-space), so its surface consists of just a single\ntwo-dimensional sheet extending throughout the entire\nunit cell. I call this file \nSquare_N.geo\n to \nremind myself that it contains a parameter \nN\n \nthat describes the meshing fineness; more specifically,\n\nN\n defines the number of segments per unit length.\n\n\nTo produce a discretized surface-mesh\nrepresentation of this geometry, we run it through \n\ngmsh\n:\n\n\n% gmsh -2 Square_N.geo\n\n\n\n\nThis produces the file \nSquare_N.msh\n, which\nI rename to \nSquare_L2.40.msh\n because the side length\nof the square is \nL=2\\,\\mu\\text{m}\n and because\nthis particular mesh has 40 interior edges (this\nnumber defines the number of surface-current basis\nfunctions and thus the size of the BEM matrix in a\n\nscuff-em\n calculation). Editing the \n.geo\n file\nto change the \nN\n parameter to 3 (from its default \nvalue of 2) and re-running \ngmsh -2\n produces a\nfiner mesh file, which I rename to \nSquare_L2_96.msh\n.\nThese meshes may be visualized in \ngmsh\n:\n\n\n% gmsh Square_L2_40.msh\n% gmsh Square_L2_96.msh\n\n\n\n\n \nSquare_L2_40.msh\n\n\n\n\n \nSquare_L2_96.msh\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 2D periodic geometries in \nscuff-em\n, the \n   lattice vectors must lie in the \nxy\n plane.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on any edge of the unit cell must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nIn this case the unit cell dimensions are \n   \nL_x\\times L_y\n where \nL_x=L_y=2\\, \\mu\\text{m}\n.\n   (More generally, \nL_x\n and \nL_y\n may be any arbitrary\n   nonzero values, and they need not equal each other.)\n\n\n\n\n\n\n\n\nscuff-em\n geometry file\n\n\nThe \n\nscuff-em\n geometry file\n\ndescribing two silicon half-spaces (infinitely-thick slabs)\nbounded by the coarser of the two unit-cell meshes described \nabove is \nSiliconSlabs_L2_40.scuffgeo\n:\n\n\n# SCUFF-EM geometry file for two silicon slabs,\n# each of infinite cross-sectional area and infinite\n# thickness, separated in the z direction by 1 microns\n\nLATTICE\n    VECTOR 2.0 0.0\n    VECTOR 0.0 2.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nREGION UpperSlab MATERIAL Silicon\nREGION Gap       MATERIAL Vacuum\nREGION LowerSlab MATERIAL Silicon\n\nSURFACE UpperSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS UpperSlab Gap\n    DISPLACED 0 0 0.5\nENDOBJECT\n\nSURFACE LowerSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS LowerSlab Gap\nENDOBJECT\n\n\n\n\nNote the following points: \n\n\n\n\n\n\nEven though our geometry doesn't contain any \n\nmulti-material junctions\n,\nnonetheless we have to describe it using \n\nREGION\n and \nSURFACE\n statements\n\ninstead of \n\nOBJECT\n...\nENDOBJECT\n statements\n\nbecause the geometry can't be described as one or \nmore compact objects embedded in an exterior medium.\n\n\n\n\n\n\nIn the default configuration described by the \n.scuffgeo\n\nfile, the slab surfaces are displaced from each other\nby a distance of 0.5 \n\\mu\nm. The geometric transformations \ndescribed below will be relative to this default \nseparation.\n\n\n\n\n\n\n\n\nscuff-em\n transformation file\n\n\nThe file describing a list of\n\ngeometric transformations\n\nis \nSlabs.trans\n:\n\n\nTRANS 0.5 SURFACE UpperSurface DISP 0 0 0.0\nTRANS 1.0 SURFACE UpperSurface DISP 0 0 0.5\nTRANS 1.5 SURFACE UpperSurface DISP 0 0 1.0\nTRANS 2.0 SURFACE UpperSurface DISP 0 0 1.5\nTRANS 2.5 SURFACE UpperSurface DISP 0 0 2.0\nTRANS 3.0 SURFACE UpperSurface DISP 0 0 2.5\nTRANS 3.5 SURFACE UpperSurface DISP 0 0 3.0\nTRANS 4.0 SURFACE UpperSurface DISP 0 0 3.5\nTRANS 4.5 SURFACE UpperSurface DISP 0 0 4.0\nTRANS 5.0 SURFACE UpperSurface DISP 0 0 4.5\n\n\n\n\nIt's convenient to visualize the effect of these\ntransformations on our geometry before we run the calculation:\n\n\n% scuff-analyze --geometry SiliconSlabs_L2_40.scuffgeo --TransFile Slabs.trans\n\n\n\n\nThis produces the file \nSiliconSlabs_L2_40.transformed.pp\n,\nwhich can be visualized by opening it in \nGMSH\n:\n\n\n\n\n\n\nLaunching the run\n\n\nHere's a \nbash\n script that will run the full Casimir \ncalculation on both the coarser and finer meshes:\n\n\n# /bin/bash\n\nfor N in 40 192\ndo\n  ARGS=\n\n  ARGS=\n${ARGS} --geometry   SiliconSlabs_L2_${N}.scuffgeo\n\n  ARGS=\n${ARGS} --TransFile  Beams.trans\n\n  ARGS=\n${ARGS} --BZSymmetry BZSymmetry\n\n  ARGS=\n${ARGS} --energy\n\n  ARGS=\n${ARGS} --zForce\n\n\n  scuff-cas3D ${ARGS}\ndone\n\n\n\n\nThis produces the files \nSiliconSlabs_L2_40.out\n\nand \nSiliconSlabs_L2_96.out\n. The former file looks\nlike this:\n\n\n# scuff-cas3D run on superhr1 at 06/15/15::23:50:32\n# data file columns: \n#1: transform tag\n#2: energy \n#3: energy error due to numerical Xi integration \n#4: z-force \n#5: z-force error due to numerical Xi integration \n0.5 -1.254502e-01 5.463886e-05 -7.264755e-01 3.268714e-04 \n1.0 -1.631064e-02 5.770642e-06 -4.865678e-02 2.055737e-05 \n...\n\n\n\n\nNow plot the energy and force per unit area vs.\nseparation distance:\n\n\n% gnuplot\ngnuplot\n set xlabel 'surface--surface separation (um)'\ngnuplot\n set ylabel 'Energy / (\\hbar c / 1um), Force / ( \\hbar c/(1um^2) )'\ngnuplot\n set logscale y\ngnuplot\n FILE='SiliconSlabs_L2_N40.out'\ngnuplot\n plot FILE u 1:2 t 'Energy (SCUFF)', '' u 1:4 t 'Force (SCUFF)'\n\n\n\n\n\n\n\nIn this plot, the solid lines are the results of the Lifshitz\nformula for the Casimir energy and force between silicon\nslabs.", 
            "title": "Casimir forces in a 2D extended geometry"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/#scuff-em-geometry-file", 
            "text": "The  scuff-em  geometry file \ndescribing two silicon half-spaces (infinitely-thick slabs)\nbounded by the coarser of the two unit-cell meshes described \nabove is  SiliconSlabs_L2_40.scuffgeo :  # SCUFF-EM geometry file for two silicon slabs,\n# each of infinite cross-sectional area and infinite\n# thickness, separated in the z direction by 1 microns\n\nLATTICE\n    VECTOR 2.0 0.0\n    VECTOR 0.0 2.0\nENDLATTICE\n\nMATERIAL SILICON\n    epsf = 1.035;      # \\epsilon_infinity\n    eps0 = 11.87;      # \\epsilon_0 \n    wp = 6.6e15;       # \\plasmon frequency\n    Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nREGION UpperSlab MATERIAL Silicon\nREGION Gap       MATERIAL Vacuum\nREGION LowerSlab MATERIAL Silicon\n\nSURFACE UpperSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS UpperSlab Gap\n    DISPLACED 0 0 0.5\nENDOBJECT\n\nSURFACE LowerSurface\n    MESHFILE Square_L2_40.msh\n    REGIONS LowerSlab Gap\nENDOBJECT  Note the following points:     Even though our geometry doesn't contain any  multi-material junctions ,\nnonetheless we have to describe it using  REGION  and  SURFACE  statements \ninstead of  OBJECT ... ENDOBJECT  statements \nbecause the geometry can't be described as one or \nmore compact objects embedded in an exterior medium.    In the default configuration described by the  .scuffgeo \nfile, the slab surfaces are displaced from each other\nby a distance of 0.5  \\mu m. The geometric transformations \ndescribed below will be relative to this default \nseparation.", 
            "title": "scuff-em geometry file"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/#scuff-em-transformation-file", 
            "text": "The file describing a list of geometric transformations \nis  Slabs.trans :  TRANS 0.5 SURFACE UpperSurface DISP 0 0 0.0\nTRANS 1.0 SURFACE UpperSurface DISP 0 0 0.5\nTRANS 1.5 SURFACE UpperSurface DISP 0 0 1.0\nTRANS 2.0 SURFACE UpperSurface DISP 0 0 1.5\nTRANS 2.5 SURFACE UpperSurface DISP 0 0 2.0\nTRANS 3.0 SURFACE UpperSurface DISP 0 0 2.5\nTRANS 3.5 SURFACE UpperSurface DISP 0 0 3.0\nTRANS 4.0 SURFACE UpperSurface DISP 0 0 3.5\nTRANS 4.5 SURFACE UpperSurface DISP 0 0 4.0\nTRANS 5.0 SURFACE UpperSurface DISP 0 0 4.5  It's convenient to visualize the effect of these\ntransformations on our geometry before we run the calculation:  % scuff-analyze --geometry SiliconSlabs_L2_40.scuffgeo --TransFile Slabs.trans  This produces the file  SiliconSlabs_L2_40.transformed.pp ,\nwhich can be visualized by opening it in  GMSH :", 
            "title": "scuff-em transformation file"
        }, 
        {
            "location": "/examples/SiliconSlabs/SiliconSlabs/#launching-the-run", 
            "text": "Here's a  bash  script that will run the full Casimir \ncalculation on both the coarser and finer meshes:  # /bin/bash\n\nfor N in 40 192\ndo\n  ARGS= \n  ARGS= ${ARGS} --geometry   SiliconSlabs_L2_${N}.scuffgeo \n  ARGS= ${ARGS} --TransFile  Beams.trans \n  ARGS= ${ARGS} --BZSymmetry BZSymmetry \n  ARGS= ${ARGS} --energy \n  ARGS= ${ARGS} --zForce \n\n  scuff-cas3D ${ARGS}\ndone  This produces the files  SiliconSlabs_L2_40.out \nand  SiliconSlabs_L2_96.out . The former file looks\nlike this:  # scuff-cas3D run on superhr1 at 06/15/15::23:50:32\n# data file columns: \n#1: transform tag\n#2: energy \n#3: energy error due to numerical Xi integration \n#4: z-force \n#5: z-force error due to numerical Xi integration \n0.5 -1.254502e-01 5.463886e-05 -7.264755e-01 3.268714e-04 \n1.0 -1.631064e-02 5.770642e-06 -4.865678e-02 2.055737e-05 \n...  Now plot the energy and force per unit area vs.\nseparation distance:  % gnuplot\ngnuplot  set xlabel 'surface--surface separation (um)'\ngnuplot  set ylabel 'Energy / (\\hbar c / 1um), Force / ( \\hbar c/(1um^2) )'\ngnuplot  set logscale y\ngnuplot  FILE='SiliconSlabs_L2_N40.out'\ngnuplot  plot FILE u 1:2 t 'Energy (SCUFF)', '' u 1:4 t 'Force (SCUFF)'   In this plot, the solid lines are the results of the Lifshitz\nformula for the Casimir energy and force between silicon\nslabs.", 
            "title": "Launching the run"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/", 
            "text": "Casimir-Polder potentials in dielectric nanostructures\n\n\n\nIn this example, we exploit \nscuff-em\n's support for periodic\ngeometries to compute Casimir-Polder potentials for atoms inside\ndielectric waveguides. Our basic test example will be the 1D \nphotonic crystal studied in this paper:\n\n\n\n\nC. L. Hung, S. M. Meenehan, D. E. Chang, O. Painter,\n    H. J. Kimble, ``Trapped atoms in one-dimensional\n    photonic crystals.'' \nNew Journal of Physics\n \n15\n\n    083026 (2013).\n\n\n\n\nWe will illustrate the use of \nscuff-em\n's Casimir-Polder\nmodule \nscuff-caspol\n by reproducing the results of \nHung et al. for a 1D lattice, then extend the calculation\nto the case of a 2D square lattice.\nThe files for this example may be found in the\n\nshare/scuff-em/examples/NanobeamCasimirPolder\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry and surface mesh for nanobeam unit cell\n\n\nThe \ngmsh\n geometry file \nUnitCell.geo\n\ndescribes just the portion of the nanobeam surface that \nlies within the \nunit cell,\n i.e. the cell that is \ninfinitely periodically replicated to yield the full \ngeometry. To produce a discretized surface-mesh\nrepresentation of this geometry, we run it through\n\ngmsh\n:\n\n\n% gmsh -2 UnitCell.geo\n\n\n\n\nThis produces a file named \nUnitCell.msh\n, which\nI rename to \nNanoBeamUnitCell_1006_.msh\n because\n\n(a)\n I will be using it as the unit cell of a beam\ngeometry, in contrast to a different use I will find\nfor the same unit cell below; and \n(b)\n the mesh has 1006 \ninterior edges (this is the number that defines the \nmemory and computation time requirements for the \n\nscuff-em\n calculation; it may be found by running\n\nscuff-analyze --mesh UnitCell.msh\n).\nYou can open the \n.msh\n file in \ngmsh\n to visualize\nthe unit-cell mesh:\n\n\n% gmsh NanoBeamUnitCell_1006.msh\n\n\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 1D periodic geometries in \nscuff-em\n, the direction\n   of infinite extent must be the \nx\n direction.\n\n\n\n\n\n\nThe sidewalls normal to the \ny\n and \nz\n directions are \n   meshed, but the sidewalls normal to the \nx\n direction are \n   \nnot\n meshed for this structure, because those surfaces are \n   not interfaces between different dielectrics.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on the unit-cell boundary must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nIn this case the unit cell is 0.367 \n\\mu\nm long.\n   This and other geometric parameters can be modified \n   by editing the file \nUnitCell.geo\n or directly\n   on the \ngmsh\n commmand line using the \n-setnumber\n option.\n\n\n\n\n\n\n\n\nscuff-em\n geometry file for dielectric nanobeam\n\n\nA \nscuff-em\n [geometry file]\nscuffEMGeometries\n \ndescribing an extended nanobeam consisting of infinitely\nmany repetitions of the above unit cell filled with\na dielectric material of constant relative permittivity\n\n\\epsilon=4\n, is \n\nNanoBeam_1006.scuffgeo\n.\nThe file reads, in its entirety, \n\n\nLATTICE\n    VECTOR 0.367 0.0\nENDLATTICE\n\nOBJECT Nanobeam\n    MESHFILE NanoBeamUnitCell_1006.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT\n\n\n\n\nWe can use \nscuff-analyze\n to visualize the geometry \ndescribed by this \n.scuffgeo\n file:\n\n\n% scuff-analyze --geometry NanoBeam_1006.scuffgeo --WriteGMSHFiles --Neighbors 3\n\n\n\n\n[The option \n--Neighbors 3\n requests that, in addition to the unit-cell\ngeometry, the first 3 periodic images of the unit cell \nin both the \npositive and negative directions\n (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file \nNanoBeam_1006.pp\n, which you \ncan view in \ngmsh\n:\n\n\n% gmsh NanoBeam_1006.pp\n\n\n\n\n\n\nNote that the visualization file produced by \nscuff-analyze\n includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called \nstraddlers\n,\nand they are added automatically by \nscuff-em\n to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.\n\n\n\n\ngmsh\n geometry and surface mesh for nanoarray unit cell\n\n\nIt's easy to generalize all of this to a geometry\nwith two-dimensional periodicity. The only modification\nrequired to the unit-cell mesh is that we have to \nremove the sidewalls normal to the \ny\n direction.\nThis can be done using the same \ngmsh\n geometry\nwe used above for the nanobeam unit cell, but with \nthe extra command-line option \n-setnumber LDim 2\n\non the \ngmsh\n command line. (Here \nLDim\n stands\nfor \"lattice dimension\".)\n\n\n% gmsh -2 -setnumber LDim 2 UnitCell.geo\n\n\n\n\nThis produces a file named \nUnitCell.msh\n, which\nI rename to \nNanoArrayUnitCell_800_.msh.\n It looks like this\n\n\n\n\n\n\nscuff-em\n geometry file for dielectric nanoarray\n\n\nA \n \nscuff-em\n geometry file\n\ndescribing a dielectric surface extended in two\ndimensions and perforated with a square lattice\nof the holes pictured above is \n\nNanoArray_800.scuffgeo\n.\nThe file reads\n\n\nLATTICE\n    VECTOR 0.367  0.0\n    VECTOR 0.000  0.845\nENDLATTICE\n\nOBJECT NanoArray\n    MESHFILE NanoArrayUnitCell_800.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT\n\n\n\n\nAgain we use \nscuff-analyze\n to visualize the geometry\ndescribed by this \n.scuffgeo\n file:\n\n\n% scuff-analyze --geometry NanoArray_800.scuffgeo --WriteGMSHFiles --Neighbors 3\n\n\n\n\n\n\n\n\nEvaluation points for Casimir-Polder potentials\n\n\nFor a Casimir-Polder calculation we will want to evaluate\nthe Casimir-Polder potential at range of points. We \nput the Cartesian coordinates of these points into a \ntext file named \nEPFile\n, which looks like \nthis:\n\n\n0.1835 0.4225 -0.500\n0.1835 0.4225 -0.480\n0.1835 0.4225 -0.460\n...\n0.1835 0.4225 0.480\n0.1835 0.4225 0.500\n\n\n\n\nand defines a line of points running through the middle of the hole\nin the beam unit cell.\n\n\nTo double-check that the evaluation points we specify\nare actually where we expect them to be vis-a-vis the \nmeshed surfaces in our problem, we can ask \nscuff-analyze\n\nto plot the evaluation points together with the \nunit-cell geometry:\n\n\n % scuff-analyze --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --WriteGMSHFiles\n\n\n\n\n\n\nThis confirms that our \nEPFile\n describes a line of evaluation\npoints running through the middle of the hole in the beam \nstructure, as desired.\n\n\n\n\nSetting up the Casimir-Polder calculation\n\n\nTo compute the Casimir-Polder potential on, say,\na rubidium atom at the above evaluation points\nfor the 1D and 2D extended structures, we now say simply\n\n\n  % scuff-caspol --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --Atom Rubidium\n\n\n\n\nand/or\n\n\n  % scuff-caspol --geometry NanoArray_800.scuffgeo --EPFile EPFile --Atom Rubidium\n\n\n\n\nThese calculations will produce files named \nNanoBeam_1006.out\n and \n\nNanoArray_800.out\n tabulating the Casimir-Polder potential \nexperience by the rubidium atom at each of the specified evaluation\npoints.\n\n\nFor more information on \nscuff-caspol\n, see the \n\nold \nscuff-caspol\n documentation\n,\nwhich is thorough and up-to-date (though it does not \ncover CP calculations in extended geometries) despite \nhaving not yet been ported from its previous format.", 
            "title": "Casimir-Polder potentials in dielectric nanostructures"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#scuff-em-geometry-file-for-dielectric-nanobeam", 
            "text": "A  scuff-em  [geometry file] scuffEMGeometries  \ndescribing an extended nanobeam consisting of infinitely\nmany repetitions of the above unit cell filled with\na dielectric material of constant relative permittivity \\epsilon=4 , is  NanoBeam_1006.scuffgeo .\nThe file reads, in its entirety,   LATTICE\n    VECTOR 0.367 0.0\nENDLATTICE\n\nOBJECT Nanobeam\n    MESHFILE NanoBeamUnitCell_1006.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT  We can use  scuff-analyze  to visualize the geometry \ndescribed by this  .scuffgeo  file:  % scuff-analyze --geometry NanoBeam_1006.scuffgeo --WriteGMSHFiles --Neighbors 3  [The option  --Neighbors 3  requests that, in addition to the unit-cell\ngeometry, the first 3 periodic images of the unit cell  in both the \npositive and negative directions  (for a total of 5 copies of the \nunit cell) be plotted as well. This helps to convey a slightly\nbetter sense of the actual infinite-length structure being \nsimulated.] This produces the file  NanoBeam_1006.pp , which you \ncan view in  gmsh :  % gmsh NanoBeam_1006.pp   Note that the visualization file produced by  scuff-analyze  includes\nextra triangles (visible at the left end of the structure) that are\nnot present in the unit-cell geometry. These are called  straddlers ,\nand they are added automatically by  scuff-em  to account for \nsurface currents that flow across the unit-cell boundaries in \nperiodic geometries.", 
            "title": "scuff-em geometry file for dielectric nanobeam"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#gmsh-geometry-and-surface-mesh-for-nanoarray-unit-cell", 
            "text": "It's easy to generalize all of this to a geometry\nwith two-dimensional periodicity. The only modification\nrequired to the unit-cell mesh is that we have to \nremove the sidewalls normal to the  y  direction.\nThis can be done using the same  gmsh  geometry\nwe used above for the nanobeam unit cell, but with \nthe extra command-line option  -setnumber LDim 2 \non the  gmsh  command line. (Here  LDim  stands\nfor \"lattice dimension\".)  % gmsh -2 -setnumber LDim 2 UnitCell.geo  This produces a file named  UnitCell.msh , which\nI rename to  NanoArrayUnitCell_800_.msh.  It looks like this", 
            "title": "gmsh geometry and surface mesh for nanoarray unit cell"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#scuff-em-geometry-file-for-dielectric-nanoarray", 
            "text": "A    scuff-em  geometry file \ndescribing a dielectric surface extended in two\ndimensions and perforated with a square lattice\nof the holes pictured above is  NanoArray_800.scuffgeo .\nThe file reads  LATTICE\n    VECTOR 0.367  0.0\n    VECTOR 0.000  0.845\nENDLATTICE\n\nOBJECT NanoArray\n    MESHFILE NanoArrayUnitCell_800.msh\n    MATERIAL CONST_EPS_4\nENDOBJECT  Again we use  scuff-analyze  to visualize the geometry\ndescribed by this  .scuffgeo  file:  % scuff-analyze --geometry NanoArray_800.scuffgeo --WriteGMSHFiles --Neighbors 3", 
            "title": "scuff-em geometry file for dielectric nanoarray"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#evaluation-points-for-casimir-polder-potentials", 
            "text": "For a Casimir-Polder calculation we will want to evaluate\nthe Casimir-Polder potential at range of points. We \nput the Cartesian coordinates of these points into a \ntext file named  EPFile , which looks like \nthis:  0.1835 0.4225 -0.500\n0.1835 0.4225 -0.480\n0.1835 0.4225 -0.460\n...\n0.1835 0.4225 0.480\n0.1835 0.4225 0.500  and defines a line of points running through the middle of the hole\nin the beam unit cell.  To double-check that the evaluation points we specify\nare actually where we expect them to be vis-a-vis the \nmeshed surfaces in our problem, we can ask  scuff-analyze \nto plot the evaluation points together with the \nunit-cell geometry:   % scuff-analyze --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --WriteGMSHFiles   This confirms that our  EPFile  describes a line of evaluation\npoints running through the middle of the hole in the beam \nstructure, as desired.", 
            "title": "Evaluation points for Casimir-Polder potentials"
        }, 
        {
            "location": "/examples/NanostructureCasimirPolder/NanostructureCasimirPolder/#setting-up-the-casimir-polder-calculation", 
            "text": "To compute the Casimir-Polder potential on, say,\na rubidium atom at the above evaluation points\nfor the 1D and 2D extended structures, we now say simply    % scuff-caspol --geometry NanoBeam_1006.scuffgeo --EPFile EPFile --Atom Rubidium  and/or    % scuff-caspol --geometry NanoArray_800.scuffgeo --EPFile EPFile --Atom Rubidium  These calculations will produce files named  NanoBeam_1006.out  and  NanoArray_800.out  tabulating the Casimir-Polder potential \nexperience by the rubidium atom at each of the specified evaluation\npoints.  For more information on  scuff-caspol , see the  old  scuff-caspol  documentation ,\nwhich is thorough and up-to-date (though it does not \ncover CP calculations in extended geometries) despite \nhaving not yet been ported from its previous format.", 
            "title": "Setting up the Casimir-Polder calculation"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/", 
            "text": "Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres\n\n\nIn this example, we use \nscuff-neq\n to compute \n(1)\n the\npower radiated by a single SiO2 sphere, and \n(2)\n the heat\ntransfer and non-equilibrium Casimir force between two SiO2\nspheres. We compare the results of \nscuff-neq\n to \nthe predictions of the \n\nT-matrix formalism of Krueger et al\n.\n\n\nThe files for this example may be found in the \n\nshare/scuff-em/examples/SiO2Spheres\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry file and surface mesh for a single sphere\n\n\nThe \ngmsh\n geometry file \nSphere.geo\n\ndescribes a sphere of radius 1 micron; it may \nbe meshed to generate coarse and fine surface meshes as follows:\n\n\n% gmsh -2 -clscale 1 Sphere.geo\n% RenameMesh Sphere.msh\n% gmsh -2 -clscale 0.5 Sphere.geo\n% RenameMesh Sphere.msh\n\n\n\n\n(Here \nRenameMesh\n is a simple \nbash\n script\nthat uses \nscuff-analyze\n to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThis produces the files \nSphere_501.msh\n and \nSphere_1479.msh,\n\nwhich you can visualize by opening in \ngmsh\n::\n\n\n% gmsh Sphere_501.msh\n\n\n\n\n\n\n% gmsh Sphere_1479.msh\n\n\n\n\n\n\n\n\nscuff-em\n geometry files\n\n\nThe \nscuff-em\n geometry file\n\nSiO2Sphere_501.scuffgeo\n\ndescribes a single SiO2 sphere.\n\n\nThe \nscuff-em\n geometry files\n\nSiO2Spheres_501.scuffgeo\n\n\nSiO2Spheres_1479.scuffgeo\n\neach describe the same configuration: two SiO2 spheres\nseparated by a center--center distance of 10 microns.\nYou can visualize this configuration by typing e.g.\n\n\n% scuff-analyze --geometry SiO2Spheres_1479.scuffgeo --WriteGMSHFiles\n% gmsh SiO2Spheres_1479.pp\n\n\n\n\n\n\n\n\nSpectral density of radiated power\n\n\nAs described in the \n\nscuff-neq\n documentation\n,\n\nscuff-neq\n computes the total power radiated by\nfinite-temperature objects as an integral over angular frequencies\n\n\\omega,\n in which the integrand involves a\ntemperature-dependent Bose-Einstein factor \nand a temperature-independent dimensionless flux \n\\Phi.\n \nTo calculate this radiated-power flux at a given set\nof frequencies, we say\n\n\n % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile --PRad\n\n\n\n\nwhere \nOmegaFile\n is a list of\nangular frequencies. (Here \n--PRad\n says that we \nare interested in the radiated power).\nThis produces the file\n\nSiO2Sphere_501.SiFlux\n, which looks something\nlike this:\n\n\n# scuff-neq run on superhr2 (07/11/15::00:31:36)\n# data file columns: \n# 1 transform tag\n# 2 omega \n# 3 (sourceObject,destObject) \n# 4 PRad flux spectral density\nDEFAULT 1.000000e-01 11 4.18911788e-06 \nDEFAULT 1.300000e-01 11 1.38869207e-05 \nDEFAULT 1.600000e-01 11 3.93335327e-05 \nDEFAULT 1.900000e-01 11 1.05263974e-04 \n\n\n\n\nAs the file header says, the second column here\nis the angular frequency \nin units of \n\\omega_0=3\\cdot 10^{14}\n rad/sec\nand the fourth column is the dimensionless power\nflux. (The first column lists the \n\ngeometrical transformation\n; since \nwe didn't specify the \n--transfile\n option to \n\nscuff-neq\n, we have just a single geometric\nconfiguration, labeled \nDEFAULT\n. The third \ncolumn identifies the source and destination objects;\nsince this geometry only has a single object,\nthe source and destination object are both \nalways object 1 and this column always reads\n\n11\n.)\n\n\nHere's a plot of the data:\n\n\n\n\nIn this plot, the solid line is the prediction of \nthe \nKrueger formalism\n, as computed\nby a \njulia\n code called \nKruegerFormulas.jl\n.\n\n\nThe plot is produced by \ngnuplot\n using \n\nthis script\n.\n\n\n\n\nSpectral density of power transfer and non-equilibrium force\n\n\nHere's a \nbash script\n that runs \nscuff-neq\n\nfor both the coarsely-meshed and finely-meshed two-sphere\ngeometry to compute the fluxes of power transfer\nand nonequilibrium force between the spheres. \nRunning the script produces files \nSiO2Spheres_501.SIFlux\n\nand \nSiO2Spheres_1479.SIFlux.\n Here are plots (produced\nby the same \ngnuplot\n script referenced above)\nof the heat-transfer flux from sphere 1 to sphere 2,\nand the force fluxes from sphere 1 to sphere 2 and\nfrom sphere 2 to sphere 2, compared to the Krueger\nT-matrix results (again computed using the \njulia\n\ncode referenced above).", 
            "title": "Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#gmsh-geometry-file-and-surface-mesh-for-a-single-sphere", 
            "text": "The  gmsh  geometry file  Sphere.geo \ndescribes a sphere of radius 1 micron; it may \nbe meshed to generate coarse and fine surface meshes as follows:  % gmsh -2 -clscale 1 Sphere.geo\n% RenameMesh Sphere.msh\n% gmsh -2 -clscale 0.5 Sphere.geo\n% RenameMesh Sphere.msh  (Here  RenameMesh  is a simple  bash  script\nthat uses  scuff-analyze  to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThis produces the files  Sphere_501.msh  and  Sphere_1479.msh, \nwhich you can visualize by opening in  gmsh ::  % gmsh Sphere_501.msh   % gmsh Sphere_1479.msh", 
            "title": "gmsh geometry file and surface mesh for a single sphere"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#scuff-em-geometry-files", 
            "text": "The  scuff-em  geometry file SiO2Sphere_501.scuffgeo \ndescribes a single SiO2 sphere.  The  scuff-em  geometry files SiO2Spheres_501.scuffgeo  SiO2Spheres_1479.scuffgeo \neach describe the same configuration: two SiO2 spheres\nseparated by a center--center distance of 10 microns.\nYou can visualize this configuration by typing e.g.  % scuff-analyze --geometry SiO2Spheres_1479.scuffgeo --WriteGMSHFiles\n% gmsh SiO2Spheres_1479.pp", 
            "title": "scuff-em geometry files"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#spectral-density-of-radiated-power", 
            "text": "As described in the  scuff-neq  documentation , scuff-neq  computes the total power radiated by\nfinite-temperature objects as an integral over angular frequencies \\omega,  in which the integrand involves a\ntemperature-dependent Bose-Einstein factor \nand a temperature-independent dimensionless flux  \\Phi.  \nTo calculate this radiated-power flux at a given set\nof frequencies, we say   % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile --PRad  where  OmegaFile  is a list of\nangular frequencies. (Here  --PRad  says that we \nare interested in the radiated power).\nThis produces the file SiO2Sphere_501.SiFlux , which looks something\nlike this:  # scuff-neq run on superhr2 (07/11/15::00:31:36)\n# data file columns: \n# 1 transform tag\n# 2 omega \n# 3 (sourceObject,destObject) \n# 4 PRad flux spectral density\nDEFAULT 1.000000e-01 11 4.18911788e-06 \nDEFAULT 1.300000e-01 11 1.38869207e-05 \nDEFAULT 1.600000e-01 11 3.93335327e-05 \nDEFAULT 1.900000e-01 11 1.05263974e-04   As the file header says, the second column here\nis the angular frequency \nin units of  \\omega_0=3\\cdot 10^{14}  rad/sec\nand the fourth column is the dimensionless power\nflux. (The first column lists the  geometrical transformation ; since \nwe didn't specify the  --transfile  option to  scuff-neq , we have just a single geometric\nconfiguration, labeled  DEFAULT . The third \ncolumn identifies the source and destination objects;\nsince this geometry only has a single object,\nthe source and destination object are both \nalways object 1 and this column always reads 11 .)  Here's a plot of the data:   In this plot, the solid line is the prediction of \nthe  Krueger formalism , as computed\nby a  julia  code called  KruegerFormulas.jl .  The plot is produced by  gnuplot  using  this script .", 
            "title": "Spectral density of radiated power"
        }, 
        {
            "location": "/examples/SiO2Spheres/SiO2Spheres/#spectral-density-of-power-transfer-and-non-equilibrium-force", 
            "text": "Here's a  bash script  that runs  scuff-neq \nfor both the coarsely-meshed and finely-meshed two-sphere\ngeometry to compute the fluxes of power transfer\nand nonequilibrium force between the spheres. \nRunning the script produces files  SiO2Spheres_501.SIFlux \nand  SiO2Spheres_1479.SIFlux.  Here are plots (produced\nby the same  gnuplot  script referenced above)\nof the heat-transfer flux from sphere 1 to sphere 2,\nand the force fluxes from sphere 1 to sphere 2 and\nfrom sphere 2 to sphere 2, compared to the Krueger\nT-matrix results (again computed using the  julia \ncode referenced above).", 
            "title": "Spectral density of power transfer and non-equilibrium force"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/", 
            "text": "Spatial distribution of heat flux from a warm tip over a cold substrate\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/TipSubstrate\n subdirectory\nof your \nscuff-em\n installation.\n\n\n\n\ngmsh\n geometry files for paraboloidal tip and cylindrical substrate\n\n\n\n\nParaboloid.geo\n\n\nCylinder.geo\n\n\n\n\nThe following script generates coarse and fine meshes of \nthese objects; it uses \nthis script\n.\n\n\n#!/bin/bash\nfor SHAPE in Paraboloid Cylinder\ndo\n  for L in 1.0 0.5\n  do\n    gmsh -2 -clscale ${L} ${SHAPE}.geo -o ${SHAPE}.msh\n    RenameMesh ${SHAPE}.msh\n  done\ndone\n\n\n\n\n\n\ngmsh\n geometry files\n\n\n\n\nTipSubstrate_Coarse.scuffgeo\n\n\nTipSubstrate_Fine.scuffgeo\n\n\n\n\n\n\n\n\nList of geometric transformations\n\n\n\n\nTipSubstrate.trans\n\n\n\n\n\n\nList of evaluation points\n\n\n\n\nEPFile\n\n\n\n\n\n\nRun \nscuff-neq\n\n\n#!/bin/bash\nARGS=\n\nARGS=\n${ARGS} --geometry ../TipSubstrate_Fine.scuffgeo\n\nARGS=\n${ARGS} --TransFile ../TipSubstrate.trans\n\nARGS=\n${ARGS} --Omega 0.7\n\nARGS=\n${ARGS} --EPFile ../EPFile\n\nARGS=\n${ARGS} --Power --ZForce\n\n\nscuff-neq ${ARGS}\n\n\n\n\n\n\nPlot \nz\n-directed Poynting flux from the tip through the vacuum and into the substrate:\n\n\ngnuplot\n plot 'TipSubstrate_Fine.SRFlux' u 5:9", 
            "title": "Spatial distribution of heat flux from a warm tip over a cold substrate"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#gmsh-geometry-files-for-paraboloidal-tip-and-cylindrical-substrate", 
            "text": "Paraboloid.geo  Cylinder.geo   The following script generates coarse and fine meshes of \nthese objects; it uses  this script .  #!/bin/bash\nfor SHAPE in Paraboloid Cylinder\ndo\n  for L in 1.0 0.5\n  do\n    gmsh -2 -clscale ${L} ${SHAPE}.geo -o ${SHAPE}.msh\n    RenameMesh ${SHAPE}.msh\n  done\ndone", 
            "title": "gmsh geometry files for paraboloidal tip and cylindrical substrate"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#gmsh-geometry-files", 
            "text": "TipSubstrate_Coarse.scuffgeo  TipSubstrate_Fine.scuffgeo", 
            "title": "gmsh geometry files"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#list-of-geometric-transformations", 
            "text": "TipSubstrate.trans", 
            "title": "List of geometric transformations"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#list-of-evaluation-points", 
            "text": "EPFile", 
            "title": "List of evaluation points"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#run-scuff-neq", 
            "text": "#!/bin/bash\nARGS= \nARGS= ${ARGS} --geometry ../TipSubstrate_Fine.scuffgeo \nARGS= ${ARGS} --TransFile ../TipSubstrate.trans \nARGS= ${ARGS} --Omega 0.7 \nARGS= ${ARGS} --EPFile ../EPFile \nARGS= ${ARGS} --Power --ZForce \n\nscuff-neq ${ARGS}", 
            "title": "Run scuff-neq"
        }, 
        {
            "location": "/examples/TipSubstrate/TipSubstrate/#plot-z-directed-poynting-flux-from-the-tip-through-the-vacuum-and-into-the-substrate", 
            "text": "gnuplot  plot 'TipSubstrate_Fine.SRFlux' u 5:9", 
            "title": "Plot z-directed Poynting flux from the tip through the vacuum and into the substrate:"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/", 
            "text": "Dyadic Green's Functions and LDOS above a material half-space\n\n\n\nIn this example, we exploit \nscuff-em\n's\n\nsupport for 2D periodic geometries\n\nby using \nscuff-ldos\n\nto compute dyadic Green's functions (DGFs) and \nelectromagnetic local densities of states (LDOS) \nat evaluation points lying above an\ninfinite planar dielectric interface.\n\n\nBecause this geometry happens to be amenable to an analytical\ntreatment, we will also \ncheck\n the numerical results of\n\nscuff-em\n against the results of analytical calculations of\nthe LDOS.\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/HalfSpaceLDOS\n subdirectory\nof your \nscuff-em\n installation.\n\n\nReview: What we are computing and why we need Brillouin-zone integration\n\n\nFor the benefit of users who may be wondering why numerical Brillouin-zone\nintegration is needed for this calculation, this section briefly reviews\nsome of the theoretical background. \n(This material is discussed in more detail in the memo\n\nComputation of Green's Functions and LDOS in \nscuff-em\n).\nIf you just want to get started running the calculations in \nscuff-em\n, \nfeel free to \nskip to the next section\n.\n\n\nGreen's functions and LDOS\n\n\nThe scattering dyadic Green's function\n\n\\boldsymbol{\\mathcal G}^{\\text E}(\\omega;\n             \\mathbf{x}_{\\text D},\n             \\mathbf{x}_{\\text S})\n\nof a material geometry\nis a \n3\\times 3\n matrix whose \ni,j\n entry is proportional to the\n\ni\n-component of the scattered electric field \nat \n\\mathbf{x}_{\\text D}\n due to a \n\nj\n-directed point electric dipole source at\n\n\\mathbf{x}_{\\text S}\n, all quantities having\ntime dependence \n\\sim e^{-i\\omega t}\n. (We could also \nconsider the magnetic Green's function\n\n\\boldsymbol{\\mathcal G}^{\\text M}\n,\nwhich describes the scattered \nmagnetic\n fields\narising from a point \nmagnetic\n dipole excitation.)\nThe subscripts \"D\" and \"S\" label the \"destination\" and \n\"source\" points; if these coincide\n\n(\\mathbf{x}_{\\text D}=\\mathbf{x}_{\\text S})\n,\nwe are talking about \none-point DGFs\n; otherwise\nwe have \ntwo-point DGFs.\n\n\nThe one-point scattering DGFs for a material geometry contain\ninformation on how the bodies in the geometry modify\nthe electromagnetic local density of states (LDOS)\nin the vicinity of the body. More specifically,\nthe full LDOS \n\\rho(\\mathbf{x})\n at a point \n\\mathbf{x}\n\nmay be decomposed as a sum of electric and magnetic\ncontributions, which themselves may be further decomposed\ninto vacuum and scattering contributions:\n\n \\begin{array}{lcl}\n\\rho(\\omega; \\mathbf{x}) &=& \\rho^\\text{E}(\\omega; \\mathbf{x}) + \\rho^\\text{M}(\\omega; \\mathbf{x})\n\\\\[5pt]\n\\rho^{\\text{E,M}}(\\mathbf{x})\n &=&   \\rho_0(\\omega)\n     + \\Delta \\rho^\\text{E,M}(\\omega; \\mathbf{x})\n\\\\[5pt]\n\\rho_0(\\omega) &=&\\frac{\\omega^2}{\\pi^2 c^3}\n\\\\[5pt]\n\\Delta \\rho^{\\text{E,M}}(\\omega; \\mathbf{x})\n &=& \\frac{\\omega}{\\pi c^2}\n     \\text{Tr Im }\\boldsymbol{\\mathcal{G}}^\\text{E,M}(\\omega; \\mathbf{x}, \\mathbf{x})\n\\end{array}\n\n\n\n\nComputing Green's functions\n\n\nThe electric and magnetic DGFs for a given source point\n(and any number of destination points)\ncollectively describe the results of 6 scattering\nproblems (with incident fields produced by electric and\nmagnetic dipoles oriented in each of the 3 cartesian\ndirections), and---for \ncompact\n geometries---could\nbe computed in \nscuff-em\n simply by\nassembling 6 right-hand-side vectors, solving the \nBEM system for the corresponding surface currents, and\ncomputing the scattered fields at all desired destination\npoints. \n\n\nHowever, the situation is more complicated for\ninfinitely extended geometries. \n\nRecall\n that such\ngeometries are described in \nscuff-em\n by a\nunit-cell geometry together with a basis of vectors \nfor a (one- or two-dimensional) lattice \n\\mathcal{L}\n.\nBy restricting our attention to scattering problems\nin which the incident fields (and thus all fields and\ncurrents) satisfies the Bloch-periodicity\ncondition \n\nf(\\mathbf{x}+\\mathbf{L})\n  =\n  e^{i\\mathbf{k}_\\text{B}\\cdot \\mathbf{L}}f(\\mathbf{x})\n  \\quad\\text{ for all } \\quad\n  \\mathbf{L}\\in\\mathcal{L}\n\n\nfor some Bloch wavevector \n\\mathbf{k}_\\text{B}\n,\nwe can get away with solving only for the surface\ncurrents within the unit cell, the currents\neverywhere else being then fixed by the Bloch periodicity.\nThis is the basic magic trick that allows infinite\ngeometries to be modeled on finite computers.\n\n\nOf course, the restriction to scattering problems involving\nonly Bloch-periodic incident fields is in fact highly restrictive;\nindeed, it excludes the particular problem we must solve\nto compute DGFs and LDOS, in which the incident field emanates\nfrom a point source at \n\\mathbf{x}_\\text{S}\n and is certainly \nnot Bloch-periodic. But here we can avail to the linearity\nof Maxwell's equations and the magic of Fourier analysis.\nInstead of solving a scattering problem involving the field\nof a point source at \n\\mathbf{x}_\\text{S}\n, we consider\nthe field of an infinite phased \narray\n of point sources,\nlocated at points \n\\{\\mathbf{x}_\\text{S} + \\mathbf{L}\\}\n\nwith phases \ne^{i\\mathbf{k}_\\text{B} \\cdot \\mathbf{L}}\n,\nfor all \n\\mathbf{L}\\in \\mathcal{L}\n. This \nis\n a\nBloch-periodic field, so we can take it as the incident\nfield in a \nscuff-em\n scattering problem, \nand the \nresulting scattered fields at \n\\mathbf{x}_\\text{D}\n\ndefine the \nBloch-periodic scattering DGFs\n\n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\omega; \\mathbf{k}_\\text{B};\n\\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S}).\n\nTo recover the non-periodic DGF \n\\boldsymbol{\\mathcal{G}}\n\nfrom \n\\overline{\\boldsymbol{\\mathcal{G}}}\n, we now\nimagine solving and summing the results of\nmany scattering problems involving our infinite array\nof point sources phased with many different Bloch vectors \n\n\\mathbf{k}_\\text{B}\n, chosen cleverly to ensure that the\ncontributions of the single point source at \n\\mathbf{x}_\\text{S}\n add\nconstructively, while the contributions of all \nother\n \npoint sources in the array add destructively\nand cancel. The formal expression of this procedure\nis a sort of inverse Fourier transform relating\n\n\\boldsymbol{\\mathcal{G}}\n to the average of\n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\mathbf{k}_\\text{B})\n \nover the Brillouin zone (BZ) of the reciprocal lattice:\n\n \\boldsymbol{\\mathcal G}(\\omega; \\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S})\n  =\\frac{1}{V_\\text{BZ}}\n   \\int_\\text{BZ}\n   \\overline{\\boldsymbol{\\mathcal G}}(\\omega; \\mathbf{k}_\\text{B};\n                           \\mathbf{x}_\\text{D},\n                           \\mathbf{x}_\\text{S})\n   \\, d\\mathbf{k}_\\text{B}\n   \\qquad (1)\n\n\nor, evaluating the integral approximately by numerical cubature,\n\n \\boldsymbol{\\mathcal G}(\\omega; \\mathbf{x}_\\text{D}, \\mathbf{x}_\\text{S})\n   \\approx \\frac{1}{V_\\text{BZ}}\n   \\sum_{m} w_m \n   \\overline{\\boldsymbol{\\mathcal G}}(\\omega; \\mathbf{k}_{\\text{B}m}; \\mathbf{x}_\\text{D},\n                           \\mathbf{x}_\\text{S})\n\n\nwhere \n\\{\\mathbf{k}_{\\text{B}m}, w_m\\}\n are the points and weights in a\ncubature rule for integration over the Brillouin zone.\nThus, getting the LDOS at a single point in a periodic geometry\nrequires summing the results of many scattering calculations at\nvarious Bloch vectors \n\\mathbf{k}_{\\text{B}m}\n lying in the Brillouin \nzone of the reciprocal lattice.\n\n\nThe question of how to choose the cubature rule---that is, the set of\nBloch vectors \n\\{\\mathbf{k}_{\\text{B}m}\\}\n at which the integrand\nis sampled and the weights \n\\{w_m\\}\n with which the samples are \ncombined---to yield accurate integral estimates without exorbitant \ncomputational cost is a tricky one, and one whose answer varies from \nproblem to problem. There are two ways to proceed:\n\n\n\n\nYou can design your own cubature scheme for integration over\nthe Brillouin zone, and simply ask \nscuff-ldos\n to give you\nvalues of the integrand \n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\mathbf{k}_\\text{B})\n\nat specific Bloch vectors \n\\bf k_\\text{B}\n.\nIn this case you will pass the \n--OmegakBlochFile\n command-line\nargument to \nscuff-ldos\n, and you will get back a data file\n(with extension \n.byOmegakBloch\n) reporting values of \n\n\\overline{\\boldsymbol{\\mathcal{G}}}\n at each \n\\bf k_\\text{B}\n\npoint you specified. (See below for examples).\n\n\n\n\n\n\n\n\nAlternatively, you can use the built-in Brillouin-zone integrator\nin \nscuff-ldos\n to perform the BZ integral automatically. In this\ncase you will get back a data file with extension \n.LDOS\n\nreporting values of \n\\boldsymbol{\\mathcal{G}}\n and \n\\Delta\\rho\n\nat each frequency and evaluation point you specified, \nplus\n a \ndata file with extension \n.byOmegakBloch\n reporting the Bloch\nvectors \n\\bf k_\\text{B}\n at which the internal integrator\nsampled the integrand and the values of\n\n\\overline{\\boldsymbol{\\mathcal{G}}}(\\bf k_\\text{B})\n \nat each sample point. \nIn this case you will probably want to set various command-line \noptions to optimize the integral evaluation; this is illustrated\nbelow and discussed in more detail on the page \n\nBrillouin-zone integration in \nscuff-em\n.\n\n\n\n\n\n\n\n\ngmsh\n geometry files for unit-cell geometries\n\n\nTo compute DGFs and LDOS in a half-space geometry,\nwe will describe the interface between the upper (vacuum)\nand lower (dielectric) regions of our geometry as the\ninfinite periodic replication of a unit-cell mesh \nover the sites of a 2D square lattice.\nBecause this particular geometry has infinite translational\nsymmetry, we are free to choose the lattice constant \n\nL=L_x=L_y\n however we like; here we will consider \nthe two values \nL=10\n nm and \nL=100\n nm.\n\n\nThe \ngmsh\n geometry file \nSquare_L_N.geo\n\ndescribes a square with user-adjustable parameters \n\nL\n and \nN\n that may be configured using the \n-setnumber\n\noption on the \ngmsh\n command line to define the square\nside length and the number of triangle edges per side length \n(the meshing fineness). To produce unit-cell meshes for\nthe two desired lattice constants, I go like this:\n\n\n% gmsh -2 -setnumber L 0.1 -setnumber N 4 Square_L_N.geo -o Square_L0P1.msh \n% RenameMesh Square_L0P1.msh\n\n% gmsh -2 -setnumber L 0.01 -setnumber N 4 Square_L_N.geo -o Square_L0P01.msh \n% RenameMesh Square_L0P01.msh\n\n\n\n\n(Here \nRenameMesh\n is a simple \nbash\n script\nthat uses \nscuff-analyze\n to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThese commands produce the files \n\nSquare_L0P1_40.msh\n and \nSquare_L0P01_40.msh.\n I also repeat the \nprocess with \n-setnumber N 8\n to yield finer meshes (with 176 instead\nof 40 interior edges).\nThese meshes may be visualized in \ngmsh\n by saying e.g.\n\n\n% gmsh Square_L0P1.40.msh\n% gmsh Square_L0P01.176.msh\n\n\n\n\n\n\n\n\nNote the following:\n\n\n\n\n\n\nFor 2D periodic geometries in \nscuff-em\n, the \n   lattice vectors must lie in the \nxy\n plane.\n\n\n\n\n\n\nFor surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on any edge of the unit cell must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use \nextrusions\n\n   in \ngmsh\n, as in the \n.geo\n file above.\n\n\n\n\n\n\nAmong the various possible ways to discretize a square\nintro triangles, I have chosen one that preserves as \nmuch symmetry as possible---specifically, the mesh \nis symmetric under the transformations\n\nx \\leftrightarrow -x\n, \ny \\leftrightarrow -y\n, and\n\nx \\leftrightarrow y\n. This is important for exploiting\nsymmetries to reduce the cost of Brillouin-zone integration\n(see below).\n\n\n\n\n\n\nThe \n.msh\n files needed to run the calculations in this\ntutorial may be found in the \nmshFiles/\n subfolder\nof the \nHalfSpaceLDOS\n example distributed with\n\nscuff-em\n.\n\n\n\n\nscuff-em\n geometry files\n\n\nFor each unit-cell mesh I create\n\nscuff-em\n geometry files\n\ndescribing three material geometries:\n\n\n\n\n\n\nan infinite-area perfectly electrically conducting (PEC) plate at height \nz=0\n;\n\n\n\n\n\n\nan infinite lossless dielectric (\n\\epsilon \\equiv 10\n) filling\n  space for \nz<0\n, with vacuum for \nz>0\n;\n\n\n\n\n\n\nsame as previous, but now with lossy metal (aluminum) instead\n  of lossless dielectric.\n\n\n\n\n\n\nThe resulting \n.scuffgeo\n files may be found in the \n\nscuffgeoFiles/\n subfolder of the \nHalfSpaceLDOS\n\nexample directory.\nFor example, the PEC-plate geometry at the coarser resolution\nwith the longer lattice constant is\n\nPECPlate_L0P1_40.scuffgeo\n,\nwhile the aluminum half-space geometry at the finer resolution\nwith the shorter lattice constant is\n\nAlHalfSpace_L0P01_176.scuffgeo\n.\nThe latter file looks like this:\n\n\n# this comes from Phys Rev B **68** 245405\nMATERIAL ALUMINUM\n    wp = 1.747e16; \n    gamma = 7.596e13;\n    Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nLATTICE\n    VECTOR 0.01 0.00\n    VECTOR 0.00 0.01\nENDLATTICE\n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION Exterior       MATERIAL Aluminum\n\nSURFACE Plate\n    MESHFILE Square_L0P01_176.msh\n    REGIONS Exterior UpperHalfSpace\nENDSURFACE\n\n\n\n\n\n\nList of evaluation points\n\n\nWe'll compute one-point DGFs and LDOS at four points,\nlocated at distances of 1, 10, 100, and 1000 nm above\nthe surface on the \nz\n-axis (\nx=y=0\n). Thus our evaluation-point\nfile (\nEPFile\n) looks like this:\n\n\n0.0 0.0 0.001\n0.0 0.0 0.010\n0.0 0.0 0.100\n0.0 0.0 1.000\n\n\n\n\n\n\nStudying the integrand to select the optimal cubature rule\n\n\nUltimately we will want to launch a full\nBrillouin-zone-integrated calculation to get\nthe total LDOS at our desired evaluation points \nand frequencies. However, before doing this we\nshould acquire some insight into the behavior of\nthe integrand so that we can make intelligent\nchoices for the various \n\noptions controlling Brillouin-zone integration\n.\n\n\nChecking Brillouin-zone symmetry\n\n\nA first thing to check is the \nsymmetry\n of the\nintegrand within the Brillouin zone (BZ).\nAs discussed \nhere\n, the built-in cubature\nroutines for 2D BZ integration in \nscuff-em\n\ncan exploit 2, 4, or 8-fold rotational symmetry.\nIn this case, because\n\n\n\n\n\n\n(1)\n the underlying (real-space) geometry is symmetric\nunder \nx\\leftrightarrow -x\n, \ny\\leftrightarrow -y\n,\nand \nx\\leftrightarrow y\n,\n\n\n\n\n\n\n(2)\n we have chosen a mesh discretization that \npreserves these symmetries, and\n\n\n\n\n\n\n(3)\n we are computing a one-point DGF, \n\n\n\n\n\n\nwe expect the BZ integrand \n\n\\overline{\\boldsymbol{\\mathcal{G}}}(k_x,k_y)\n\nto have 8-fold rotational symmetry, and thus\nwe should be able to restrict the domain of the \nBZ integration to just the \nirreducible\n Brillouin\nzone (a triangular wedge having 1/8 the total area\nof the BZ, as shown \nhere\n) and multiply by 8 \nto get the full BZ integral. \n\n\nTo test this, we'll run a quick first calculation in which\nwe compute just the integrand \n\\boldsymbol{\\mathcal{G}}(k_x,k_y)\n\nat 8 \n(k_x,k_y)\n points related by symmetry. Specifically,\nfor a square lattice with lattice constant \nL=100\\text{ nm}\n\n(reciprocal lattice constant \n\\Gamma=\\frac{2\\pi}{100\\text{ nm}}\n)\nwe'll consider the point\n\n(k_x,k_y)=(0.40\\Gamma,0.27\\Gamma)\\approx(25,17)\\,\\mu\\text{m}^{-1}\n\nand the 7 other points obtained by flipping signs and interchanging\ncomponents. Here's a picture showing the locations of these 8 points\nwithin in the BZ:\n\n\n\n\nWorking at angular frequency \n\\omega=10 \\cdot 3\\times 10^{14}\n rad/sec,\nwe create a little text file named \nEightPoints\n listing the\n\n(\\omega, k_x, k_y)\n values at which we want to sample the BZ integrand:\n\n\n10 +25 +17\n10 +17 +25\n10 -17 +25\n10 -25 +17\n10 -25 -17\n10 -17 -25\n10 +17 -25\n10 +25 -17\n\n\n\n\nNow run \nscuff-ldos\n:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile EightPoints --EPFile EPFile\n\n\n\n\nThis produces the file \nAlHalfSpace_L0P1_40.byOmegakBloch\n,\nin which each individual line reports \n\\overline{\\mathcal{G}}\n values\nfor a single evaluation point, frequency, and Bloch vector.\nLooking at just the portion of the file corresponding to the\nevaluation point at \nz=100\n nm, we see this:\n\n\n\n\nThis shows that, as expected, the Brillouin-zone integrands for\nthe electric and magnetic LDOS \n\\rho^\\text{E,M}\n are\ninvariant---up to small numerical errors on the order \nof around 1%, which are reduced to around 0.1% when we re-run\nthe calculation on the finer [N=176] mesh---under the 8-fold\nsymmetry relating the various Brillouin-zone points here. \nLater we will exploit this symmetry by specifying the command-line\noption \n--BZSymmetryFactor 8\n to reduce the cost of\nevaluating the full BZ integral.\n\n\nIncidentally, notice that the individual components of the DGFs (such as\n\n\\overline{\\mathcal{G}}_{xx}\n) do \nnot\n obey the full set of symmetries obeyed by the LDOS. You will need to take this into account if your goal is to compute DGFs and not just LDOS.\n\n\nObserving the variation of the integrand with \n|\\mathbf{k}_\\text{B}|\n\n\n\n\nAnother diagnostic test is to inspect the variation of the integrand with the magnitude of the Bloch vector. For this purpose we'll compute the integrand at points lying on the \nx\n-axis between the origin and the edge of the BZ, again working with the \nL=100\n nm lattice at \n\\omega=10\n.  We create a file called \nXAxisPoints\n specifying the (\n\\omega,k_x,k_y\n) points we want to sample: \n\n\n10  00.0  0.0\n10  1.57  0.0\n10  3.14  0.0\n...\n10  29.8  0.0\n10  31.4  0.0\n\n\n\n\nRun \nscuff-ldos\n:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile XAxisPoints --EPFile EPFile\n\n\n\n\nThis produces the file \nAlHalfSpace_L0P1_40.byOmegakBloch.\n\nWe plot the BZ integrand for the electric LDOS \n\n\\rho^\\text{E}(\\mathbf{k})\n versus \nk_x\n at \nz=100\n nm: \n\n\n% gnuplot\ngnuplot\n FILE='AlHalfSpace_L0P1_40.byOmegakBloch'\ngnuplot\n set yrange [-100:100]\ngnuplot\n plot FILE u ($3==0.1 ? $6 : 1/0):8 w lp pt 7 ps 1\n\n\n\n\n\n\nWhoops! There seems to be some sort of blowup happening\nnear \nk_x=10\n, i.e. near the point \nk_x=\\frac{\\omega}{c}\n\nwhere the Bloch wavelength coincides with the free-space\nphoton wavelength. Zooming in on the region near \nk_x=10\n,\nthe data look like this (where we have additionally plotted\ndata for evaluation points at a couple of other heights\noff the surface):\n\n\n\n\nThe important things to read off from this plot are:\n\n\n\n\n\n\nAs \n|\\mathbf{k}_\\text{B}|\\to k_0\\equiv \\frac{\\omega}{c}\n from below, the integrand\n  blows up like \n1/\\sqrt{k_0 - |\\mathbf{k}_\\text{B}|}.\n\n\n\n\n\n\n\n\nOn the other side of \nk_0\n, the integrand decays exponentially\n  at a \nz\n-dependent rate.\n\n\n\n\n\n\nThis behavior is expected for cases in which the photon wavenumber\nlies within the Brillouin zone; the square-root blowup in\nthe LDOS is just the usual van Hove singularity, while \nthe exponential decay for larger \nk\n arises because plane waves\nwith transverse wavelength shorter than the free-space \nphoton wavelength are evanescent (not propagating) waves\nthat decay exponentially with distance from the surface.\n\n\n(BTW, \nhere\n is the \ngnuplot\n\nscript that produces the two plots above.)\n\n\n\n\nRunning full Brillouin-zone-integrated calculations\n\n\nNow it's time to launch runs for full BZ-integrated LDOS. For\nthis purpose we will want to set appropriate values for the\n\ncommand-line options controlling Brillouin-zone integration\n.\nWe have already determined that the integrand has \n8-fold symmetry, so we will be specifying \n--BZSymmetryFactor 8.\n\nThe next task is to choose a cubature\nrule (\"BZ integration method\"), i.e. a strategy for sampling\nthe integrand at appropriately-chosen \n|\\mathbf{k}_\\text{B}|\n\npoints to estimate the integral accurately with as few\nsamples as possible.\n\n\nThe presence of the \n|\\mathbf{k}_\\text{B}|=k_0\n singularity\nin the Brillouin zone makes this a good candidate for\nthe \nPolar2\n strategy, which performs the BZ integral\nusing a polar decomposition\n\n\\mathbf{k}_\\text{B}=(k_\\rho, k_\\theta)\n,\nwith the integrals over the regions \nk_\\rho < k_0\n \nand \nk_\\rho>k_0\n handled separately, and with the \nchange of variables \nk_\\rho \\to k_z=\\sqrt{|k_0^2 - k_\\rho^2|}\n\nto neutralize the square-root singularity at \n\nk_\\rho = k_0.\n In this case the integrals\nover \nk_z\n and \nk_\\theta\n are performed using \n\nN_\\rho\n and \nN_\\theta\n evaluation points, \nrespectively, where \nN_\\rho\n and \nN_\\theta\n \nare combined into a single value specified as \nthe \n--BZIOrder\n command-line option, i.e.\n\n \\texttt{--BZIOrder} = N_\\rho \\times 100 + N_\\theta.\n\nFor example, to use 31 points for the radial integral\nand 11 points for the \n\\theta\n integral, we would\nsay \n--BZIOrder 3111\n.\n\n\n(Actually, in this particular case, we expect to have\nfull rotational symmetry, i.e. the integrand should be \nindependent of \nk_\\theta\n, and thus we can specify\nthe special value \nN_\\theta=2\n to request that the\n\nk_\\theta\n integral be evaluated by a one-point\ncubature sampling just the point \nk_\\theta=0\n.)\n\n\nChoosing an 11-point integration rule for the\nradial integral and the above-discussed 1-point\ncubature for the \n\\theta\n integral, our \nscuff-ldos\n\ncommand-line looks like this:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 1102\n\n\n\n\nAs a comparison, I will also run calculations with\n\nN_\\rho=0\n. This selects an \nadaptive\n integration\nalgorithm for the radial integral, which determines\nthe number and location of the sample points\nautomatically to achieve user-specified relative\nand absolute error tolerances, which are set with the \n\n--BZIRelTol\n and \n--BZIAbsTol\n command-line options:\n\n\n% scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 0002 --BZIRelTol 1.0e-2 --BZIRelTol 1.0e-8\n\n\n\n\nI also run calculations on the finer-resolution mesh (the \n_176.scuffgeo\n files) and the \nmesh with lattice constant \nL=0.01\\,\\mu\\text{m}\n (the \nL0P01\n files).\n\n\nHere's a plot of the LDOS enhancement at \nz=10 nm\n:\n\n\n\n\nThe green dots are for the calculation with all numerical\nresolution parameters\nset to their maximum (most accurate and most expensive) values: \nfinest mesh, smallest lattice constant, and adaptive BZ cubature. \nThese points agree well with the analytical prediction up to the \nhighest frequencies, where they start to deviate.\n\n\nThe other data symbols are the results of calculations in\nwhich one fineness parameter is relaxed to a less-expensive \nvalue:\n\n\n\n\nThe blue triangles are for the geometry with lattice constant\n\nL=100\n nm (but still using a fine mesh with adaptive cubature).\nEvidently this degrades the quality of the numerical data\ncompletely. That makes sense, since the evaluation point \nis at a height \nz=10\n nm above the surface. For larger \nz\n \nvalues the data values for the two lattice constants are in \nbetter agreement.\n\n\n\n\n\n\n\n\nThe orange triangles are for the geometry with lattice\nconstant \nL=10\n nm, but now meshed at coarser resolution\n(resulting in \nN=40\n triangle edges instead of \nN=176\n for\nthe finer case). Evidently this doesn't degrade the \nquality of the data \nat all\n, so for this case we can \nrun calculations with the (significantly cheaper) coarser\nmesh at no cost in accuracy. \n\n\n\n\n\n\n\n\nThe yellow stars are for the \nL=10\n nm geometry with\nthe fine (\nN=176\n) mesh resolution, but with the BZ integration\nperformed using a fixed-order numerical integration (\nN_\\rho=31\n samples)\ninstead of adaptive quadrature\nfor the radial part of the BZ integral. Evidently this \nyields data that agree with the more accurate adaptive-quadrature\ndata at most frequencies, but deviate over a range of \nfrequencies in the range \n\\omega\\in[10,40]\n\nand again at high frequencies.", 
            "title": "LDOS and dyadic Green functions above an infinite aluminum half-space"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#gmsh-geometry-files-for-unit-cell-geometries", 
            "text": "To compute DGFs and LDOS in a half-space geometry,\nwe will describe the interface between the upper (vacuum)\nand lower (dielectric) regions of our geometry as the\ninfinite periodic replication of a unit-cell mesh \nover the sites of a 2D square lattice.\nBecause this particular geometry has infinite translational\nsymmetry, we are free to choose the lattice constant  L=L_x=L_y  however we like; here we will consider \nthe two values  L=10  nm and  L=100  nm.  The  gmsh  geometry file  Square_L_N.geo \ndescribes a square with user-adjustable parameters  L  and  N  that may be configured using the  -setnumber \noption on the  gmsh  command line to define the square\nside length and the number of triangle edges per side length \n(the meshing fineness). To produce unit-cell meshes for\nthe two desired lattice constants, I go like this:  % gmsh -2 -setnumber L 0.1 -setnumber N 4 Square_L_N.geo -o Square_L0P1.msh \n% RenameMesh Square_L0P1.msh\n\n% gmsh -2 -setnumber L 0.01 -setnumber N 4 Square_L_N.geo -o Square_L0P01.msh \n% RenameMesh Square_L0P01.msh  (Here  RenameMesh  is a simple  bash  script\nthat uses  scuff-analyze  to count the number of interior\nedges in a surface mesh and rename the mesh file accordingly.)\nThese commands produce the files  Square_L0P1_40.msh  and  Square_L0P01_40.msh.  I also repeat the \nprocess with  -setnumber N 8  to yield finer meshes (with 176 instead\nof 40 interior edges).\nThese meshes may be visualized in  gmsh  by saying e.g.  % gmsh Square_L0P1.40.msh\n% gmsh Square_L0P01.176.msh    Note the following:    For 2D periodic geometries in  scuff-em , the \n   lattice vectors must lie in the  xy  plane.    For surfaces that straddle the unit-cell boundaries\n   (as is the case here), each triangle edge that lies\n   on any edge of the unit cell must have an identical\n   image edge on the opposite side of the unit cell.\n   An easy way to achieve this is to use  extrusions \n   in  gmsh , as in the  .geo  file above.    Among the various possible ways to discretize a square\nintro triangles, I have chosen one that preserves as \nmuch symmetry as possible---specifically, the mesh \nis symmetric under the transformations x \\leftrightarrow -x ,  y \\leftrightarrow -y , and x \\leftrightarrow y . This is important for exploiting\nsymmetries to reduce the cost of Brillouin-zone integration\n(see below).    The  .msh  files needed to run the calculations in this\ntutorial may be found in the  mshFiles/  subfolder\nof the  HalfSpaceLDOS  example distributed with scuff-em .", 
            "title": "gmsh geometry files for unit-cell geometries"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#scuff-em-geometry-files", 
            "text": "For each unit-cell mesh I create scuff-em  geometry files \ndescribing three material geometries:    an infinite-area perfectly electrically conducting (PEC) plate at height  z=0 ;    an infinite lossless dielectric ( \\epsilon \\equiv 10 ) filling\n  space for  z<0 , with vacuum for  z>0 ;    same as previous, but now with lossy metal (aluminum) instead\n  of lossless dielectric.    The resulting  .scuffgeo  files may be found in the  scuffgeoFiles/  subfolder of the  HalfSpaceLDOS \nexample directory.\nFor example, the PEC-plate geometry at the coarser resolution\nwith the longer lattice constant is PECPlate_L0P1_40.scuffgeo ,\nwhile the aluminum half-space geometry at the finer resolution\nwith the shorter lattice constant is AlHalfSpace_L0P01_176.scuffgeo .\nThe latter file looks like this:  # this comes from Phys Rev B **68** 245405\nMATERIAL ALUMINUM\n    wp = 1.747e16; \n    gamma = 7.596e13;\n    Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nLATTICE\n    VECTOR 0.01 0.00\n    VECTOR 0.00 0.01\nENDLATTICE\n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION Exterior       MATERIAL Aluminum\n\nSURFACE Plate\n    MESHFILE Square_L0P01_176.msh\n    REGIONS Exterior UpperHalfSpace\nENDSURFACE", 
            "title": "scuff-em geometry files"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#list-of-evaluation-points", 
            "text": "We'll compute one-point DGFs and LDOS at four points,\nlocated at distances of 1, 10, 100, and 1000 nm above\nthe surface on the  z -axis ( x=y=0 ). Thus our evaluation-point\nfile ( EPFile ) looks like this:  0.0 0.0 0.001\n0.0 0.0 0.010\n0.0 0.0 0.100\n0.0 0.0 1.000", 
            "title": "List of evaluation points"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#studying-the-integrand-to-select-the-optimal-cubature-rule", 
            "text": "Ultimately we will want to launch a full\nBrillouin-zone-integrated calculation to get\nthe total LDOS at our desired evaluation points \nand frequencies. However, before doing this we\nshould acquire some insight into the behavior of\nthe integrand so that we can make intelligent\nchoices for the various  options controlling Brillouin-zone integration .  Checking Brillouin-zone symmetry  A first thing to check is the  symmetry  of the\nintegrand within the Brillouin zone (BZ).\nAs discussed  here , the built-in cubature\nroutines for 2D BZ integration in  scuff-em \ncan exploit 2, 4, or 8-fold rotational symmetry.\nIn this case, because    (1)  the underlying (real-space) geometry is symmetric\nunder  x\\leftrightarrow -x ,  y\\leftrightarrow -y ,\nand  x\\leftrightarrow y ,    (2)  we have chosen a mesh discretization that \npreserves these symmetries, and    (3)  we are computing a one-point DGF,     we expect the BZ integrand  \\overline{\\boldsymbol{\\mathcal{G}}}(k_x,k_y) \nto have 8-fold rotational symmetry, and thus\nwe should be able to restrict the domain of the \nBZ integration to just the  irreducible  Brillouin\nzone (a triangular wedge having 1/8 the total area\nof the BZ, as shown  here ) and multiply by 8 \nto get the full BZ integral.   To test this, we'll run a quick first calculation in which\nwe compute just the integrand  \\boldsymbol{\\mathcal{G}}(k_x,k_y) \nat 8  (k_x,k_y)  points related by symmetry. Specifically,\nfor a square lattice with lattice constant  L=100\\text{ nm} \n(reciprocal lattice constant  \\Gamma=\\frac{2\\pi}{100\\text{ nm}} )\nwe'll consider the point (k_x,k_y)=(0.40\\Gamma,0.27\\Gamma)\\approx(25,17)\\,\\mu\\text{m}^{-1} \nand the 7 other points obtained by flipping signs and interchanging\ncomponents. Here's a picture showing the locations of these 8 points\nwithin in the BZ:   Working at angular frequency  \\omega=10 \\cdot 3\\times 10^{14}  rad/sec,\nwe create a little text file named  EightPoints  listing the (\\omega, k_x, k_y)  values at which we want to sample the BZ integrand:  10 +25 +17\n10 +17 +25\n10 -17 +25\n10 -25 +17\n10 -25 -17\n10 -17 -25\n10 +17 -25\n10 +25 -17  Now run  scuff-ldos :  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile EightPoints --EPFile EPFile  This produces the file  AlHalfSpace_L0P1_40.byOmegakBloch ,\nin which each individual line reports  \\overline{\\mathcal{G}}  values\nfor a single evaluation point, frequency, and Bloch vector.\nLooking at just the portion of the file corresponding to the\nevaluation point at  z=100  nm, we see this:   This shows that, as expected, the Brillouin-zone integrands for\nthe electric and magnetic LDOS  \\rho^\\text{E,M}  are\ninvariant---up to small numerical errors on the order \nof around 1%, which are reduced to around 0.1% when we re-run\nthe calculation on the finer [N=176] mesh---under the 8-fold\nsymmetry relating the various Brillouin-zone points here. \nLater we will exploit this symmetry by specifying the command-line\noption  --BZSymmetryFactor 8  to reduce the cost of\nevaluating the full BZ integral.  Incidentally, notice that the individual components of the DGFs (such as \\overline{\\mathcal{G}}_{xx} ) do  not  obey the full set of symmetries obeyed by the LDOS. You will need to take this into account if your goal is to compute DGFs and not just LDOS.  Observing the variation of the integrand with  |\\mathbf{k}_\\text{B}|   Another diagnostic test is to inspect the variation of the integrand with the magnitude of the Bloch vector. For this purpose we'll compute the integrand at points lying on the  x -axis between the origin and the edge of the BZ, again working with the  L=100  nm lattice at  \\omega=10 .  We create a file called  XAxisPoints  specifying the ( \\omega,k_x,k_y ) points we want to sample:   10  00.0  0.0\n10  1.57  0.0\n10  3.14  0.0\n...\n10  29.8  0.0\n10  31.4  0.0  Run  scuff-ldos :  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegakBlochFile XAxisPoints --EPFile EPFile  This produces the file  AlHalfSpace_L0P1_40.byOmegakBloch. \nWe plot the BZ integrand for the electric LDOS  \\rho^\\text{E}(\\mathbf{k})  versus  k_x  at  z=100  nm:   % gnuplot\ngnuplot  FILE='AlHalfSpace_L0P1_40.byOmegakBloch'\ngnuplot  set yrange [-100:100]\ngnuplot  plot FILE u ($3==0.1 ? $6 : 1/0):8 w lp pt 7 ps 1   Whoops! There seems to be some sort of blowup happening\nnear  k_x=10 , i.e. near the point  k_x=\\frac{\\omega}{c} \nwhere the Bloch wavelength coincides with the free-space\nphoton wavelength. Zooming in on the region near  k_x=10 ,\nthe data look like this (where we have additionally plotted\ndata for evaluation points at a couple of other heights\noff the surface):   The important things to read off from this plot are:    As  |\\mathbf{k}_\\text{B}|\\to k_0\\equiv \\frac{\\omega}{c}  from below, the integrand\n  blows up like  1/\\sqrt{k_0 - |\\mathbf{k}_\\text{B}|}.     On the other side of  k_0 , the integrand decays exponentially\n  at a  z -dependent rate.    This behavior is expected for cases in which the photon wavenumber\nlies within the Brillouin zone; the square-root blowup in\nthe LDOS is just the usual van Hove singularity, while \nthe exponential decay for larger  k  arises because plane waves\nwith transverse wavelength shorter than the free-space \nphoton wavelength are evanescent (not propagating) waves\nthat decay exponentially with distance from the surface.  (BTW,  here  is the  gnuplot \nscript that produces the two plots above.)", 
            "title": "Studying the integrand to select the optimal cubature rule"
        }, 
        {
            "location": "/examples/HalfSpaceLDOS/HalfSpaceLDOS/#running-full-brillouin-zone-integrated-calculations", 
            "text": "Now it's time to launch runs for full BZ-integrated LDOS. For\nthis purpose we will want to set appropriate values for the command-line options controlling Brillouin-zone integration .\nWe have already determined that the integrand has \n8-fold symmetry, so we will be specifying  --BZSymmetryFactor 8. \nThe next task is to choose a cubature\nrule (\"BZ integration method\"), i.e. a strategy for sampling\nthe integrand at appropriately-chosen  |\\mathbf{k}_\\text{B}| \npoints to estimate the integral accurately with as few\nsamples as possible.  The presence of the  |\\mathbf{k}_\\text{B}|=k_0  singularity\nin the Brillouin zone makes this a good candidate for\nthe  Polar2  strategy, which performs the BZ integral\nusing a polar decomposition \\mathbf{k}_\\text{B}=(k_\\rho, k_\\theta) ,\nwith the integrals over the regions  k_\\rho < k_0  \nand  k_\\rho>k_0  handled separately, and with the \nchange of variables  k_\\rho \\to k_z=\\sqrt{|k_0^2 - k_\\rho^2|} \nto neutralize the square-root singularity at  k_\\rho = k_0.  In this case the integrals\nover  k_z  and  k_\\theta  are performed using  N_\\rho  and  N_\\theta  evaluation points, \nrespectively, where  N_\\rho  and  N_\\theta  \nare combined into a single value specified as \nthe  --BZIOrder  command-line option, i.e.  \\texttt{--BZIOrder} = N_\\rho \\times 100 + N_\\theta. \nFor example, to use 31 points for the radial integral\nand 11 points for the  \\theta  integral, we would\nsay  --BZIOrder 3111 .  (Actually, in this particular case, we expect to have\nfull rotational symmetry, i.e. the integrand should be \nindependent of  k_\\theta , and thus we can specify\nthe special value  N_\\theta=2  to request that the k_\\theta  integral be evaluated by a one-point\ncubature sampling just the point  k_\\theta=0 .)  Choosing an 11-point integration rule for the\nradial integral and the above-discussed 1-point\ncubature for the  \\theta  integral, our  scuff-ldos \ncommand-line looks like this:  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 1102  As a comparison, I will also run calculations with N_\\rho=0 . This selects an  adaptive  integration\nalgorithm for the radial integral, which determines\nthe number and location of the sample points\nautomatically to achieve user-specified relative\nand absolute error tolerances, which are set with the  --BZIRelTol  and  --BZIAbsTol  command-line options:  % scuff-ldos --geometry scuffgeoFiles/AlHalfSpace_L0P1_40.scuffgeo --OmegaFile OmegaFile --EPFile EPFile --BZIMethod Polar2 --BZIOrder 0002 --BZIRelTol 1.0e-2 --BZIRelTol 1.0e-8  I also run calculations on the finer-resolution mesh (the  _176.scuffgeo  files) and the \nmesh with lattice constant  L=0.01\\,\\mu\\text{m}  (the  L0P01  files).  Here's a plot of the LDOS enhancement at  z=10 nm :   The green dots are for the calculation with all numerical\nresolution parameters\nset to their maximum (most accurate and most expensive) values: \nfinest mesh, smallest lattice constant, and adaptive BZ cubature. \nThese points agree well with the analytical prediction up to the \nhighest frequencies, where they start to deviate.  The other data symbols are the results of calculations in\nwhich one fineness parameter is relaxed to a less-expensive \nvalue:   The blue triangles are for the geometry with lattice constant L=100  nm (but still using a fine mesh with adaptive cubature).\nEvidently this degrades the quality of the numerical data\ncompletely. That makes sense, since the evaluation point \nis at a height  z=10  nm above the surface. For larger  z  \nvalues the data values for the two lattice constants are in \nbetter agreement.     The orange triangles are for the geometry with lattice\nconstant  L=10  nm, but now meshed at coarser resolution\n(resulting in  N=40  triangle edges instead of  N=176  for\nthe finer case). Evidently this doesn't degrade the \nquality of the data  at all , so for this case we can \nrun calculations with the (significantly cheaper) coarser\nmesh at no cost in accuracy.      The yellow stars are for the  L=10  nm geometry with\nthe fine ( N=176 ) mesh resolution, but with the BZ integration\nperformed using a fixed-order numerical integration ( N_\\rho=31  samples)\ninstead of adaptive quadrature\nfor the radial part of the BZ integral. Evidently this \nyields data that agree with the more accurate adaptive-quadrature\ndata at most frequencies, but deviate over a range of \nfrequencies in the range  \\omega\\in[10,40] \nand again at high frequencies.", 
            "title": "Running full Brillouin-zone-integrated calculations"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/", 
            "text": "Electrostatic polarizability of platonic solids\n\n\n\nIn this example we use the \nscuff-static\n electrostatic\nmodule of \nscuff-em\n to compute the DC polarizabilities\nof dielectric bodies with regular shapes and varying\ndielectric permittivity. This example was inspired by this paper:\n\n\n\n\nA. Sihvola, P. Yla-Oijala, S. Jarvenpaa, and J. Avelin, \"Polarizabilities of Platonic Solids,\" \nIEEE Transactions on Antennas and Propagation\n \n52\n 9 (2004)\n\n\n\n\nThe files for this example may be found in the\n\nshare/scuff-em/examples/PlatonicSolids\n subdirectory\nof your \nscuff-em\n installation.\n\n\ngmsh\n geometry files for spherical, tetrahedral, and octrahedral particles\n\n\nThe \ngmsh\n geometry files\n\nSphere.geo\n,\n\nTetrahedron.geo\n\nand \n\nOctahedron.geo\n\nrespectively describe spherical, tetrahedral, and \noctahedral particles.\nI turn them into \n.msh\n files describing surface meshes of\ntwo different finenesses by running the following \nbash\n\nscript, which invokes the\n\nRenameMesh\n\nscript:\n\n\n#!/bin/bash\n\nfor SCALE in 1.0 0.7\ndo\n  for SHAPE in Sphere Tetrahedron Octahedron\n  do\n    gmsh -clscale ${SCALE} -2 ${SHAPE}.geo -o ${SHAPE}.msh\n    RenameMesh ${SHAPE}.msh\n  done\ndone\n\n\n\n\nNote\n: The \n.geo\n files contain a variable parameter \nL\n that \nsets the sphere radius or the polygon edge length. In each case,\nthe default value of \nL\n is chosen to ensure that the volume \nof the result particle matches the volume of a sphere of radius \n1, but you may override this setting (to set \nL\n to a value of, \nsay, 2.34) by adding the command-line option \n-setnumber L 2.34\n \nto the \ngmsh\n command above.\n\n\nHere are pictures of the finer of the three meshes produced by this procedure:\n\n\n\n\nPolarizability of a dielectric sphere\n\n\nHere's a simple \nscuff-em\n geometry file\n named \nE10Sphere.scuffgeo\n that describes a dielectric sphere with relative permittivity \n\\epsilon=10\n:\n\n\nOBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_10\nENDOBJECT\n\n\n\n\nTo compute the DC polarizability of this object, we say\n\n\n% scuff-static --Geometry E10Sphere.scuffgeo --PolFile E10Sphere.pol\n\n\n\n\nThis produces a file named \nE10Sphere.pol\n, which reports\nall 9 components of the DC polarizability tensor for the \nsphere:\n\n\n# data file columns: \n# 01: object label \n# 02: alpha_{xx} \n# 03: alpha_{yx} \n# 04: alpha_{zx} \n# 05: alpha_{xy} \n# 06: alpha_{yy} \n# 07: alpha_{zy} \n# 08: alpha_{xz} \n# 09: alpha_{yz} \n# 10: alpha_{zz} \nSphere 9.221300e+00 6.692939e-03 4.299017e-02 1.225110e-02 9.231265e+00 1.831022e-03 -1.860956e-02 1.039749e-02 9.233396e+00 \n\n\n\n\nHere are some observations on this result:\n\n\n\n\n\n\nThe diagonal components here are in decent agreement with the\ntheoretical value of \n\\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{\\epsilon-1}{\\epsilon+2}R^3\\approx 9.4 R^3\n.\n\n\n\n\n\n\nThe slight discrepancies between the three diagonal components\narise because the surface mesh slightly breaks rotational symmetry\nof the sphere.\n\n\n\n\n\n\nThe nonzero values of the off-diagonal components are \nnumerical noise.\n\n\n\n\n\n\nIn all three cases, the result is improved by running\ncalculations with finer surface meshes.\n\n\nPolarizability of a dielectric cavity\n\n\nHere's an alternative geometry file describing a spherical\nvacuum \ncavity\n in a universe filled with \n\\epsilon=10\n \ndielectric material:\n\n\nMEDIUM\n    MATERIAL CONST_EPS_10\nENDMEDIUM\n\nOBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_1\nENDOBJECT\n\n\n\n\nThe polarizability data predicted by \nscuff-static\n for this\ngeometry are\n\n\nSphere -5.168105e+00 3.103541e-03 1.420259e-02 3.842746e-03 -5.164908e+00 -1.409712e-03 -6.971980e-03 4.036885e-03 -5.165247e+00 \n\n\n\n\nThe diagonal components here agree with the theoretical value of\n\n\\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{1-\\epsilon}{1+2\\epsilon}R^3\\approx -5.14 R^3\n.\n\n\nbash\n script to run calculations at many different permittivities\n\n\nUltimately we want to compute the polarizability at many\ndifferent values of the interior and exterior permittivity,\nand it would be unwieldy to have to repeat the above process\nby hand in each case. Instead, it's convenient to write a\na \nbash\n script to automate the process. This script \nis called \nGetPolVsTau.sh\n. It has a \nhard-coded list of surface meshes and reads pairs of \ninterior and exterior permittivity values\nin the form (EpsOut, EpsIn) from a file named\n\nEpsFile\n. For each surface mesh and each\npair of permittivity values, the script does the \nfollowing:\n\n\n\n\n\n\nIt constructs a \n.scuffgeo\n file for the given\nmesh and permittivity values by appropriately modifying\na template file called \nTemplate.scuffgeo\n.\n\n\n\n\n\n\nIt runs \nscuff-static\n to get the polarizability\nfor this object with this pair of permittivity values.\n\n\n\n\n\n\nIt reads the resulting polarizability data from the output file\nwritten by \nscuff-static\n and writes the data, together\nwith the (EpsOut, EpsIn) values, to an overall output\nfile for the shape in question. \n\n\n\n\n\n\nThis script, which takes about 10 minutes to run on my laptop,\nproduces a series of files with names like\n\nTetrahedron_1179.AlphaVsTau.\n Here \nTau\n refers to the quantity\n\n\\tau\\equiv \\epsilon^{\\text{in}}/\\epsilon^{\\text{out}}\n\ndefined in the paper by Sihvola et al. referenced above.\n\n\nPlotting polarizability vs. \n\\tau\n for the three shapes\nreproduces Figure 4 of the paper by Sihvola et al.\nreferenced above,\nexcept for something funky that appears to be happening \nfor the tetrahedron around \n\\epsilon=100.\n\n\n\n\n\n\nIncidentally, here's the \ngnuplot\n script that I\nused to produce this plot: \nPlotter.gp\n.", 
            "title": "Electrostatic polarizability of platonic solids"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/#polarizability-of-a-dielectric-sphere", 
            "text": "Here's a simple  scuff-em  geometry file  named  E10Sphere.scuffgeo  that describes a dielectric sphere with relative permittivity  \\epsilon=10 :  OBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_10\nENDOBJECT  To compute the DC polarizability of this object, we say  % scuff-static --Geometry E10Sphere.scuffgeo --PolFile E10Sphere.pol  This produces a file named  E10Sphere.pol , which reports\nall 9 components of the DC polarizability tensor for the \nsphere:  # data file columns: \n# 01: object label \n# 02: alpha_{xx} \n# 03: alpha_{yx} \n# 04: alpha_{zx} \n# 05: alpha_{xy} \n# 06: alpha_{yy} \n# 07: alpha_{zy} \n# 08: alpha_{xz} \n# 09: alpha_{yz} \n# 10: alpha_{zz} \nSphere 9.221300e+00 6.692939e-03 4.299017e-02 1.225110e-02 9.231265e+00 1.831022e-03 -1.860956e-02 1.039749e-02 9.233396e+00   Here are some observations on this result:    The diagonal components here are in decent agreement with the\ntheoretical value of  \\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{\\epsilon-1}{\\epsilon+2}R^3\\approx 9.4 R^3 .    The slight discrepancies between the three diagonal components\narise because the surface mesh slightly breaks rotational symmetry\nof the sphere.    The nonzero values of the off-diagonal components are \nnumerical noise.    In all three cases, the result is improved by running\ncalculations with finer surface meshes.", 
            "title": "Polarizability of a dielectric sphere"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/#polarizability-of-a-dielectric-cavity", 
            "text": "Here's an alternative geometry file describing a spherical\nvacuum  cavity  in a universe filled with  \\epsilon=10  \ndielectric material:  MEDIUM\n    MATERIAL CONST_EPS_10\nENDMEDIUM\n\nOBJECT Sphere\n    MESHFILE Sphere_501.msh\n    MATERIAL CONST_EPS_1\nENDOBJECT  The polarizability data predicted by  scuff-static  for this\ngeometry are  Sphere -5.168105e+00 3.103541e-03 1.420259e-02 3.842746e-03 -5.164908e+00 -1.409712e-03 -6.971980e-03 4.036885e-03 -5.165247e+00   The diagonal components here agree with the theoretical value of \\frac{\\alpha}{\\epsilon_0}=4\\pi \\frac{1-\\epsilon}{1+2\\epsilon}R^3\\approx -5.14 R^3 .", 
            "title": "Polarizability of a dielectric cavity"
        }, 
        {
            "location": "/examples/PlatonicSolids/PlatonicSolids/#bash-script-to-run-calculations-at-many-different-permittivities", 
            "text": "Ultimately we want to compute the polarizability at many\ndifferent values of the interior and exterior permittivity,\nand it would be unwieldy to have to repeat the above process\nby hand in each case. Instead, it's convenient to write a\na  bash  script to automate the process. This script \nis called  GetPolVsTau.sh . It has a \nhard-coded list of surface meshes and reads pairs of \ninterior and exterior permittivity values\nin the form (EpsOut, EpsIn) from a file named EpsFile . For each surface mesh and each\npair of permittivity values, the script does the \nfollowing:    It constructs a  .scuffgeo  file for the given\nmesh and permittivity values by appropriately modifying\na template file called  Template.scuffgeo .    It runs  scuff-static  to get the polarizability\nfor this object with this pair of permittivity values.    It reads the resulting polarizability data from the output file\nwritten by  scuff-static  and writes the data, together\nwith the (EpsOut, EpsIn) values, to an overall output\nfile for the shape in question.     This script, which takes about 10 minutes to run on my laptop,\nproduces a series of files with names like Tetrahedron_1179.AlphaVsTau.  Here  Tau  refers to the quantity \\tau\\equiv \\epsilon^{\\text{in}}/\\epsilon^{\\text{out}} \ndefined in the paper by Sihvola et al. referenced above.  Plotting polarizability vs.  \\tau  for the three shapes\nreproduces Figure 4 of the paper by Sihvola et al.\nreferenced above,\nexcept for something funky that appears to be happening \nfor the tetrahedron around  \\epsilon=100.    Incidentally, here's the  gnuplot  script that I\nused to produce this plot:  Plotter.gp .", 
            "title": "bash script to run calculations at many different permittivities"
        }, 
        {
            "location": "/reference/TopLevel/", 
            "text": "Top-level overview of \nscuff-em\n\n\nscuff-em\n is a free, open-source software \nimplementation of the boundary-element method (BEM)\n(or the \"method of moments\") of electromagnetic\nscattering. (More specifically, \nscuff-em\n\nimplements the EFIE and PMCHWT formulations\nof the BEM using RWG basis functions.)\n\n\nscuff-em\n originated as a specialized tool\nfor using BEM techniques to model\nfluctuation-induced electromagnetic phenomena---such as\n\nCasimir forces\n\nand\n\nradiative heat transfer\n---and \nsubsequently expanded into a general-purpose BEM solver targeting a\nvariety of applications in nanophotonics.\n\n\nscuff-em\n consists of a \ncore library\n,\nimplementing the basic BEM functionality, plus a large number \nof specialized \napplication modules\n \ndesigned for specific problems in science and engineering.\n\n\nscuff-em\n stands for \nS\nurface \nCU\nrrent/\nF\nield \nF\normulation of \n\nE\nlectro\nM\nagnetism. This is a reference to the underlying solution \nmethodology used by \nscuff-em\n and other BEM solvers, in which we solve \nfirst for surface currents [including both electric (\nK\n) and \nmagnetic (\nN\n) currents, as cartooned in the \nscuff-em\n logo], \nthen use these currents to compute the scattered fields or other \nquantities of interest.\n\n\nThe entire \nscuff-em\n suite is free software distributed \nunder the \nGNU GPL\n. The source code for \nscuff-em\n \nmay be downloaded from the \n\nscuff-em\n GitHub page\n. \n\nThe GitHub page is also the right place for questions, \nbug reports, feature requests, and other discussion of \nscuff-em\n.\n\n\nFor commercial support and consulting services\nrelated to \nscuff-em\n, please contact \n\nSIMPETUS Inc.\n\n\nInterfaces to \nscuff-em\n\n\nAccess to the \nscuff-em\n computational engine is available\nvia multiple interfaces.\n\n\nThe \ncommand-line interface\n consists of a large number\nof \ncommand-line applications\n for\nrunning various types of standard calculations in computational\nphysics. Using \nscuff-em\n in this way requires only\nthat you learn the basic command-line options\n\n\nThe \napplication programming interface\n consists of \n\nC++ and python APIs\n\nthat allow access to internal \nscuff-em\n data structures\nand methods for maximal flexibility in implementing your\nown custom-designed physics codes.\n\n\nInputs to \nscuff-em\n calculations\n\n\nTypical inputs to \nscuff-em\n calculations include\n\n\n\n\n\n\nA \ngeometry file\n describing the scattering geometry\n\n\n\n\n\n\nAn optional \nlist of geometric transformations\n \n  to be applied to the geometry, with calculations generally repeated\n  at each transformation\n\n\n\n\n\n\nSpecification of the frequencies (and, for extended geometries,\n  the Bloch vectors) at which you want to perform calculations\n\n\n\n\n\n\nFor scattering codes: a specification of the \n  [incident fields][IncidentFields.md].\n\n\n\n\n\n\nSpecifications of the output quantities you wish to get back: \n  field components at individual points in space, power/force/torque\n  information, Casimir quantities, heat-transfer rates, impedance \n  parameters, capacitances, polarizabilities, etc.\n\n\n\n\n\n\nOutputs from \nscuff-em\n calculations\n\n\nTypical outputs from \nscuff-em\n calculations include\n\n\n\n\n\n\ntext-based data files reporting output quantities\n\n\n\n\n\n\nVisualization files written in \n  \nGMSH\n post-processing\n  format.\n\n\n\n\n\n\n\n\nCommand-line Applications\n\n\nNanophotonics / electromagnetic scattering\n\n\n\n\n\n\nscuff-scatter\n\n\n\n\nA general-purpose solver forproblems involving\nAvailable outputs include: scattered and total fields\nat arbitrary points in space; visualization of fields \nand surface currents; absorbed and scattered power;\nforce and torque (radiation pressure); induced dipole\nor spherical multipole moments; and more.\n\n\n\n\n\n\n\n\n\nscuff-transmission\n\n\n\n\nA specialized solver for computing plane-wave transmission\nin 2D extended geometries: thin films, perforated screens,\nnanoparticle arrays, etc. \n\n\n\n\n\n\n\n\nscuff-tmatrix\n\n\n\n\nA specialized code for computing the\n\nT-matrices\n\nof arbitrary compact scatterers.\n\n\n\n\n\n\n\n\nFluctuation-induced interactions\n\n\n\n\n\n\nscuff-cas3D\n\n\n\n\nAn implementation of the \n[fluctuating-surface-current approach to equilibrium Casimir forces][FSCPaper] \nin compact or extended geometries.\n\n\n\n\n\n\n\n\nscuff-caspol\n\n\n\n\nA tool for computing Casimir-Polder potentials for\npolarizable molecules in the vicinity of compact or \nextended material bodies.\n\n\n\n\n\n\n\n\nscuff-neq\n\n\n\n\nAn implementation of the fluctuating-surface-current\napproach to non-equilibrium fluctuation-induced\ninteractions among compact objects.\nAvailable outputs include: frequency-resolved or \nfrequency-integrated rates of heat radiation or \nradiative heat transfer; non-equilibrium Casimir \nforces; self-propulsion and self-rotation of \nisolated bodies.\n\n\n\n\n\n\n\n\nRF / microwave engineering\n\n\n\n\nscuff-RF\n\n\nA tool for modeling the electromagnetic properties of \npassive RF devices such as antennas and inductors.\nAvailable outputs include: frequency-dependent\nS-parameters for arbitrarily-shaped objects;\nradiated field patterns for antennas or other objects\ndriven by user-specified currents.\n\n\n\n\n\n\n\n\nElectrostatics\n\n\n\n\n[\nscuff-static\n][scuff-static]\n\n\nAn electrostatic solver. \nAvailable outputs include: self- and mutual-capacitances\nof arbitrarily-shaped conductors ; DC polarizabilities of\nconducting and dielectric bodies; electrostatic fields\n(at user-specified evaluation points) in the presence \nof conducting surfaces held at user-specified potentials.\n\n\n\n\n\n\n\n\nCiting \nscuff-em\n\n\nIf you find \nscuff-em\n useful for generating\nresults included in publications, please consider citing both \n\n(a)\n one of the papers discussing the implementation of\n\nscuff-em\n, and \n\n(b)\n the URL for the code. For example, if you are writing\nin LaTeX, you might write something like this:\n\n\nNumerical computations were performed using {\\sc scuff-em}, a free,\nopen-source software implementation of the boundary-element \nmethod~\\cite{SCUFF1, SCUFF2}.\n\n\n\n\nHere the \nSCUFF1\n and \nSCUFF2\n\nreferences refer to the following \n.bibtex\n entries:\n\n\n@ARTICLE{SCUFF1,\nauthor = {{Homer Reid}, M.~T. and {Johnson}, S.~G.},\ntitle = \n{Efficient Computation of Power, Force, and Torque in \nBEM Scattering Calculations}\n,\njournal = {ArXiv e-prints},\narchivePrefix = \narXiv\n,\neprint = {1307.2966},\nprimaryClass = \nphysics.comp-ph\n,\nkeywords = {Physics - Computational Physics, Physics - Classical Physics},\nyear = 2013,\nmonth = jul,\n}\n\n@ARTICLE{SCUFF2,\nnote=\n\\texttt{http://github.com/homerreid/scuff-EM}\n\n}\n\n\n\n\n[scuff-static]              ../applications/scuff-static/scuff-static.md", 
            "title": "Top-level overview"
        }, 
        {
            "location": "/reference/TopLevel/#interfaces-to-scuff-em", 
            "text": "Access to the  scuff-em  computational engine is available\nvia multiple interfaces.  The  command-line interface  consists of a large number\nof  command-line applications  for\nrunning various types of standard calculations in computational\nphysics. Using  scuff-em  in this way requires only\nthat you learn the basic command-line options  The  application programming interface  consists of  C++ and python APIs \nthat allow access to internal  scuff-em  data structures\nand methods for maximal flexibility in implementing your\nown custom-designed physics codes.", 
            "title": "Interfaces to scuff-em"
        }, 
        {
            "location": "/reference/TopLevel/#inputs-to-scuff-em-calculations", 
            "text": "Typical inputs to  scuff-em  calculations include    A  geometry file  describing the scattering geometry    An optional  list of geometric transformations  \n  to be applied to the geometry, with calculations generally repeated\n  at each transformation    Specification of the frequencies (and, for extended geometries,\n  the Bloch vectors) at which you want to perform calculations    For scattering codes: a specification of the \n  [incident fields][IncidentFields.md].    Specifications of the output quantities you wish to get back: \n  field components at individual points in space, power/force/torque\n  information, Casimir quantities, heat-transfer rates, impedance \n  parameters, capacitances, polarizabilities, etc.", 
            "title": "Inputs to scuff-em calculations"
        }, 
        {
            "location": "/reference/TopLevel/#outputs-from-scuff-em-calculations", 
            "text": "Typical outputs from  scuff-em  calculations include    text-based data files reporting output quantities    Visualization files written in \n   GMSH  post-processing\n  format.", 
            "title": "Outputs from scuff-em calculations"
        }, 
        {
            "location": "/reference/TopLevel/#command-line-applications", 
            "text": "Nanophotonics / electromagnetic scattering    scuff-scatter   A general-purpose solver forproblems involving\nAvailable outputs include: scattered and total fields\nat arbitrary points in space; visualization of fields \nand surface currents; absorbed and scattered power;\nforce and torque (radiation pressure); induced dipole\nor spherical multipole moments; and more.     scuff-transmission   A specialized solver for computing plane-wave transmission\nin 2D extended geometries: thin films, perforated screens,\nnanoparticle arrays, etc.      scuff-tmatrix   A specialized code for computing the T-matrices \nof arbitrary compact scatterers.     Fluctuation-induced interactions    scuff-cas3D   An implementation of the \n[fluctuating-surface-current approach to equilibrium Casimir forces][FSCPaper] \nin compact or extended geometries.     scuff-caspol   A tool for computing Casimir-Polder potentials for\npolarizable molecules in the vicinity of compact or \nextended material bodies.     scuff-neq   An implementation of the fluctuating-surface-current\napproach to non-equilibrium fluctuation-induced\ninteractions among compact objects.\nAvailable outputs include: frequency-resolved or \nfrequency-integrated rates of heat radiation or \nradiative heat transfer; non-equilibrium Casimir \nforces; self-propulsion and self-rotation of \nisolated bodies.     RF / microwave engineering   scuff-RF  A tool for modeling the electromagnetic properties of \npassive RF devices such as antennas and inductors.\nAvailable outputs include: frequency-dependent\nS-parameters for arbitrarily-shaped objects;\nradiated field patterns for antennas or other objects\ndriven by user-specified currents.     Electrostatics   [ scuff-static ][scuff-static]  An electrostatic solver. \nAvailable outputs include: self- and mutual-capacitances\nof arbitrarily-shaped conductors ; DC polarizabilities of\nconducting and dielectric bodies; electrostatic fields\n(at user-specified evaluation points) in the presence \nof conducting surfaces held at user-specified potentials.", 
            "title": "Command-line Applications"
        }, 
        {
            "location": "/reference/TopLevel/#citing-scuff-em", 
            "text": "If you find  scuff-em  useful for generating\nresults included in publications, please consider citing both  (a)  one of the papers discussing the implementation of scuff-em , and  (b)  the URL for the code. For example, if you are writing\nin LaTeX, you might write something like this:  Numerical computations were performed using {\\sc scuff-em}, a free,\nopen-source software implementation of the boundary-element \nmethod~\\cite{SCUFF1, SCUFF2}.  Here the  SCUFF1  and  SCUFF2 \nreferences refer to the following  .bibtex  entries:  @ARTICLE{SCUFF1,\nauthor = {{Homer Reid}, M.~T. and {Johnson}, S.~G.},\ntitle =  {Efficient Computation of Power, Force, and Torque in \nBEM Scattering Calculations} ,\njournal = {ArXiv e-prints},\narchivePrefix =  arXiv ,\neprint = {1307.2966},\nprimaryClass =  physics.comp-ph ,\nkeywords = {Physics - Computational Physics, Physics - Classical Physics},\nyear = 2013,\nmonth = jul,\n}\n\n@ARTICLE{SCUFF2,\nnote= \\texttt{http://github.com/homerreid/scuff-EM} \n}  [scuff-static]              ../applications/scuff-static/scuff-static.md", 
            "title": "Citing scuff-em"
        }, 
        {
            "location": "/reference/Installing/", 
            "text": "Installing \nscuff-em\n\n\n0. Try \nscuff-em\n online before installing anything!\n\n\nJohannes Feist\n has set up\nan interactive online notebook using \nMyBinder\n\nthat you can use to run some simple \nscuff-em\n calculations on\nthe cloud without having to install anything. This free service\noffers limited computing power, so you won't want to attempt any\nheavy calculations here, but you can follow Johannes' tutorial\nto observe the flow of a typical \nscuff-em\n calculation,\nplay around with your own calculations, and get a feel for what \nusing \nscuff-em\n will like once you have installed it on your \nmachine.\n\n\nHere's the link:\n\nhttp://mybinder.org/repo/jfeist/scuff-em-mybinder\n.\n\n\n1. External packages\n\n\nscuff-em\n relies on a small number of well-established free \nsoftware packages to implement certain non-essential functionality. \n\nscuff-em\n can be compiled and installed without any of these packages, \nbut in this case the code will be somewhat crippled.\n\n\n\n\n\n\nIf you actually want to solve scattering problems (instead of \n  just setting them up), you will need\n  \nLAPACK/BLAS\n.\n\n\n\n\n\n\nIf you want the capacity to write output files in the \n  standard HDF5 binary format, you will need\n  \nHDF5\n.\n\n\n\n\n\n\nIf you want to compile the \npython\n interface, you will need the\n  \npython\n development files.\n\n\n\n\n\n\nAlthough not required to install, compile, or use\n  \nscuff-em\n,\n  \ngmsh\n\n  is an extremely valuable open-source meshing and visualization\n  tool that is used throughout the\n  \nscuff-em\n documentation.\n\n\n\n\n\n\nOn Debian/Ubuntu Linux systems, you can fetch all of these packages by doing a \n\n\n% sudo apt-get install liblapack-dev libblas-dev libhdf5-serial-dev python-dev gmsh\n\n\n\n\n\n\nNote: In some cases it seems the \ngmsh\n package conflicts with \nthe \nlibhdf5-serial-dev\n package. In this case, just \nremove \ngmsh\n from the above \napt-get\n statement; you can \ninstall it by hand following the instructions\non the \nGMSH website\n.\n(Note that \ngmsh\n, though very useful, \nis not necessary to compile or run \nscuff-em\n.)\n\n\n\n\n2. Cloning the GitHub repository and building the code\n\n\nscuff-em\n is hosted on \nGitHub\n.\nThe current build status of the \nscuff-em\n master branch is:\n\n\n\n\nTo fetch and install the latest version of the \ncode, execute the following steps. (Replace the string\n\n/path/to/scuff-em-installation-directory\n\nwith your desired installation directory.)\n\n\n% git clone https://homerreid@github.com/HomerReid/scuff-em.git\n% cd scuff-em\n% sh autogen.sh --prefix=/path/to/scuff-em-installation-directory\n% make install\n\n\n\n\nIf this succeeds, the executable versions of the application\nprograms (such as \nscuff-scatter\n, \nscuff-rf\n, etc.) will be \ninstalled in the directory \nPREFIX/bin/\n \nand the demonstration examples for the various application programs \nwill be in \nPREFIX/share/scuff-em/examples\n\n(where \nPREFIX\n is the directory you specified using the \n\n--prefix\n option above).\n\n\nIf you have trouble installing \nscuff-em\n,\nplease file an issue on the \n\nscuff-em\n GitHub page\n.\n\n\nBuild options\n\n\nYou may specify options to the \nautogen.sh\n\n(or \nconfigure\n) command to guide the compilation process. \nFor a full list of available options,\ntype \nconfigure --help.\n Here we summarize some of the\nmore salient possibilities.\n\n\n\n\nMultithreading: \nopenmp\n vs. \npthreads\n\n\nThe \nscuff-em\n core library \nuses multithreading for all steps in the\n\nmain flow\n of\nthe BEM scattering procedure. You can use \nconfigure\n\noptions to select whether this multithreading is implemented\nusing \nopenmp\n or \npthreads\n. The former is the default,\nwhile the latter may be enabled like this:\n\n\n% ./configure --without-openmp --with-pthreads\n\n\n\n\nThe default \nopenmp\n\nmultithreading tends to play better with other multithreaded \nsoftware packages and is definitely the right choice if you \nwill be operating on a shared machine with some CPU cores \noccupied by other users. \n(You can monitor performance by inspecting\n\n.log\n files\n.\n\n\nSupport for \npthreads\n\nis a legacy feature that will be discontinued in future versions of \n\nscuff-em\n.\n\n\nNote: in some cases you may need to tweak certain environment \nvariables to achieve maximal \n\nopenmp\n performance.\nFor example, on my workstation (which has 8 CPU cores),\nin order to get \nopenmp\n codes\nto use all 8 cores I need to set the following environment\nvariable:\n\n\n% export GOMP_CPU_AFFINITY=0-7\n\n\n\n\n\n\nDisabling the python interface to speed the build process\n\n\nCompiling the python interface is slow---it accounts for\nmore than half of the build time on some systems.\nIf you don't need the python interface to \nscuff-em\n,\nuse the option \n--without-python\n when running \nconfigure\n\nto accelerate the build process.\n\n\n\n\nBuilding for debugging\n\n\nIf you would like to run \nscuff-em\n API codes in a debugger\nlike \ngdb\n,\nyou will want to modify the build options to \n(a)\n include\ndebugging symbols, \n(b)\n turn off optimization, \n(c)\n\ndisable \nopenmp\n multithreading, which does not play well\nwith \nGDB\n. \n\n\nHere is the script that works for me to achieve these goals:\n\n\n#!/bin/bash\n\nCC=\ngcc -ggdb -O0\n\nCXX=\ng++ -ggdb -O0\n\nexport CFLAGS=\n-O0\n\nexport CXXFLAGS=\n-O0\n\nsh autogen.sh --enable-debug --without-openmp --disable-shared\n\n\n\n\n(It shouldn't be necessary to have to add \n-O0\n to both the\nenvironment variables and the compiler command lines, but\nthis seems to be the only way things work for me.)\n\n\nAfter running this script to reconfigure for building with\ncompiling support, you will want to \nmake clean; make\n\nto rebuild everything with debugging support. Of course,\nafter you are finished debugging you will need to reconfigure\nwith debugging support removed and then re-do the \nclean build. Because this is time-consuming, I typically\nmaintain two separate copies of the code base, one for\ndebugging and one for running at full speed.\n\n\nOnce debugging support has been added, you can run \nthe code in \ngdb\n. Here's a sample session:\n\n\n % gdb /path/to/debug/repository/bin/scuff-ldos\n\n (gdb) set args \n scuff-ldos.args\n\n (gdb) break GetHalfSpaceDGFs\nBreakpoint 1 at 0x409626: file AnalyticalDGFs.cc, line 217.\n\n (gdb) run\n\nBreakpoint 1, GetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, \n    zp=0.10000000000000001, LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, \n    AbsTol=1e-10, MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:217\n\n217   double BZVolume=GetRLBasis(LBasis, RLBasis);\n\n(gdb) print Omega\n$1 = {_M_value = 0.10000000000000001 + 0 * I}\n\n(gdb) u 230\n\nGetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, zp=0.10000000000000001, \n    LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, AbsTol=1e-10, \n    MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:230\n\n230   cdouble Sum[18];\n\n(gdb) print Data-\nEpsilon\n$2 = {_M_value = -45765.335680436379 + 115960.58424811834 * I}\n\n\n\n\nNote\n: If you have a better debugging solution that \ndoes not require steps \n(b)\n and/or \n(c)\n above , please\nlet me know about it. It stinks to have to run the codes\nat greatly reduced speed when debugging, because often the\nproblem spots lie after expensive sections like BEM matrix\nassembly, and then it takes forever for the code to run\nin the debugger to get there.", 
            "title": "Installation"
        }, 
        {
            "location": "/reference/Installing/#0-try-scuff-em-online-before-installing-anything", 
            "text": "Johannes Feist  has set up\nan interactive online notebook using  MyBinder \nthat you can use to run some simple  scuff-em  calculations on\nthe cloud without having to install anything. This free service\noffers limited computing power, so you won't want to attempt any\nheavy calculations here, but you can follow Johannes' tutorial\nto observe the flow of a typical  scuff-em  calculation,\nplay around with your own calculations, and get a feel for what \nusing  scuff-em  will like once you have installed it on your \nmachine.  Here's the link: http://mybinder.org/repo/jfeist/scuff-em-mybinder .", 
            "title": "0. Try scuff-em online before installing anything!"
        }, 
        {
            "location": "/reference/Installing/#1-external-packages", 
            "text": "scuff-em  relies on a small number of well-established free \nsoftware packages to implement certain non-essential functionality.  scuff-em  can be compiled and installed without any of these packages, \nbut in this case the code will be somewhat crippled.    If you actually want to solve scattering problems (instead of \n  just setting them up), you will need\n   LAPACK/BLAS .    If you want the capacity to write output files in the \n  standard HDF5 binary format, you will need\n   HDF5 .    If you want to compile the  python  interface, you will need the\n   python  development files.    Although not required to install, compile, or use\n   scuff-em ,\n   gmsh \n  is an extremely valuable open-source meshing and visualization\n  tool that is used throughout the\n   scuff-em  documentation.    On Debian/Ubuntu Linux systems, you can fetch all of these packages by doing a   % sudo apt-get install liblapack-dev libblas-dev libhdf5-serial-dev python-dev gmsh   Note: In some cases it seems the  gmsh  package conflicts with \nthe  libhdf5-serial-dev  package. In this case, just \nremove  gmsh  from the above  apt-get  statement; you can \ninstall it by hand following the instructions\non the  GMSH website .\n(Note that  gmsh , though very useful, \nis not necessary to compile or run  scuff-em .)", 
            "title": "1. External packages"
        }, 
        {
            "location": "/reference/Installing/#2-cloning-the-github-repository-and-building-the-code", 
            "text": "scuff-em  is hosted on  GitHub .\nThe current build status of the  scuff-em  master branch is:   To fetch and install the latest version of the \ncode, execute the following steps. (Replace the string /path/to/scuff-em-installation-directory \nwith your desired installation directory.)  % git clone https://homerreid@github.com/HomerReid/scuff-em.git\n% cd scuff-em\n% sh autogen.sh --prefix=/path/to/scuff-em-installation-directory\n% make install  If this succeeds, the executable versions of the application\nprograms (such as  scuff-scatter ,  scuff-rf , etc.) will be \ninstalled in the directory  PREFIX/bin/  \nand the demonstration examples for the various application programs \nwill be in  PREFIX/share/scuff-em/examples \n(where  PREFIX  is the directory you specified using the  --prefix  option above).  If you have trouble installing  scuff-em ,\nplease file an issue on the  scuff-em  GitHub page .  Build options  You may specify options to the  autogen.sh \n(or  configure ) command to guide the compilation process. \nFor a full list of available options,\ntype  configure --help.  Here we summarize some of the\nmore salient possibilities.   Multithreading:  openmp  vs.  pthreads  The  scuff-em  core library \nuses multithreading for all steps in the main flow  of\nthe BEM scattering procedure. You can use  configure \noptions to select whether this multithreading is implemented\nusing  openmp  or  pthreads . The former is the default,\nwhile the latter may be enabled like this:  % ./configure --without-openmp --with-pthreads  The default  openmp \nmultithreading tends to play better with other multithreaded \nsoftware packages and is definitely the right choice if you \nwill be operating on a shared machine with some CPU cores \noccupied by other users. \n(You can monitor performance by inspecting .log  files .  Support for  pthreads \nis a legacy feature that will be discontinued in future versions of  scuff-em .  Note: in some cases you may need to tweak certain environment \nvariables to achieve maximal  openmp  performance.\nFor example, on my workstation (which has 8 CPU cores),\nin order to get  openmp  codes\nto use all 8 cores I need to set the following environment\nvariable:  % export GOMP_CPU_AFFINITY=0-7   Disabling the python interface to speed the build process  Compiling the python interface is slow---it accounts for\nmore than half of the build time on some systems.\nIf you don't need the python interface to  scuff-em ,\nuse the option  --without-python  when running  configure \nto accelerate the build process.   Building for debugging  If you would like to run  scuff-em  API codes in a debugger\nlike  gdb ,\nyou will want to modify the build options to  (a)  include\ndebugging symbols,  (b)  turn off optimization,  (c) \ndisable  openmp  multithreading, which does not play well\nwith  GDB .   Here is the script that works for me to achieve these goals:  #!/bin/bash\n\nCC= gcc -ggdb -O0 \nCXX= g++ -ggdb -O0 \nexport CFLAGS= -O0 \nexport CXXFLAGS= -O0 \nsh autogen.sh --enable-debug --without-openmp --disable-shared  (It shouldn't be necessary to have to add  -O0  to both the\nenvironment variables and the compiler command lines, but\nthis seems to be the only way things work for me.)  After running this script to reconfigure for building with\ncompiling support, you will want to  make clean; make \nto rebuild everything with debugging support. Of course,\nafter you are finished debugging you will need to reconfigure\nwith debugging support removed and then re-do the \nclean build. Because this is time-consuming, I typically\nmaintain two separate copies of the code base, one for\ndebugging and one for running at full speed.  Once debugging support has been added, you can run \nthe code in  gdb . Here's a sample session:   % gdb /path/to/debug/repository/bin/scuff-ldos\n\n (gdb) set args   scuff-ldos.args\n\n (gdb) break GetHalfSpaceDGFs\nBreakpoint 1 at 0x409626: file AnalyticalDGFs.cc, line 217.\n\n (gdb) run\n\nBreakpoint 1, GetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, \n    zp=0.10000000000000001, LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, \n    AbsTol=1e-10, MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:217\n\n217   double BZVolume=GetRLBasis(LBasis, RLBasis);\n\n(gdb) print Omega\n$1 = {_M_value = 0.10000000000000001 + 0 * I}\n\n(gdb) u 230\n\nGetHalfSpaceDGFs (Omega=..., kBloch=0x7fffffffd5c0, zp=0.10000000000000001, \n    LBasis=0x7fffffffd380, MP=0x130a7c0, RelTol=0.01, AbsTol=1e-10, \n    MaxCells=1000, GE=0x7fffffffd3a0, GM=0x7fffffffd430)\n    at AnalyticalDGFs.cc:230\n\n230   cdouble Sum[18];\n\n(gdb) print Data- Epsilon\n$2 = {_M_value = -45765.335680436379 + 115960.58424811834 * I}  Note : If you have a better debugging solution that \ndoes not require steps  (b)  and/or  (c)  above , please\nlet me know about it. It stinks to have to run the codes\nat greatly reduced speed when debugging, because often the\nproblem spots lie after expensive sections like BEM matrix\nassembly, and then it takes forever for the code to run\nin the debugger to get there.", 
            "title": "2. Cloning the GitHub repository and building the code"
        }, 
        {
            "location": "/reference/Geometries/", 
            "text": "Geometry Descriptions in \nscuff-em\n\n\nGeometries in \nscuff-em\n are described by simple text files \nthat are conventionally given the file extension \n.scuffgeo.\n \nThe \n.scuffgeo\n file format supports a variety of options for \nspecifying scattering geometries.\n\n\nThe simplest case is one in which you have a collection of\ncompact homogeneous objects (which may be nested inside \none another). In this case, your \n.scuffgeo\n \nfile will simply specify mesh files representing the \nsurfaces of these objects, as well as optional material\nspecifications for the frequency-dependent electrical properties\nof the media inside.\n(A \nmesh\n is a collection of flat triangular panels that \napproximates a two-dimensional surface.\n\nscuff-em\n doesn't do the meshing for you;\nyou use external meshing software such as \n\nGMSH\n or \n\nCOMSOL\n\nfor that.)\n\n\nIn more complicated cases, it may not be possible to\ndescribe your geometry as a simple collection of\nobjects. This is true, for example, if your geometry \ncontains any \nmulti-material junctions\n---that is, \npoints at which three or more disparate media meet.\nIn this case your \n.scuffgeo\n file will specify \na series of three-dimensional \nregions\n and a set of \ntwo-dimensional meshed \nsurfaces\n lying between them.\n\n\nFinally, your geometry may be infinitely \nextended\n in \none or two directions. Examples of 1D extended geometries\ninclude this description of\n\nparallel silicon beams\n,\nwhile examples of 2D extended geometries include\na planar metamaterial array or an infinite square lattice\nof spheres. In this case, your \n.scuffgeo\n file will\nspecify \nlattice vectors\n together with a description\nof the objects, or the regions and surfaces, that constitute\njust the \nunit-cell\n geometry, which is then infinitely\nperiodically replicated to constitute the actual geometry.\n\n\nIn what follows we will see how to write \n.scuffgeo\n\nfiles that describe each of these types of geometries.\n\n\n\n\n\n\n\nGeometry Files in \nscuff-em\n\n\n\n\n\n \nSimple geometries: One or more compact objects (possibly nested)\n\n\n \nMore complex geometries: multi-material junctions\n\n\n \nExtended geometries: periodic boundary conditions\n\n\n \n.scuffgeo\n file syntax reference\n\n\n \nA compendium of \n.scuffgeo\n files\n\n\n\n\n\n\n \n\n\n1. Simple Geometries: One or more compact objects (possibly nested)\n\n\nThe simplest \nscuff-em\n geometries consist of \none or more \ncompact objects\n---that is, finite volumes of homogeneous media,\nbounded by closed 2D surfaces. In this case, all meshed surfaces in the geometry \nmust be \nclosed\n surfaces, and no two object surfaces may touch or overlap.\nEach surface is then associated with a single homogeneous material\nregion---namely, the region interior to that surface---and we collectively\nrefer to that material region and its closed surface as an \nobject.\n\n\nThe \n.scuffgeo\n file for geometries of this type consists simply \nof a sequence of \nobject declarations\n, one for each compact object \nin the geometry. A typical object declaration section looks something \nlike this:\n\n\nOBJECT UpperSphere\n    MESHFILE Sphere_458.msh\n    MATERIAL Gold\n    DISPLACED 0 0 3\n    ROTATED 45 ABOUT 0 0 1\nENDOBJECT\n\n\n\n\nThe string that follows the \nOBJECT\n keyword \n(\nUpperSphere\n in this case) is an arbitrary \nuser-specified label that you may attach to your object\nfor ease of identifying it in output files, etc. \n\n\nThe only keyword that is strictly required within the \n\nOBJECT...ENDOBJECT\n clause is \nMESHFILE.\n This specifies \na mesh file, generated by \ngmsh\n, \ncomsol\n, or other meshing \ntools, describing the surface of your object. \n\nscuff-em\n will look for this file in several places: \n\n\n\n\nthe current working directory\n\n\nthe directory specified by the \nSCUFF_MESH_PATH\n environment variable\n\n\nany search directories specified using the \nMESHPATH\n keyword in the \n.scuffgeo\n file.\n\n\n\n\nThe latter two options allow you to set up one or more common \nrepositories of mesh files which you can then re-use for \n\nscuff-em\n calculations launched from whatever directory you like.\n\n\nThe optional \nMATERIAL\n keyword is used to select a \n\nscuff-em\n material designation\n\n(in this case, \nGold\n) for the medium interior to \nyour object. The actual definition of the material \nGold\n\n(given by a \nMATERIAL...ENDMATERIAL\n clause)\nmay be present in the \n.scuffgeo\n file before the \n\nOBJECT\n specification, or may exist in a separate \nmaterial database file. If you don't specify a \nMATERIAL\n\nfor your object, it will be treated as a perfectly electrically \nconducting (PEC) body. \n\n\nThe optional \nDISPLACED\n and \nROTATED\n\nkeywords specify geometrical transformations \nthat are applied to the surface mesh after it is read in from \nthe mesh file. For example, if your mesh file describes a sphere \ncentered around the origin, and you include the line \n\nDISPLACED 0 0 3\n in your \nOBJECT...ENDOBJECT\n\nclause, then your geometry as interpreted by \n\nscuff-em\n will contain a sphere\ncentered around the point with cartesian coordinates \n(0,0,3). For more details, see the \n\nsyntax reference\n\nbelow.\n\n\nYour \n.scuffgeo\n file may contain any number of\n\nOBJECT...ENDOBJECT\n clauses.\nThe objects specified by these clauses may be \n\nnested\n,\ni.e. one object may be fully contained inside another \nobject; this will be autodetected by \nscuff-em\n.\n\n\n(However, this simple way of specifying geometries has \nthe constraint that no two object surfaces may touch or intersect. \nIf you find yourself needing to describe geometries involving \nobjects whose surface touch---thus defining \nmulti-material junctions\n---you\nyou have graduated to writing the \n\nslightly more complicated type of \n.scuffgeo\n file described below\n.)\n\n\nHere's an example of a simple \n.scuffgeo\n file describing \na smaller PEC sphere embedded inside a larger silicon dioxide\nsphere.\n\n\n# material specification for intrinsic silicon\nMATERIAL SILICON\nepsf = 1.035;      # \\epsilon_infinity\neps0 = 11.87;      # \\epsilon_0 \nwp = 6.6e15;       # \\plasmon frequency\nEps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\n\nOBJECT SiliconSphere \nMESHFILE Sphere_R1P0.msh\nMATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \nMESHFILE Sphere_R0P5.msh\nMATERIAL PEC\nENDOBJECT \n\n\n\n\n\n\nNote that the \nMATERIAL PEC\n specification for the \ninner sphere is actually superfluous---we could simply have \nomitted it, because PEC is the default material assumed for \n\nOBJECT\n clauses. On the other hand, if we had \ninstead said \nMATERIAL Vacuum\n, then we would be \ndescribing an \nvacuum\n sphere inside our larger \nsilicon sphere---that is, a spherical \nshell\n of silicon,\nas considered in \n[this \nscuff-scatter\n example][SphericalShellExample].\n\n\n\n\n2. More complex geometries: multi-material junctions\n\n\nThe attempt to describe a geometry simply as a collection of compact objects \nbreaks down for more complicated situations. For example, consider the composite \nsphere (or \"bihemisphere\") depicted in the figure below; this is a spherical\nobject formed by adjoining an upper hemisphere of material A to a lower \nhemisphere of material B. \n\n\nSchematic depiction of a Bihemisphere\n\n\n\n\nMesh representations of the three interface surfaces\n\n(shown displaced for clarity)\n\n\n\n\nOur first thought might be to think of the upper hemispherical volume as one \ncompact object, and the lower hemispherical volume as a second compact object.\nBut this doesn't work, because we can't assign a unique closed surface to each\ncompact object. Clearly the upper hemispherical surface \"belongs\" to object \n\nUpperHemisphere,\n and the lower hemispherical surface \"belongs\" to\nobject \nLowerHemisphere.\n But to which volume do we assign the surface \nof the equatorial plane?\n\n\nMore formally, the key aspect of the bihemisphere geometry that prevents \nit from being describable as a collection of compact objects is the presence\nof \nmulti-material junctions\n---that is, regions of the geometry \nat which three or more homogeneous material regions meet. The equator of \nthe bihemisphere is a multi-material junction. \n\n\n(A note on terminology: In \nscuff-em\n parlance,\na multi-material junction (MMJ) is a point or line \nat which \nthree or more\n homogeneous regions meet.\nOf course any meshed surface in a geometry---including \nthe closed surfaces used to describe simple compact-object \ngeometries above---lies at the junction of\nat least \ntwo\n regions, and is thus technically \na \"multi-material\" junction, but is not considered \nan MMJ for the purposes of the present discussion.)\n\n\nGeometries involving multi-material junctions are described in \n\nscuff-em\n by explicitly \nspecifying the various \nregions\n and \nsurfaces\n \nthat are present. Each \nregion\n is a contiguous volume \nthroughout which the material properties are spatially constant.\nEach \nsurface\n is a mesh describing a closed \nor open\n \n2D surface represented as a \nunion of flat triangular panels. Each surface must lie at the \ninterface between precisely two regions.\n\n\nFor example, in the bihemisphere geometry, there are three \nregions: \n\n\n\n\nThe exterior medium (vacuum).\n\n\nThe upper hemispherical volume (material A).\n\n\nThe lower hemispherical volume (material B).\n\n\n\n\nAnd there are three surfaces:\n\n\n\n\nThe upper hemispherical surface, which is an interface between regions 1 and 2.\n\n\nThe lower hemispherical surface, which is an interface between regions 1 and 3.\n\n\nThe surface of the equatorial plane, which is an interface between regions 2 and 3.\n\n\n\n\nThe \n.scuffgeo\n file for geometry described\nusing regions and surfaces will consist, unsurprisingly,\nof \nREGION\n lines and \n\nSURFACE...ENDSURFACE\n clauses.\n\n\nEach \nREGION\n line should look something like this:\n\n\nREGION UpperHemisphereVolume MATERIAL Gold\n\n\n\n\nThe string identifier following the \nREGION\n keyword is an \narbitrary label you may assign to your region. The string identifier\nfollowing the \nMATERIAL\n keyword is a \n\nscuff-em\n material designation\n\nspecifying the frequency-dependent material properties \nof the region.\n\n\nAll \nscuff-em\n geometries by default\nstart off with an implicitly defined region\nnamed \nExterior\n, of material \nVACUUM\n.\nIf you want to change the material properties of the \nexterior medium---for example, if your entire scattering geometry\nis embedded in ethanol---you can say something like \n\n\nREGION Exterior MATERIAL Ethanol\n\n\n\n\nOtherwise, you can refer freely to the region named \n\nExterior\n without defining it, as it will \nbe automatically present in all \nscuff-em\n\ngeometries.\n\n\nSurfaces in a regions-and-surfaces geometry are identified \nby \nSURFACE...ENDSURFACE\n clauses.\nThese are similar to \nOBJECT...ENDOBJECT\n \nclauses, but with a couple of differences. A typical \nexample looks like this:\n\n\nSURFACE UpperHemisphereSurface\n    MESHFILE UpperHemisphereSurface.msh\n    REGIONS Exterior UpperHemisphereVolume\nENDSURFACE\n\n\n\n\nThe string identifier following the \nSURFACE\n keyword\nis an arbitrary label you may assign to your surface to \nhelp identify it in output files, etc.\n\n\nThe mandatory \nMESHFILE\n keyword specifies the \nname of a file from which \nscuff-em\n\nwill attempt to read the surface mesh.\n\n\nThe mandatory \nREGIONS\n keyword identifies the two \nregions that lie on the two sides of the surface.\nThese should be regions that were previously declared using \n\nREGION\n statements (with the exception of the\nregion \nExteror\n, which is always implicitly \npresent.)\n\n\nThe \norder\n in which you specify surfaces is \nimportant for the internal workings of \nscuff-em\n,\nalthough most output quantities reported by most \n\nscuff-em\n codes will not depend on \nthis ordering.\n\n\nThe distinction is this: The surface normal vector is taken to \npoint \ninto\n the first region specified with the \n\nREGIONS\n keyword, and thus \naway from\n the second\nregion. What this means internally is that surface currents on \nthe surface contribute to the fields in the first region with a \n\npositive\n sign, and to the fields in the second region \nwith a \nnegative\n sign. Again, however, this is all handled \nconsistently within the internal workings of the code, so flipping\nthe order in the \nREGION\n specification should not\nlead to any differences in physically relevant output quantities.\n(If you flip the order of the regions, the currents on the surface\nchange sign, and their contributions to the fields in each region\nchange sign, so the fields don't change.)\n\n\nIn addition to the mandatory \nMESHFILE\n \nand \nREGIONS\n keyword, the \nSURFACE...ENDSURFACE\n\nmay also include \nDISPLACED\n and/or \nROTATED\n\nstatements to apply geometrical transforms to your surface,\nas is possible in \nOBJECT...ENDOBJECT\n clauses.\n\n\nNote that any geometry that may be represented in the simpler\nform discussed above (as a sequence of \nOBJECT...ENDOBJECT\n\nclauses) may also be represented in the regions-and-surfaces \nlanguage. \nA compact object consists of a single region (the interior of \nthe object) and a single surface (lying at the interface between\nthe interior and exterior regions). Thus, if the meshfile \n\nMySphere.msh\n represents a meshed sphere, then the \nfollowing two \n.scuffgeo\n files are equivalent:\n\n\nREGION SphereInterior MATERIAL Gold\n\nSURFACE TheSphere\nMESHFILE Sphere.msh\nREGIONS  Exterior SphereInterior\nENDSURFACE\n\n\n\n\nOBJECT TheSphere\nMESHFILE Sphere.msh\nMATERIAL Gold\nENDSURFACE\n\n\n\n\n(And see \nbelow\n for an example of how to \nrewrite the nested-spheres example from above\nin the regions-and-surfaces language.)\n\n\nIn some cases it may be convenient to write a single meshfile\nthat contains mesh descriptions for multiple surfaces \nin your geometry. This may be done by including a\n\nMESHTAG\n specification in your \n\nSURFACE...ENDSURFACE\n clause:\n\n\nSURFACE MySurface\n    MESHFILE MyMeshFile.msh\n    MESHTAG 12\n    REGIONS MyRegion1 MyRegion2\nENDSURFACE\n\n\n\n\nWhat this does is to instruct \nscuff-em\n to\nread from \nMyMeshFile.msh\n only those triangular panels\nthat have been tagged by the meshing program as belonging \nto entity 12. \n(Different meshing programs have different ways of tagging mesh \nentities. In \ngmsh\n, the tag corresponds to\nwhat \ngmsh\n calls the \"physical region;\"\nit is the argument that enters statements\nsuch as \nPhysical Surface(12)={...}\n in the \n.geo\n\nfile, and it is the number printed as the \nphysical-number\n\nfield in the \n.msh\n output file.)\n\n\nAs an example, here's a \n.scuffgeo\n file for the bihemisphere \ngeometry described above. The meshfile \nBiHemisphere_126.msh\n\nwas produced by a \ngmsh\n file named \n[BiHemisphere.geo](BiHemisphere.geo};\nnote that the three separate interface surfaces\nare created with three separate \nPhysical Surface\n\ncommands, each specifying a different tag, which is then used \nin the \n.scuffgeo\n file below to distinguish different \nentities in the \n.msh\n file.\n\n\nREGION Exterior        MATERIAL VACUUM\nREGION UpperHemisphere MATERIAL CONST_EPS_20\nREGION LowerHemisphere MATERIAL CONST_EPS_2\n\nSURFACE LowerHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 1\n    REGIONS Exterior LowerHemisphere\nENDSURFACE\n\nSURFACE UpperHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 2\n    REGIONS Exterior UpperHemisphere\nENDSURFACE\n\nSURFACE EquatorialPlane\n    MESHFILE BiHemisphere_126.msh\n    PHYSICAL_REGION 3\n    REGIONS UpperHemisphere LowerHemisphere\nENDSURFACE\n\n\n\n\n3. Extended geometries: periodic boundary conditions\n\n\nscuff-em\n can handle geometries that are\ninfinitely extended (that is, periodically repeated) in one or two\ndimensions using Bloch-periodic boundary conditions. In this case,\nyour \n.scuffgeo\n file will contain a specification of \nthe objects, or the surfaces and regions, that constitute the \n\nunit-cell\n geometry, together with a specification of the \n\nlattice vectors\n that describe how the unit cell is periodically\nrepeated.\n\n\n\n\nNote\n: The current version of \nscuff-em\n \nrequires that 2D lattice basis vectors have vanishing \nz\n\ncomponent and that 1D lattice basis vectors have vanishing\n\ny\n and \nz\n components. In other words, for 2D periodicity\nthe lattice vectors must live in the \nxy\n plane, while\nfor 1D periodicity the lattice vector must be aligned \nwith the \nx\n axis. This places no restriction on the \nactual geometric configurations that may be treated, but \nmay be inconvenient for some users who are accustomed to \nsetting up their periodic geometries in a different way.\n(For example, if you are studying thin films, and you are \nused to having the film surfaces parallel to the \nyz\n\nplane with the film thickness in the \nx\n direction, you will\nneed to rotate your coordinate system so that the surfaces \nre parallel to the \nxy\n plane and the thickness is in \nthe \nz\n direction.) This limitation may be lifted in \na future code release.\n\n\nNote\n: An additional restriction in the current version\nof \nscuff-em\n is that 2D lattices must be \nrectangular\n \nlattices: the first \nLATTICE\n vector must have only its \n\nx\n component nonzero, while the second \nLATTICE\n vector \nmust have only its \ny\n component nonzero (although the two \nvectors may have different lengths).\n. This actually \ndoes\n place restrictions on \nthe geometries that may be treated (for example, it \nexcludes hexagonal lattices), and it will be remedied\nas soon as somebody wants to run calculations on a \nnon-square-lattice geometry and is willing to help me\ntest the new feature.\n\n\n\n\nThe lattice is specified using a \nLATTICE...ENDLATTICE\n\nsection. For example, a square lattice with lattice constant \nof 1 \n\\mu\nm would look like this: \n\n\nLATTICE\nVECTOR 1 0 \nVECTOR 0 1 \nENDLATTICE \n\n\n\n\nEach \nVECTOR xx yy\n statement adds a new lattice vector\nwith cartesian components of \n(xx,yy)\n length units.\n\n\nYou may specify one or two \nVECTOR\n statements.\nIf you specify a single \nVECTOR\n, your unit-cell\ngeometry will be periodically repeated in just that one direction.\nIf you specify two \nVECTOR\n statements, your unit-cell\ngeometry will be periodically repeated in a two-dimensional lattice\npattern.\n\n\nHaving specified the lattice vectors, the remainder of your \n\n.scuffgeo\n file just consists of a specification of \nthe unit-cell geometry as if it were a standalone compact \ngeometry. For example, you may include \nOBJECT...ENDOBJECT\n \nsections to describe any compact objects that exist inside \nthe unit cell, or \nREGION\n statements and \nSURFACE...ENDSURFACE\n\nsections to describe more complicated unit-cell geometries.\n\n\nCompact objects fully contained in the unit cell\n\n\nThe simplest case is that in which your geometry is simply \nan array of isolated compact objects (with \"isolated\" here meaning \nthat each object does not touch its periodically repeated images.)\nIn this case, you will want to make sure that the objects \nlie entirely within the unit cell (not straddling its boundaries),\n\n\nFor example, here's a \n.scuffgeo\n file describing\na square lattice of cubical nanoparticles:\n\n\n The unit cell geometry \n\n\n\n\n The innermost 25 cells of the full geometry \n\n\n\n\n The \n.scuffgeo\n file \n \n\n\nLATTICE\nVECTOR 0.5  0\nVECTOR 0.0  0.5\nENDLATTICE \n\nOBJECT CubicalNanoparticle\nMESHFILE Cube.msh\nMATERIAL Silicon\nENDOBJECT\n\n\n\n\nSurfaces that straddle the unit-cell boundary\n\n\nMore generally, your unit-cell geometry may include surfaces \nthat straddle the unit-cell boundary. (This will be the case \nwhenever the infinite surfaces you are describing are \n\nconnected\n, as opposed to the isolated arrays of objects\nconsidered above). For example, here's a \n.scuffgeo\n\nfile representing a thin metallic film perforated by an \narray of holes. The parameters here are chosen to mimic \nthe geometry studied by \n\nMartin-Moreno et al, \nPhysical Review Letters\n \n86\n 1114 (2001).\n\n\n The unit cell geometry\n\n\n\n\nThe innermost 25 cells of the full geometry\n\n\n\n\n The \n.scuffgeo\n file\n\n\nLATTICE\nVECTOR 0.75  0\nVECTOR 0.0   0.75\nENDLATTICE \n\nOBJECT UnitCellMesh\nMESHFILE PFT_794.msh\nMATERIAL Gold\nENDOBJECT\n\n\n\n\nMeshing constraints for surfaces that straddle the unit-cell boundary\n\n\nThere is an important constraint on the surface meshes that may be\n\nused to define the unit-cell geometry for problems involving continuous symmetries.\n\n\nThe constraint is this: \n\nFor any panel edge that lies on a unit-cell \nboundary, there must be an identical edge lying on the opposite \nside of the unit-cell boundary.\n One way to think about this is \nthat the periodically-repeated images of the unit-cell geometry must \nall fit together \"nicely\" at the unit-cell boundaries, as indicated \nin the right panel of the figure above.\n\n\n\n\n4. Syntax reference for the \n.scuffgeo\n file format\n\n\nA \n.scuffgeo\n file consists of one or more multiline\n\nsections\n (delimited by starting and ending keywords)\nplus zero or more single-line \nstatements\n.\n\n\nBlank lines and comments (lines beginning with a \n#\n symbol)\nare ignored in \n.scuffgeo\n files.\n\n\nMESHPATH\n statement\n\n\n\n\n\n \n Keyword \n \n\n Description \n \n\n\n\n\n \n\n \nMESHPATH\n \nmy-mesh-path\n\n\n Adds the directory \nmy-mesh-path\n\n     to the path searched by \nscuff-em\n \n     for mesh files.\n\n\n\n \n\n\n\n\nREGION\n statement\n\n\n\n\n\n \n Keyword \n \n\n Description \n \n\n\n\n\n \n\n \nREGION\n \nName\n\n     \nMATERIAL\n \nMaterial\n\n\n\n\n \n     Adds a new homogeneous material region\n     to the geometry with name \nName\n\n     and material properties described by the     \n     \nscuff-em\n \n     material designation \nMaterial\n.\n\n     As discussed above, \nREGION\n\n     statements are \nnot needed\n\n     for geometries consisting of compact homogeneous\n     bodies described by \nOBJECT\n sections.\n     (Each \nOBJECT\n section automatically\n     adds a new region to the problem for the interior\n     of the object in question.) \nREGION\n\n     statements are generally only necessary when your \n     geometry contains \n     \nmulti-material junctions.\n\n\n\n\n\n \n\n\n\n\nOBJECT...ENDOBJECT\n sections\n\n\n\n\n\n \n Keyword \n \n\n Description \n \n\n\n\n\n \n\n \nOBJECT\n \nobject label\n \n\n\n Begins an object declaration for an object with the specified\nlabel.\n\n\n\n \n\n\n \n\n \nMESHFILE\n \nMyFile.msh\n \n\n\n Specifies the mesh file that defines the closed surface\n     of the object.\n\n\n\n \n\n\n \n\n \nMESHTAG \n \nxx\n \n\n\n Specifies that only panels tagged in the mesh\n     file with tag \nxx\n are to be considered \n     part of the surface of this object. This allows a\n     single \n.msh\n file to contain multiple\n     closed surfaces each defining distinct objects.\n\n\n\n \n\n\n \n\n \nMATERIAL \n \nMyMaterial\n \n\n\n Specifies a \nscuff-em\n\n     material designation for the homogeneous medium\n     interior to the object.\n\n\n\n \n\n\n \n\n \nDISPLACED\n \nxx yy zz\n \n\n\n Indicates that the contents of the specified mesh \nfile are to be translated through a displacement vector with \ncartesian components (\nxx, yy, zz\nbefore\ninclusion in the geometry.\n\n\n\n\n\n\n \n\n \nROTATED\n \ndd\n \nABOUT\n \nnx ny nz\n \n\n\n Indicates that the contents of the specified mesh \nfile are to be rotated through an angle of \ndd\n\ndegrees (\ndegrees, not radians\n) about an axis passing \nthrough the origin and through the point with cartesian coordinates\n(\nnx, ny, nz/\nbefore inclusion in the geometry.\n\n\n\n \n\n\n \n\n \nENDOBJECT\n\n\n Ends the object declaration.\n\n\n\n \n\n\n\n\nSURFACE...ENDSURFACE\n sections\n\n\nLATTICE...ENDLATTICE\n sections\n\n\nMATERIAL...ENDMATERIAL\n sections\n\n\n\n\nFor details on how to write a \nMATERIAL\n section,\nsee \nhere\n.\n\n\n\n\n \n\n\n5. A compendium of sample \n.scuffgeo\n files\n\n\nThe images corresponding to the \n.scuffgeo\n files below were \nobtained using the \nscuff-analyze\n utility distributed with \nthe \nscuff-em\n suite, like this:\n\n\n% scuff-analyze --geometry MyGeometry.scuffgeo --WriteGMSHFiles\n\n\n\n\nThis produces a \ngmsh\n post-processing file \nnamed \nMyGeometry.pp\n that you can open in \n\ngmsh\n to visualize your geometry and\nmake sure \nscuff-em\n interpreted your \n\n.scuffgeo\n file as you intended.\nThis is generally a good thing to do before launching any serious\ncalculations.\n\n\n\n\nA single perfectly electrically conducting (PEC) sphere\n\n\nThis is perhaps the simplest imaginable \nscuff-em\n\ngeometry.\n\n\nOBJECT PECSphere \n    MESHFILE Sphere.msh\nENDOBJECT \n\n\n\n\n\n\n\n\n\n\nA gold sphere and a silicon sphere\n\n\nThis example illustrates the use of the \nDISPLACED\n\nkeyword to displace a surface mesh relative to its positioning \nin the mesh file. Note in particular that this keyword allows\nus to use the same mesh file to describe two different spheres,\nwhich speeds things up by allowing \nscuff-em\n \nto reuse certain parts of the calculation, thus eliminating\nredundant numerical work. (Without the \nDISPLACED\n \nkeyword in this example, the two spheres would be sitting on \ntop of one another.)\n\n\nMATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nMATERIAL GOLD\n  wp = 1.37e16; \n  gamma = 5.32e13;\n  Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nMESHPATH /home/homer/work/MeshFiles\n\nOBJECT GoldSphere\n  MESHFILE Sphere.msh\n  MATERIAL Gold\n  DISPLACED 0 0 3\nENDOBJECT \n\nOBJECT SiliconSphere\n  MESHFILE Sphere.msh\n  MATERIAL Silicon\nENDOBJECT \n\n\n\n\n\n\n\n\n\n\nA small gold sphere inside a larger silicon dioxide sphere\n\n\nMATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT SiliconSphere \n  MESHFILE Sphere_R1P0.msh\n  MATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \n  MESHFILE Sphere_R0P5.msh\n  MATERIAL PEC\nENDOBJECT", 
            "title": "Geometry descriptions"
        }, 
        {
            "location": "/reference/Geometries/#1-simple-geometries-one-or-more-compact-objects-possibly-nested", 
            "text": "The simplest  scuff-em  geometries consist of \none or more  compact objects ---that is, finite volumes of homogeneous media,\nbounded by closed 2D surfaces. In this case, all meshed surfaces in the geometry \nmust be  closed  surfaces, and no two object surfaces may touch or overlap.\nEach surface is then associated with a single homogeneous material\nregion---namely, the region interior to that surface---and we collectively\nrefer to that material region and its closed surface as an  object.  The  .scuffgeo  file for geometries of this type consists simply \nof a sequence of  object declarations , one for each compact object \nin the geometry. A typical object declaration section looks something \nlike this:  OBJECT UpperSphere\n    MESHFILE Sphere_458.msh\n    MATERIAL Gold\n    DISPLACED 0 0 3\n    ROTATED 45 ABOUT 0 0 1\nENDOBJECT  The string that follows the  OBJECT  keyword \n( UpperSphere  in this case) is an arbitrary \nuser-specified label that you may attach to your object\nfor ease of identifying it in output files, etc.   The only keyword that is strictly required within the  OBJECT...ENDOBJECT  clause is  MESHFILE.  This specifies \na mesh file, generated by  gmsh ,  comsol , or other meshing \ntools, describing the surface of your object.  scuff-em  will look for this file in several places:    the current working directory  the directory specified by the  SCUFF_MESH_PATH  environment variable  any search directories specified using the  MESHPATH  keyword in the  .scuffgeo  file.   The latter two options allow you to set up one or more common \nrepositories of mesh files which you can then re-use for  scuff-em  calculations launched from whatever directory you like.  The optional  MATERIAL  keyword is used to select a  scuff-em  material designation \n(in this case,  Gold ) for the medium interior to \nyour object. The actual definition of the material  Gold \n(given by a  MATERIAL...ENDMATERIAL  clause)\nmay be present in the  .scuffgeo  file before the  OBJECT  specification, or may exist in a separate \nmaterial database file. If you don't specify a  MATERIAL \nfor your object, it will be treated as a perfectly electrically \nconducting (PEC) body.   The optional  DISPLACED  and  ROTATED \nkeywords specify geometrical transformations \nthat are applied to the surface mesh after it is read in from \nthe mesh file. For example, if your mesh file describes a sphere \ncentered around the origin, and you include the line  DISPLACED 0 0 3  in your  OBJECT...ENDOBJECT \nclause, then your geometry as interpreted by  scuff-em  will contain a sphere\ncentered around the point with cartesian coordinates \n(0,0,3). For more details, see the  syntax reference \nbelow.  Your  .scuffgeo  file may contain any number of OBJECT...ENDOBJECT  clauses.\nThe objects specified by these clauses may be  nested ,\ni.e. one object may be fully contained inside another \nobject; this will be autodetected by  scuff-em .  (However, this simple way of specifying geometries has \nthe constraint that no two object surfaces may touch or intersect. \nIf you find yourself needing to describe geometries involving \nobjects whose surface touch---thus defining  multi-material junctions ---you\nyou have graduated to writing the  slightly more complicated type of  .scuffgeo  file described below .)  Here's an example of a simple  .scuffgeo  file describing \na smaller PEC sphere embedded inside a larger silicon dioxide\nsphere.  # material specification for intrinsic silicon\nMATERIAL SILICON\nepsf = 1.035;      # \\epsilon_infinity\neps0 = 11.87;      # \\epsilon_0 \nwp = 6.6e15;       # \\plasmon frequency\nEps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\n\nOBJECT SiliconSphere \nMESHFILE Sphere_R1P0.msh\nMATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \nMESHFILE Sphere_R0P5.msh\nMATERIAL PEC\nENDOBJECT    Note that the  MATERIAL PEC  specification for the \ninner sphere is actually superfluous---we could simply have \nomitted it, because PEC is the default material assumed for  OBJECT  clauses. On the other hand, if we had \ninstead said  MATERIAL Vacuum , then we would be \ndescribing an  vacuum  sphere inside our larger \nsilicon sphere---that is, a spherical  shell  of silicon,\nas considered in \n[this  scuff-scatter  example][SphericalShellExample].", 
            "title": "1. Simple Geometries: One or more compact objects (possibly nested)"
        }, 
        {
            "location": "/reference/Geometries/#2-more-complex-geometries-multi-material-junctions", 
            "text": "The attempt to describe a geometry simply as a collection of compact objects \nbreaks down for more complicated situations. For example, consider the composite \nsphere (or \"bihemisphere\") depicted in the figure below; this is a spherical\nobject formed by adjoining an upper hemisphere of material A to a lower \nhemisphere of material B.   Schematic depiction of a Bihemisphere   Mesh representations of the three interface surfaces \n(shown displaced for clarity)   Our first thought might be to think of the upper hemispherical volume as one \ncompact object, and the lower hemispherical volume as a second compact object.\nBut this doesn't work, because we can't assign a unique closed surface to each\ncompact object. Clearly the upper hemispherical surface \"belongs\" to object  UpperHemisphere,  and the lower hemispherical surface \"belongs\" to\nobject  LowerHemisphere.  But to which volume do we assign the surface \nof the equatorial plane?  More formally, the key aspect of the bihemisphere geometry that prevents \nit from being describable as a collection of compact objects is the presence\nof  multi-material junctions ---that is, regions of the geometry \nat which three or more homogeneous material regions meet. The equator of \nthe bihemisphere is a multi-material junction.   (A note on terminology: In  scuff-em  parlance,\na multi-material junction (MMJ) is a point or line \nat which  three or more  homogeneous regions meet.\nOf course any meshed surface in a geometry---including \nthe closed surfaces used to describe simple compact-object \ngeometries above---lies at the junction of\nat least  two  regions, and is thus technically \na \"multi-material\" junction, but is not considered \nan MMJ for the purposes of the present discussion.)  Geometries involving multi-material junctions are described in  scuff-em  by explicitly \nspecifying the various  regions  and  surfaces  \nthat are present. Each  region  is a contiguous volume \nthroughout which the material properties are spatially constant.\nEach  surface  is a mesh describing a closed  or open  \n2D surface represented as a \nunion of flat triangular panels. Each surface must lie at the \ninterface between precisely two regions.  For example, in the bihemisphere geometry, there are three \nregions:    The exterior medium (vacuum).  The upper hemispherical volume (material A).  The lower hemispherical volume (material B).   And there are three surfaces:   The upper hemispherical surface, which is an interface between regions 1 and 2.  The lower hemispherical surface, which is an interface between regions 1 and 3.  The surface of the equatorial plane, which is an interface between regions 2 and 3.   The  .scuffgeo  file for geometry described\nusing regions and surfaces will consist, unsurprisingly,\nof  REGION  lines and  SURFACE...ENDSURFACE  clauses.  Each  REGION  line should look something like this:  REGION UpperHemisphereVolume MATERIAL Gold  The string identifier following the  REGION  keyword is an \narbitrary label you may assign to your region. The string identifier\nfollowing the  MATERIAL  keyword is a  scuff-em  material designation \nspecifying the frequency-dependent material properties \nof the region.  All  scuff-em  geometries by default\nstart off with an implicitly defined region\nnamed  Exterior , of material  VACUUM .\nIf you want to change the material properties of the \nexterior medium---for example, if your entire scattering geometry\nis embedded in ethanol---you can say something like   REGION Exterior MATERIAL Ethanol  Otherwise, you can refer freely to the region named  Exterior  without defining it, as it will \nbe automatically present in all  scuff-em \ngeometries.  Surfaces in a regions-and-surfaces geometry are identified \nby  SURFACE...ENDSURFACE  clauses.\nThese are similar to  OBJECT...ENDOBJECT  \nclauses, but with a couple of differences. A typical \nexample looks like this:  SURFACE UpperHemisphereSurface\n    MESHFILE UpperHemisphereSurface.msh\n    REGIONS Exterior UpperHemisphereVolume\nENDSURFACE  The string identifier following the  SURFACE  keyword\nis an arbitrary label you may assign to your surface to \nhelp identify it in output files, etc.  The mandatory  MESHFILE  keyword specifies the \nname of a file from which  scuff-em \nwill attempt to read the surface mesh.  The mandatory  REGIONS  keyword identifies the two \nregions that lie on the two sides of the surface.\nThese should be regions that were previously declared using  REGION  statements (with the exception of the\nregion  Exteror , which is always implicitly \npresent.)  The  order  in which you specify surfaces is \nimportant for the internal workings of  scuff-em ,\nalthough most output quantities reported by most  scuff-em  codes will not depend on \nthis ordering.  The distinction is this: The surface normal vector is taken to \npoint  into  the first region specified with the  REGIONS  keyword, and thus  away from  the second\nregion. What this means internally is that surface currents on \nthe surface contribute to the fields in the first region with a  positive  sign, and to the fields in the second region \nwith a  negative  sign. Again, however, this is all handled \nconsistently within the internal workings of the code, so flipping\nthe order in the  REGION  specification should not\nlead to any differences in physically relevant output quantities.\n(If you flip the order of the regions, the currents on the surface\nchange sign, and their contributions to the fields in each region\nchange sign, so the fields don't change.)  In addition to the mandatory  MESHFILE  \nand  REGIONS  keyword, the  SURFACE...ENDSURFACE \nmay also include  DISPLACED  and/or  ROTATED \nstatements to apply geometrical transforms to your surface,\nas is possible in  OBJECT...ENDOBJECT  clauses.  Note that any geometry that may be represented in the simpler\nform discussed above (as a sequence of  OBJECT...ENDOBJECT \nclauses) may also be represented in the regions-and-surfaces \nlanguage. \nA compact object consists of a single region (the interior of \nthe object) and a single surface (lying at the interface between\nthe interior and exterior regions). Thus, if the meshfile  MySphere.msh  represents a meshed sphere, then the \nfollowing two  .scuffgeo  files are equivalent:  REGION SphereInterior MATERIAL Gold\n\nSURFACE TheSphere\nMESHFILE Sphere.msh\nREGIONS  Exterior SphereInterior\nENDSURFACE  OBJECT TheSphere\nMESHFILE Sphere.msh\nMATERIAL Gold\nENDSURFACE  (And see  below  for an example of how to \nrewrite the nested-spheres example from above\nin the regions-and-surfaces language.)  In some cases it may be convenient to write a single meshfile\nthat contains mesh descriptions for multiple surfaces \nin your geometry. This may be done by including a MESHTAG  specification in your  SURFACE...ENDSURFACE  clause:  SURFACE MySurface\n    MESHFILE MyMeshFile.msh\n    MESHTAG 12\n    REGIONS MyRegion1 MyRegion2\nENDSURFACE  What this does is to instruct  scuff-em  to\nread from  MyMeshFile.msh  only those triangular panels\nthat have been tagged by the meshing program as belonging \nto entity 12. \n(Different meshing programs have different ways of tagging mesh \nentities. In  gmsh , the tag corresponds to\nwhat  gmsh  calls the \"physical region;\"\nit is the argument that enters statements\nsuch as  Physical Surface(12)={...}  in the  .geo \nfile, and it is the number printed as the  physical-number \nfield in the  .msh  output file.)  As an example, here's a  .scuffgeo  file for the bihemisphere \ngeometry described above. The meshfile  BiHemisphere_126.msh \nwas produced by a  gmsh  file named \n[BiHemisphere.geo](BiHemisphere.geo};\nnote that the three separate interface surfaces\nare created with three separate  Physical Surface \ncommands, each specifying a different tag, which is then used \nin the  .scuffgeo  file below to distinguish different \nentities in the  .msh  file.  REGION Exterior        MATERIAL VACUUM\nREGION UpperHemisphere MATERIAL CONST_EPS_20\nREGION LowerHemisphere MATERIAL CONST_EPS_2\n\nSURFACE LowerHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 1\n    REGIONS Exterior LowerHemisphere\nENDSURFACE\n\nSURFACE UpperHemisphereSurface \n    MESHFILE BiHemisphere_126.msh\n    MESHTAG 2\n    REGIONS Exterior UpperHemisphere\nENDSURFACE\n\nSURFACE EquatorialPlane\n    MESHFILE BiHemisphere_126.msh\n    PHYSICAL_REGION 3\n    REGIONS UpperHemisphere LowerHemisphere\nENDSURFACE", 
            "title": "2. More complex geometries: multi-material junctions"
        }, 
        {
            "location": "/reference/Geometries/#3-extended-geometries-periodic-boundary-conditions", 
            "text": "scuff-em  can handle geometries that are\ninfinitely extended (that is, periodically repeated) in one or two\ndimensions using Bloch-periodic boundary conditions. In this case,\nyour  .scuffgeo  file will contain a specification of \nthe objects, or the surfaces and regions, that constitute the  unit-cell  geometry, together with a specification of the  lattice vectors  that describe how the unit cell is periodically\nrepeated.   Note : The current version of  scuff-em  \nrequires that 2D lattice basis vectors have vanishing  z \ncomponent and that 1D lattice basis vectors have vanishing y  and  z  components. In other words, for 2D periodicity\nthe lattice vectors must live in the  xy  plane, while\nfor 1D periodicity the lattice vector must be aligned \nwith the  x  axis. This places no restriction on the \nactual geometric configurations that may be treated, but \nmay be inconvenient for some users who are accustomed to \nsetting up their periodic geometries in a different way.\n(For example, if you are studying thin films, and you are \nused to having the film surfaces parallel to the  yz \nplane with the film thickness in the  x  direction, you will\nneed to rotate your coordinate system so that the surfaces \nre parallel to the  xy  plane and the thickness is in \nthe  z  direction.) This limitation may be lifted in \na future code release.  Note : An additional restriction in the current version\nof  scuff-em  is that 2D lattices must be  rectangular  \nlattices: the first  LATTICE  vector must have only its  x  component nonzero, while the second  LATTICE  vector \nmust have only its  y  component nonzero (although the two \nvectors may have different lengths).\n. This actually  does  place restrictions on \nthe geometries that may be treated (for example, it \nexcludes hexagonal lattices), and it will be remedied\nas soon as somebody wants to run calculations on a \nnon-square-lattice geometry and is willing to help me\ntest the new feature.   The lattice is specified using a  LATTICE...ENDLATTICE \nsection. For example, a square lattice with lattice constant \nof 1  \\mu m would look like this:   LATTICE\nVECTOR 1 0 \nVECTOR 0 1 \nENDLATTICE   Each  VECTOR xx yy  statement adds a new lattice vector\nwith cartesian components of  (xx,yy)  length units.  You may specify one or two  VECTOR  statements.\nIf you specify a single  VECTOR , your unit-cell\ngeometry will be periodically repeated in just that one direction.\nIf you specify two  VECTOR  statements, your unit-cell\ngeometry will be periodically repeated in a two-dimensional lattice\npattern.  Having specified the lattice vectors, the remainder of your  .scuffgeo  file just consists of a specification of \nthe unit-cell geometry as if it were a standalone compact \ngeometry. For example, you may include  OBJECT...ENDOBJECT  \nsections to describe any compact objects that exist inside \nthe unit cell, or  REGION  statements and  SURFACE...ENDSURFACE \nsections to describe more complicated unit-cell geometries.", 
            "title": "3. Extended geometries: periodic boundary conditions"
        }, 
        {
            "location": "/reference/Geometries/#compact-objects-fully-contained-in-the-unit-cell", 
            "text": "The simplest case is that in which your geometry is simply \nan array of isolated compact objects (with \"isolated\" here meaning \nthat each object does not touch its periodically repeated images.)\nIn this case, you will want to make sure that the objects \nlie entirely within the unit cell (not straddling its boundaries),  For example, here's a  .scuffgeo  file describing\na square lattice of cubical nanoparticles:   The unit cell geometry     The innermost 25 cells of the full geometry     The  .scuffgeo  file     LATTICE\nVECTOR 0.5  0\nVECTOR 0.0  0.5\nENDLATTICE \n\nOBJECT CubicalNanoparticle\nMESHFILE Cube.msh\nMATERIAL Silicon\nENDOBJECT", 
            "title": "Compact objects fully contained in the unit cell"
        }, 
        {
            "location": "/reference/Geometries/#surfaces-that-straddle-the-unit-cell-boundary", 
            "text": "More generally, your unit-cell geometry may include surfaces \nthat straddle the unit-cell boundary. (This will be the case \nwhenever the infinite surfaces you are describing are  connected , as opposed to the isolated arrays of objects\nconsidered above). For example, here's a  .scuffgeo \nfile representing a thin metallic film perforated by an \narray of holes. The parameters here are chosen to mimic \nthe geometry studied by  Martin-Moreno et al,  Physical Review Letters   86  1114 (2001).   The unit cell geometry   The innermost 25 cells of the full geometry    The  .scuffgeo  file  LATTICE\nVECTOR 0.75  0\nVECTOR 0.0   0.75\nENDLATTICE \n\nOBJECT UnitCellMesh\nMESHFILE PFT_794.msh\nMATERIAL Gold\nENDOBJECT", 
            "title": "Surfaces that straddle the unit-cell boundary"
        }, 
        {
            "location": "/reference/Geometries/#meshing-constraints-for-surfaces-that-straddle-the-unit-cell-boundary", 
            "text": "There is an important constraint on the surface meshes that may be \nused to define the unit-cell geometry for problems involving continuous symmetries.  The constraint is this:  For any panel edge that lies on a unit-cell \nboundary, there must be an identical edge lying on the opposite \nside of the unit-cell boundary.  One way to think about this is \nthat the periodically-repeated images of the unit-cell geometry must \nall fit together \"nicely\" at the unit-cell boundaries, as indicated \nin the right panel of the figure above.", 
            "title": "Meshing constraints for surfaces that straddle the unit-cell boundary"
        }, 
        {
            "location": "/reference/Geometries/#4-syntax-reference-for-the-scuffgeo-file-format", 
            "text": "A  .scuffgeo  file consists of one or more multiline sections  (delimited by starting and ending keywords)\nplus zero or more single-line  statements .  Blank lines and comments (lines beginning with a  #  symbol)\nare ignored in  .scuffgeo  files.  MESHPATH  statement      Keyword     Description         MESHPATH   my-mesh-path   Adds the directory  my-mesh-path \n     to the path searched by  scuff-em  \n     for mesh files.     REGION  statement      Keyword     Description         REGION   Name \n      MATERIAL   Material    \n     Adds a new homogeneous material region\n     to the geometry with name  Name \n     and material properties described by the     \n      scuff-em  \n     material designation  Material .\n\n     As discussed above,  REGION \n     statements are  not needed \n     for geometries consisting of compact homogeneous\n     bodies described by  OBJECT  sections.\n     (Each  OBJECT  section automatically\n     adds a new region to the problem for the interior\n     of the object in question.)  REGION \n     statements are generally only necessary when your \n     geometry contains \n      multi-material junctions.      OBJECT...ENDOBJECT  sections      Keyword     Description         OBJECT   object label     Begins an object declaration for an object with the specified\nlabel.        MESHFILE   MyFile.msh     Specifies the mesh file that defines the closed surface\n     of the object.        MESHTAG    xx     Specifies that only panels tagged in the mesh\n     file with tag  xx  are to be considered \n     part of the surface of this object. This allows a\n     single  .msh  file to contain multiple\n     closed surfaces each defining distinct objects.        MATERIAL    MyMaterial     Specifies a  scuff-em \n     material designation for the homogeneous medium\n     interior to the object.        DISPLACED   xx yy zz     Indicates that the contents of the specified mesh \nfile are to be translated through a displacement vector with \ncartesian components ( xx, yy, zz before\ninclusion in the geometry.       ROTATED   dd   ABOUT   nx ny nz     Indicates that the contents of the specified mesh \nfile are to be rotated through an angle of  dd \ndegrees ( degrees, not radians ) about an axis passing \nthrough the origin and through the point with cartesian coordinates\n( nx, ny, nz/ before inclusion in the geometry.        ENDOBJECT   Ends the object declaration.     SURFACE...ENDSURFACE  sections  LATTICE...ENDLATTICE  sections  MATERIAL...ENDMATERIAL  sections   For details on how to write a  MATERIAL  section,\nsee  here .", 
            "title": "4. Syntax reference for the .scuffgeo file format"
        }, 
        {
            "location": "/reference/Geometries/#5-a-compendium-of-sample-scuffgeo-files", 
            "text": "The images corresponding to the  .scuffgeo  files below were \nobtained using the  scuff-analyze  utility distributed with \nthe  scuff-em  suite, like this:  % scuff-analyze --geometry MyGeometry.scuffgeo --WriteGMSHFiles  This produces a  gmsh  post-processing file \nnamed  MyGeometry.pp  that you can open in  gmsh  to visualize your geometry and\nmake sure  scuff-em  interpreted your  .scuffgeo  file as you intended.\nThis is generally a good thing to do before launching any serious\ncalculations.   A single perfectly electrically conducting (PEC) sphere  This is perhaps the simplest imaginable  scuff-em \ngeometry.  OBJECT PECSphere \n    MESHFILE Sphere.msh\nENDOBJECT      A gold sphere and a silicon sphere  This example illustrates the use of the  DISPLACED \nkeyword to displace a surface mesh relative to its positioning \nin the mesh file. Note in particular that this keyword allows\nus to use the same mesh file to describe two different spheres,\nwhich speeds things up by allowing  scuff-em  \nto reuse certain parts of the calculation, thus eliminating\nredundant numerical work. (Without the  DISPLACED  \nkeyword in this example, the two spheres would be sitting on \ntop of one another.)  MATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nMATERIAL GOLD\n  wp = 1.37e16; \n  gamma = 5.32e13;\n  Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nMESHPATH /home/homer/work/MeshFiles\n\nOBJECT GoldSphere\n  MESHFILE Sphere.msh\n  MATERIAL Gold\n  DISPLACED 0 0 3\nENDOBJECT \n\nOBJECT SiliconSphere\n  MESHFILE Sphere.msh\n  MATERIAL Silicon\nENDOBJECT      A small gold sphere inside a larger silicon dioxide sphere  MATERIAL SILICON\n  epsf = 1.035;      # \\epsilon_infinity\n  eps0 = 11.87;      # \\epsilon_0 \n  wp = 6.6e15;       # \\plasmon frequency\n  Eps(w) = epsf + (eps0-epsf)/(1-(w/wp)^2);\nENDMATERIAL\n\nOBJECT SiliconSphere \n  MESHFILE Sphere_R1P0.msh\n  MATERIAL Silicon\nENDOBJECT \n\n\nOBJECT InnerSphere \n  MESHFILE Sphere_R0P5.msh\n  MATERIAL PEC\nENDOBJECT", 
            "title": "5. A compendium of sample .scuffgeo files"
        }, 
        {
            "location": "/reference/Materials/", 
            "text": "Material descriptions in \nscuff-em\n\n\nscuff-em\n allows the\nfrequency-dependent electrical properties (dielectric\npermittivity and magnetic permeability) of materials to be \nspecified in one of several ways:\n\n\n\n\nYou can use a \nbuilt-in\n material like \nPEC\n or \nVacuum.\n  \n\n\nYou can specify a material with \nconstant\n (frequency-independent) \npermittivity and permeability.\n\n\nYou can specify a data file containing tabulated \npermittivity and permeability values over a range of \nfrequencies; in this case, \nscuff-em\n\nwill interpolate between values in your file to estimate\nmaterial properties at arbitrary frequencies.\n\n\nYou can define your own material with \narbitrary frequency-dependent material properties,\nspecified using mathematical expressions.\n\n\n\n\nMaterials are generally specified to\n\nscuff-em\n by including a line like \n\n\nMATERIAL MyMaterialName\n\n\n\n\nin the \n\n.scuffgeo\n file\n;\nhere \nMyMaterialName\n is a string constructed in different\nways depending on which of the above types of material specification\nyou have in mind, as detailed below.\n\n\nNote that material specification in \nscuff-em\n are \n\ncase-insensitive.\n The strings \nTEFLON,\n \nTeflon,\n and \nteflon\n all \nrefer to the same material.\n\n\nNote also that the values of the permittivity and permeability\ndescribed by \nscuff-em\n material designations are always\nthe dimensionless \nrelative\n permittivity and permeability,\nwith values of 1 in vacuum.\n\n\n\n\n\n\n \n Material specifications in \nscuff-em\n\n\n\n\n \n \nBuilt-in materials\n\n \n \nFrequency-independent materials\n\n \n \nMaterials specified using tabulated data\n\n \n \nUser-defined materials\n\n \n \n\n       \nscuff-plotepseu:\n A command-line \n       utility for verifying material properties\n\n\n\n\n\n\n\n\n\n1. Built-In Materials\n\n\nThe two built-in materials are \nVacuum\n and \n\nPEC\n. The former describes a material with \n\n\\epsilon=\\mu=1\n at all frequencies, while the latter describes \na \nP\nerfect \nE\nlectrical \nC\nonductor.\n\n\n\n\n\n\n2. Frequency-independent materials\n\n\nFor a non-magnetic material with frequency-independent permittivity\n\n\\epsilon\n, you can use a material specification of the form \n\n\nMATERIAL CONST_EPS_11.8\n\n\n\n\nwhere you would replace \n11.8\n with the constant value \nof the permittivity. (Note that \nCONST_EPS_11.8\n \nis all one word, with no spaces.)\n\n\nFor a material with frequency-independent permittivity \n\\epsilon\n\n\nand\n frequency-independent permeability \n\\mu\\ne1\n, you can \nuse a material-property designation of the form \n\n\nMATERIAL CONST_EPS_11.8_MU_0.8\n\n\n\n\nwhere you would replace \n0.8\n with the constant value \nof the permeability. (Again, all one word, no spaces.)\n\n\nYou can also specify materials with negative and/or complex \npermittivity: \n\n\nMATERIAL CONST_EPS_-54+46i\n\n\n\n\nOf course, a dielectric function with a frequency-independent \nimaginary part is unphysical, but no problems will arise as long \nas you are only doing computations at a single frequency.\n\n\n\n\n\n\n3. Materials specified using tabulated data\n\n\nIf you have tabulated frequency data for the permittivity and/or permeability\nof your material, you can specify this to \nscuff-em\n using a material \nspecification of the form\n\n\nMATERIAL FILE_MyDataFile.dat\n\n\n\n\nwhere the \nFILE_\n part of the string is fixed, and the \nremainder is the name of your data file (which is of course case-sensitive.)\nAgain, note that the material property specification is all one word with\nno spaces.\n\n\nThe data file is interpreted by \nscuff-em\n\nin the following way:\n\n\n\n\nBlank lines and comments (lines beginning with \n#\n) are ignored.\n\n\nAll other lines must contain either two or three space-separated \nstrings, which are interpreted as\n\n\n\n\n\n\nOmega\n \nEpsilon(Omega)\n  [\nMu(Omega)\n]\n\n\n\n\nwhere \nOmega\n is an angular frequency, \nEpsilon(Omega)\n \nis the relative permittivity at that frequency, and the optional\n\nMu(Omega)\n is the relative permeability.\n\n\nThe values specified for \nEps\n and \nMu\n may be\n\ncomplex numbers.\n.\n\n\nNote that \n\\omega\n values in material data files are always specified\nin units of radians per second, \nnot\n the specialized frequency\nunits that are used in \nscuff-em\n application codes.\n For \nexample, an angular frequency of \n3\\cdot 10^{14}\n rad/sec would\nbe specified as \n1.0\n in (for example) the \n--omega\n argument\nto \nscuff-scatter\n, but as \n3.0e14\n in a material data file.\n\n\nFor example, suppose you have tabulated data for the \nfrequency-dependent permittivity of silver over a finite\nrange of frequencies. Put those data into a text file\ncalled (for example) \nSilver.dat\n\nwith the angular frequencies (in radians per second)\non the first column, and the complex relative permittivity\non the second column, so that the data file looks something\nlike this:\n\n\n2.5133e15 -28.832+0.39369i\n2.6180e15 -26.235+0.35815i\n...\n5.2360e15 -2.3459+0.23547i\n5.3855e15 -1.7349+0.24727i\n\n\n\n\nThis says that, for example, at angular frequency\n\n\\omega=2.5133\\cdot 10^{15}\\hbox{ rad/sec}\n we have \nrelative permittivity \n\n\\epsilon(\\omega)=-28.832 + 0.39369i.\n\n\n\n\nThen your \n.scuffgeo\n file may refer to a material\nnamed \nFILE_Silver.dat,\n whose dielectric function at\narbitrary frequencies \n\\omega\n will be obtained by\ninterpolating the data specified in your data file.\nFor example, to describe a sphere made of this material\nyour ``.scuffgeo'' file could contain a section like\n\n\nOBJECT SilverSphere\n    MESHFILE Sphere.msh\n    MATERIAL FILE_Silver.dat\nENDOBJECT\n\n\n\n\nNote: If you are doing calculations at \nimaginary\n frequencies\n(in \nscuff-cas3d\n, \nscuff-caspol\n, or \nscuff-scatter\n with\nan imaginary value specified for \n--omega\n)\nand you have tabulated data for the relative permittivity\non the imaginary frequency axis, you can play exactly the \nsame game described above, except that now the \n\\omega\n\nvalues on the first column of the data file will be \npure imaginary (they will end in \ni\n or \nI\n).\n(Also, on physical grounds the relative permittivity at\neach frequency should be real-valued and positive in this \ncase).\n\n\n\n\n\n\n4. User-defined materials\n\n\nFor more general materials, you will want to define your own\nfrequency-dependent material designations. You do this by \nfirst creating an entry in a database file that describes \nyour material, and then referring back to that entry in \n\n.scuffgeo\n files and anywhere else you need to \nspecify a material property designation. (Alternatively, \nyou can define the material on-the-fly inside a \n\nMATERIAL...ENDMATERIAL\n section in your \n.scuffgeo\n file. \nSee \nhere\n for more details.\n\n\n\n\nThe location of the database file\n\n\nlibmatprop\n looks in the following three places for its \ndatabase file:\n\n\n\n\n\n\nThe file \n${HOME}/.matprop.dat\n (i.e. a file \nnamed \n.matprop.dat\n in the top-level directory\nfor your user account.)\n\n\n\n\n\n\nThe file named by the environment variable \nSCUFF_MATPROPFILE.\n \n\n\n\n\n\n\nA file named \nmatprop.dat\n in the current working\ndirectory. (Note the absence of a leading period as compared\nwith the previous item.)\n\n\n\n\n\n\nPersonally, I think the first or second of these options is the most\nconvenient; they allow you to create and maintain a single database\nfile that contains all the common materials you will ever need to use.\n\n\nEntries in the database file\n\n\nA typical entry in the database file looks like this:\n\n\nMATERIAL SiliconCarbide\n\n  EpsInf = 6.7;\n  a0     = -3.32377e28;\n  a1     = +8.93329e11;\n  b0     = -2.21677e28;\n  b1     = 8.93329e11;\n\n  Eps(w) = EpsInf * ( w^2 + a1*i*w + a0 ) / ( w^2 + b1*i*w + b0);\n\nENDMATERIAL\n\n\n\n\nThe first line defines the name of the material (the name you\nwould supply as an argument to the \nMATERIAL\n keyword \nin a \n.scuffgeo\n file, for example).\n\n\nThe next few lines define some constants. These constant\ndefinitions are specific to this particular \nMATERIAL\n;\ntwo different \nMATERIAL\n sections in the database \nfile may define the same constant to have two different values.\n\n\nThe line \nEps(w) = ...\n defines the \nfrequency-dependent relative permittivity of your material.\nThe expression to the right of the \n=\n sign is \nparsed and interpreted as a function\nof the single variable \nw,\n the angular frequency.\nThe expression may refer to any of the constants you have defined \nfor the present material; it may also use the symbols\n\ni\n and \nI\n to denote the imaginary unit.\n\n\nAgain, \n\\omega\n values in material property specifications are \nalways interpreted in units of radians per second, \nnot\n the \nspecialized angular-frequency units that are used in some of the \n\nscuff-em\n application codes.\n\n\nIf your material has \n\\mu\\ne 1\n, you may optionally also include a line \nof the form\n\n\nMu(w) = some-function(w)\n\n\n\n\nA Sample Database File\n\n\nHere is a sample database file:\nmatprop.dat\n.\nI recommend you rename this file to \n${HOME}/.matprop.dat\n and \naugment it as necessary for your applications.\n\n\n\n\n \n\n\n5. \nscuff-plotEpsMu:\n A command-line utility for verifying material properties\n\n\nThe \nscuff-em\n distribution comes with an application program named \n\nscuff-plotEpsMu\n that you\ncan use to make sure that a material property designation is \ninterpreted the way you intended. You can run this command with \nno arguments to get usage information:\n\n\n% scuff-plotEpsMu \n\nerror: --material option is mandatory (aborting)\n\nusage: scuff-plotEpsMu [options]\n\noptions: \n\n--material xx  (name of material)\n--OmegaMin xx  (minimum angular frequency)\n--OmegaMax xx  (maximum angular frequency)\n--gnuplot      (use GNUPLOT to plot results)\n--geometry xx  (.scuffgeo file containing material definition)\n\n\n\n\nRunning \nscuff-plotEpsMu --material MyMaterial\n\nwill produce an output file name \nMyMaterial.epsmu\n,\nwhich will contain 7 columns of data, representing the \npermittivity and permeability of your material at various \nangular frequencies on both the real and imaginary \n \naxes:\n\n\n\n\n\n\n \n\n Column   \n\n\n 1 \n \n 2 \n \n 3 \n \n 4 \n \n\n 5 \n \n 6 \n \n 7 \n\n\n \n\n \n\n Quantity \n\n\n \n \n\n\n Re \n(\n)  \n\n\n Im \n(\n)  \n\n\n Re \n(\n)  \n\n\n Im \n(\n)  \n\n\n \n(i\n) \n\n\n \n(i\n) \n\n\n \n\n\n\n\n\n\nIf \ngnuplot\n is installed on your system,\nthen you can use the \n--GnuPlot\n option to generate pop-up \nplots of \n\\epsilon(\\omega)\n and \n\\mu(\\omega)\n vs. \n\\omega\n\nfor your material.\n\n\nYou can use \n--OmegaMin/--OmegaMax\n to set the\nrange of angular frequencies over which material properties \nwill be plotted. The defaults are equivalent to specifying \n\n--OmegaMin 1e8\n and \n--OmegaMax 1e16\n, \nrespectively.\n\n\nIf your material is defined on-the-fly in a \n.scuffgeo\n \nfile, you can pass that file to \nscuff-plotEpsMu\n using \nthe \n--geometry\n option. (If your material is defined\nin a \nmaterial database file\n\nthen this option is not needed.)\n\n\nFor example, in \n\nthis example\n\nwe used a material named \nSiliconCarbide,\n which was defined\nin a geometry file named \nSiCSphere.scuffgeo.\n To check the\nthe frequency-dependent permittivity of this material, we can say\n\n\n% scuff-plotEpsMu --material SiliconCarbide --geometry SiCSphere.scuffgeo --gnuplot\n\n\n\n\nThis will pop up four graphs, of which one looks something like this:", 
            "title": "Material designations"
        }, 
        {
            "location": "/reference/Materials/#1-built-in-materials", 
            "text": "The two built-in materials are  Vacuum  and  PEC . The former describes a material with  \\epsilon=\\mu=1  at all frequencies, while the latter describes \na  P erfect  E lectrical  C onductor.", 
            "title": "1. Built-In Materials"
        }, 
        {
            "location": "/reference/Materials/#2-frequency-independent-materials", 
            "text": "For a non-magnetic material with frequency-independent permittivity \\epsilon , you can use a material specification of the form   MATERIAL CONST_EPS_11.8  where you would replace  11.8  with the constant value \nof the permittivity. (Note that  CONST_EPS_11.8  \nis all one word, with no spaces.)  For a material with frequency-independent permittivity  \\epsilon  and  frequency-independent permeability  \\mu\\ne1 , you can \nuse a material-property designation of the form   MATERIAL CONST_EPS_11.8_MU_0.8  where you would replace  0.8  with the constant value \nof the permeability. (Again, all one word, no spaces.)  You can also specify materials with negative and/or complex \npermittivity:   MATERIAL CONST_EPS_-54+46i  Of course, a dielectric function with a frequency-independent \nimaginary part is unphysical, but no problems will arise as long \nas you are only doing computations at a single frequency.", 
            "title": "2. Frequency-independent materials"
        }, 
        {
            "location": "/reference/Materials/#3-materials-specified-using-tabulated-data", 
            "text": "If you have tabulated frequency data for the permittivity and/or permeability\nof your material, you can specify this to  scuff-em  using a material \nspecification of the form  MATERIAL FILE_MyDataFile.dat  where the  FILE_  part of the string is fixed, and the \nremainder is the name of your data file (which is of course case-sensitive.)\nAgain, note that the material property specification is all one word with\nno spaces.  The data file is interpreted by  scuff-em \nin the following way:   Blank lines and comments (lines beginning with  # ) are ignored.  All other lines must contain either two or three space-separated \nstrings, which are interpreted as    Omega   Epsilon(Omega)   [ Mu(Omega) ]   where  Omega  is an angular frequency,  Epsilon(Omega)  \nis the relative permittivity at that frequency, and the optional Mu(Omega)  is the relative permeability.  The values specified for  Eps  and  Mu  may be complex numbers. .  Note that  \\omega  values in material data files are always specified\nin units of radians per second,  not  the specialized frequency\nunits that are used in  scuff-em  application codes.  For \nexample, an angular frequency of  3\\cdot 10^{14}  rad/sec would\nbe specified as  1.0  in (for example) the  --omega  argument\nto  scuff-scatter , but as  3.0e14  in a material data file.  For example, suppose you have tabulated data for the \nfrequency-dependent permittivity of silver over a finite\nrange of frequencies. Put those data into a text file\ncalled (for example)  Silver.dat \nwith the angular frequencies (in radians per second)\non the first column, and the complex relative permittivity\non the second column, so that the data file looks something\nlike this:  2.5133e15 -28.832+0.39369i\n2.6180e15 -26.235+0.35815i\n...\n5.2360e15 -2.3459+0.23547i\n5.3855e15 -1.7349+0.24727i  This says that, for example, at angular frequency \\omega=2.5133\\cdot 10^{15}\\hbox{ rad/sec}  we have \nrelative permittivity  \\epsilon(\\omega)=-28.832 + 0.39369i.   Then your  .scuffgeo  file may refer to a material\nnamed  FILE_Silver.dat,  whose dielectric function at\narbitrary frequencies  \\omega  will be obtained by\ninterpolating the data specified in your data file.\nFor example, to describe a sphere made of this material\nyour ``.scuffgeo'' file could contain a section like  OBJECT SilverSphere\n    MESHFILE Sphere.msh\n    MATERIAL FILE_Silver.dat\nENDOBJECT  Note: If you are doing calculations at  imaginary  frequencies\n(in  scuff-cas3d ,  scuff-caspol , or  scuff-scatter  with\nan imaginary value specified for  --omega )\nand you have tabulated data for the relative permittivity\non the imaginary frequency axis, you can play exactly the \nsame game described above, except that now the  \\omega \nvalues on the first column of the data file will be \npure imaginary (they will end in  i  or  I ).\n(Also, on physical grounds the relative permittivity at\neach frequency should be real-valued and positive in this \ncase).", 
            "title": "3. Materials specified using tabulated data"
        }, 
        {
            "location": "/reference/Materials/#4-user-defined-materials", 
            "text": "For more general materials, you will want to define your own\nfrequency-dependent material designations. You do this by \nfirst creating an entry in a database file that describes \nyour material, and then referring back to that entry in  .scuffgeo  files and anywhere else you need to \nspecify a material property designation. (Alternatively, \nyou can define the material on-the-fly inside a  MATERIAL...ENDMATERIAL  section in your  .scuffgeo  file. \nSee  here  for more details.   The location of the database file  libmatprop  looks in the following three places for its \ndatabase file:    The file  ${HOME}/.matprop.dat  (i.e. a file \nnamed  .matprop.dat  in the top-level directory\nfor your user account.)    The file named by the environment variable  SCUFF_MATPROPFILE.      A file named  matprop.dat  in the current working\ndirectory. (Note the absence of a leading period as compared\nwith the previous item.)    Personally, I think the first or second of these options is the most\nconvenient; they allow you to create and maintain a single database\nfile that contains all the common materials you will ever need to use.  Entries in the database file  A typical entry in the database file looks like this:  MATERIAL SiliconCarbide\n\n  EpsInf = 6.7;\n  a0     = -3.32377e28;\n  a1     = +8.93329e11;\n  b0     = -2.21677e28;\n  b1     = 8.93329e11;\n\n  Eps(w) = EpsInf * ( w^2 + a1*i*w + a0 ) / ( w^2 + b1*i*w + b0);\n\nENDMATERIAL  The first line defines the name of the material (the name you\nwould supply as an argument to the  MATERIAL  keyword \nin a  .scuffgeo  file, for example).  The next few lines define some constants. These constant\ndefinitions are specific to this particular  MATERIAL ;\ntwo different  MATERIAL  sections in the database \nfile may define the same constant to have two different values.  The line  Eps(w) = ...  defines the \nfrequency-dependent relative permittivity of your material.\nThe expression to the right of the  =  sign is \nparsed and interpreted as a function\nof the single variable  w,  the angular frequency.\nThe expression may refer to any of the constants you have defined \nfor the present material; it may also use the symbols i  and  I  to denote the imaginary unit.  Again,  \\omega  values in material property specifications are \nalways interpreted in units of radians per second,  not  the \nspecialized angular-frequency units that are used in some of the  scuff-em  application codes.  If your material has  \\mu\\ne 1 , you may optionally also include a line \nof the form  Mu(w) = some-function(w)  A Sample Database File  Here is a sample database file: matprop.dat .\nI recommend you rename this file to  ${HOME}/.matprop.dat  and \naugment it as necessary for your applications.", 
            "title": "4. User-defined materials"
        }, 
        {
            "location": "/reference/Materials/#5-scuff-plotepsmu-a-command-line-utility-for-verifying-material-properties", 
            "text": "The  scuff-em  distribution comes with an application program named  scuff-plotEpsMu  that you\ncan use to make sure that a material property designation is \ninterpreted the way you intended. You can run this command with \nno arguments to get usage information:  % scuff-plotEpsMu \n\nerror: --material option is mandatory (aborting)\n\nusage: scuff-plotEpsMu [options]\n\noptions: \n\n--material xx  (name of material)\n--OmegaMin xx  (minimum angular frequency)\n--OmegaMax xx  (maximum angular frequency)\n--gnuplot      (use GNUPLOT to plot results)\n--geometry xx  (.scuffgeo file containing material definition)  Running  scuff-plotEpsMu --material MyMaterial \nwill produce an output file name  MyMaterial.epsmu ,\nwhich will contain 7 columns of data, representing the \npermittivity and permeability of your material at various \nangular frequencies on both the real and imaginary   \naxes:       Column      1     2     3     4     5     6     7        Quantity         Re  ( )     Im  ( )     Re  ( )     Im  ( )      (i )     (i )       If  gnuplot  is installed on your system,\nthen you can use the  --GnuPlot  option to generate pop-up \nplots of  \\epsilon(\\omega)  and  \\mu(\\omega)  vs.  \\omega \nfor your material.  You can use  --OmegaMin/--OmegaMax  to set the\nrange of angular frequencies over which material properties \nwill be plotted. The defaults are equivalent to specifying  --OmegaMin 1e8  and  --OmegaMax 1e16 , \nrespectively.  If your material is defined on-the-fly in a  .scuffgeo  \nfile, you can pass that file to  scuff-plotEpsMu  using \nthe  --geometry  option. (If your material is defined\nin a  material database file \nthen this option is not needed.)  For example, in  this example \nwe used a material named  SiliconCarbide,  which was defined\nin a geometry file named  SiCSphere.scuffgeo.  To check the\nthe frequency-dependent permittivity of this material, we can say  % scuff-plotEpsMu --material SiliconCarbide --geometry SiCSphere.scuffgeo --gnuplot  This will pop up four graphs, of which one looks something like this:", 
            "title": "5. scuff-plotEpsMu: A command-line utility for verifying material properties"
        }, 
        {
            "location": "/reference/Transformations/", 
            "text": "Geometrical transformations in \nscuff-em\n\n\nFor some of the physical problems handled by codes in the \n\nscuff-em\n suite, it is of interest\nto consider the effect of \ngeometrical transformations\n---namely, \nrigid displacements and rotations of the objects in a geometry with \nrespect to one another.\n\n\nFor example, if you are investigating the Casimir force between \ntwo nanoparticles of some exotic shape, you will probably want\nto carry out the calculation for many (let's say 25) different \nvalues of the interparticle separation and obtain the full \nforce-vs-separation \ncurve\n, not just the force on a single\nconfiguration.\n\n\nOf course, one way to handle this situation would be simply to\ncreate 25 different \n.scuffgeo\n files, each describing\nthe nanoparticles at different separation distances, and then run \n\nscuff-cas3d\n \n25 separate times. However, such a procedure would not only be a major\nhassle, but would also fail to exploit some significant \ncomputational redundancies.\n\n\nFor example, in a geometry consisting of two nanoparticles,\nthe diagonal blocks of the \n\nBEM matrix\n\nare \nindependent of the interparticle separation\n and hence \nneed only be assembled once per frequency, after which they \ncan be \nreused\n for all 25 interparticle separations.\nThis can save a lot of time as compared to the cost of \nrunning 25 independent calculations.\n\n\nTo facilitate this type of calculation, several of the \nstandalone applications in the \n\nscuff-em\n \nsuite offer the option of specifying a \ntransformation list.\n\nThis is a file describing a sequence of geometrical transformations\nto be carried out on the base geometry described by your \n\n.scuffgeo\n file. Each output quantity that you\nrequest (be it the \ny-\ndirected Casimir force, the \ntotal heat transfer, or what have you) will then be computed\nand reported separately for each of the transformations you \nspecified.\n\n\nAn important caveat is that \n\ngeometrical transformations may not change the \nnesting topology\n of a \n\nscuff-em\n geometry.\n This is discussed in more detail\n\nbelow\n.\n\n\n\n\n\n \n \n\n Geometrical Transformations in\n                      \nscuff-em\n\n                 \n\n\n\n\n \n \nSyntax of the \n.trans\n file\n\n \n \nAn example of a \n.trans\n file\n\n \n \nVisualizing the effect of the transformations you specified\n\n \n \nTransformations may not change the nesting topology\n\n\n\n\n\n\n\n1. Syntax of the \n.trans\n file\n\n\nYou will list your geometrical transformations in a file \nwhose name conventionally has file extension \n.trans\n.\nThis is the file you will specify using the \n\n--transfile\n option to \n\nscuff-cas3d\n \nand other codes.\n\n\nThe \n.trans\n file may contain any number of \ntransformations. \nEach transformation will specify \nwhich\n objects in your\ngeometry are to be transformed, and \nhow\n those objects \nwill be displaced or rotated. \n\n\nEach transformation will be specified by a section of the file\nthat looks something like this:\n\n\n\n\nTRANSFORMATION\n \nname-of-transformation\n\n\n \n \n \nOBJECT\n \nFirstObjectLabel\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n ...\n\n\n \n \n \nOBJECT\n \nSecondObjectLabel\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n \ndisplacement-or-rotation\n\n\n \n \n \n \n \n ...\n\n\nENDTRANSFORMATION\n\n\n\n\nThe \nname-of-transformation\n field after the \n\nTRANSFORMATION\n keyword specifies a mandatory label\nassigned to this transformation, which will be used\nin output files to identify quantities computed under this\ntransformation. \n\n\nThe \nFirstObjectLabel\n field should be the label of\nan object in your geometry (as assigned using the \nOBJECT\n\nkeyword in a \n.scuffgeo\n file\n.\nDisplacements and rotations specified after this line will apply to the\nobject named on this line, until the next \nOBJECT\n line is \nencountered.\n\n\nEach \ndisplacement-or-rotation\n line should look either like\nthis:\n\n\n\n\n\n\nDISPLACED\n   \nxx yy zz\n\n\n\n\n\n\nor like this:\n\n\n\n\n\n\nROTATED\n \ndd\n \nABOUT\n \nnx ny nz\n\n\n\n\n\n\nThe former case specifies that the object in question is to be displaced\nthrough a displacement vector with cartesian coordinates \n\n(xx,yy,zz)\n.\n\n\nThe latter case specifies that the object in question is to be rotated\nthrough \ndd\n degrees about an axis passing through the origin\nand through the point with cartesian coordinates \n(xx,yy,zz).\n\nNote that \nABOUT\n is a fixed keyword that must be repeated\nverbatim.\n\n(Note that the rotation angle is specified in \ndegrees, not radians.)\n\n\nYou may specify any number of \nDISPLACEMENT\n and \n\nROTATION\n statements to be applied to each object.\nThese statements will be applied in the order they are \nspecified in the \n.trans\n file.\n\n\nNote that \nTRANSFORMATION...ENDTRANSFORMATION\n\nsections are not cumulative; two consecutive such sections do not \nbuild on each other, but instead describe distinct transformations\napplied to the geometry starting in its original state as described \nin the \n.scuffgeo\n file.\n\n\n(However, if your \n.scuffgeo\n included any \n\nDISPLACED\n or \nROTATED\n statements to\ntransform object meshes prior to their inclusion in the\ngeometry, then the transformations in a \n.trans\n\nfile \nare\n cumulative with respect to those, as any\nsuch transformations are considered to be included\ninto the base default configuration of the geometry.)\n\n\nBlank lines and comments (lines beginning with \n#\n) in\n\n.trans\n files are ignored.\n\n\nAbbreviated Syntax\n\n\nFor simple transformations you may use the following\nabbreviated one-line syntax in place of an entire\n\nTRANSFORMATION...ENDTRANSFORMATION\n section:\n\n\n\n\nTRANS\n \nname\n \nOBJECT\n \nLabel\n   \ndisplacement-or-rotation\n\n\n\n\nThis differs from the syntax outlined above in the following\nways: \n\n\n\n\nThe entire transformation is specified on a single line.\n\n\nThe line begins with the shortened keyword \nTRANS\n, and there is no terminating keyword.\n\n\n\n\nEmpty Transformations\n\n\nThe following transformations are perfectly legal:\n\n\nTRANSFORMATION Nothing\nENDTRANSFORMATION\n\n\n\n\nTRANS Default\n\n\n\n\nThese define \ntransformations\n that actually leave the geometry\nuntouched from the configuration specified in the \n.scuffgeo\n\nfile. You may name these transformations anything you please, just\nas with any other transformations. This is sometimes useful for\ncarrying out computations on a sequence of geometric configurations\nof which one is the unmodified configuration of the \n.scuffgeo\n\nfile.\n\n\n\n\n2. An example of a \n.trans\n file\n\n\nHere's an example of a \n.trans\n file designed to \nbe used with \nthis geometry file\n,\nwhich contains two objects with\nuser-assigned labels \nTheSphere\n and \nTheCube\n.\n\n\nNote that, in the \n.scuffgeo\n file, the cube is \ndisplaced 3 units in the positive \nz\n direction relative \nto the configuration of its mesh file; as noted above,\ntransformations in the \n.trans\n are \ncarried out starting from that displaced configuration.\n\n\nThis file declares three separate transformations:\n\n\n\n\n\n\nThe first (labeled \n2.0\n) displaces the sphere 2.0 \nlength units in the \ny\n direction, while simultaneously \ndisplacing the cube 2.0 units in the \nx\n direction.  \n\n\n\n\n\n\nThe second (labeled \n2.0R\n) is the same as the \nfirst, but with the cube first rotated 45 degrees \n(\n/4 radians) about the \nz\n axis before it is \ndisplaced.  \n\n\n\n\n\n\nThe third (labeled \n-3.0\n) displaces the sphere \nnegative 3.0 length units in the \ny\n direction, while\nleaving the cube untouched.\n\n\n\n\n\n\n# a transformation in which both cube and sphere are displaced \nTRANSFORMATION 2.0\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# similar to the above, but now the square is rotated before it is displaced\nTRANSFORMATION 2.0R\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nROTATED      45 ABOUT 0 0 1 \nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# in this transformation, only the sphere is affected, so we can use the abbreviated syntax\nTRANS -3.0 OBJECT TheSphere DISP 0.0 -3.0 0.0\n\n\n\n\n\n\n3. Visualizing the effect of the transformations you specified\n\n\nBefore running a full calculation using a \n.trans\n\nfile, you will generally want to double-check to make sure \nthat the geometrical transformations as interpreted by \n\nscuff-em\n are actually what \nyou intended. \n\n\nA simple way to do this is to use the \n\nscuff-analyze\n\nutility application that comes with the \nscuff-em\n distribution. \nInvoking this utility\nwith the \n--geometry\n and \n--transfile\n\noptions to specify your \n.scuffgeo\n and \n\n.trans\n files will produce an output file \ncalled \nMyGeometry.transformed.pp\n \n(where \nMyGeometry.scuffgeo\n was the name of the \nyour geometry file) which you can open in \n\ngmsh\n.\n\n\nFor example, to visualize the impact of the transformations \nin the example above, we could proceed as follows.\n(All the files needed to execute this example may be found\nin the \nexamples/SphereCube\n directory of the \n\nscuff-em\n source distribution.)\n\n\n% scuff-analyze --geometry SphereCube.scuffgeo --transfile SphereCube.trans\n\n\n\n\nThis will generate a file named \nSphereCube.transformed.pp\n\nthat you can open in \ngmsh\n:\n\n\n% gmsh SphereCube.transformed.pp\n\n\n\n\n\n\n\n\n\n\nNote that the items in the \ngmsh\n\nmenu here are labeled using the strings you assigned to each\ntransformation in your \n.trans\n file (the\n\nname-of-transformation\n field in the syntax \ndescription above).\n\n\n\n\n4. Geometrical transformations may not change the nesting topology\n\n\nAn important restriction on the use of geometrical transformations \nin \nscuff-em\n is that transformations \nmay not change the \nnesting topology\n of a \n\nscuff-em\n geometry -- that is, the \ncontainership relations that classify which objects are \nembedded inside which other objects. This is because \n\nscuff-em\n autodetects the nesting \ntopology when it first reads in the \n.scuffgeo\n\nfile and cannot subsequently redefine it.\n\n\nFor example, perhaps your \n.scuffgeo\n file describes \na geometry consisting of a big sphere (perhaps filled with a dielectric \nliquid like water) and a smaller sphere (perhaps a ball of silicon) \ninside this sphere. In this case, you can use geometrical \ntransformations to move the smaller sphere around \nwithin\n the \nlarger sphere, but you may not write a geometrical transformation\nthat displaces the smaller sphere all the way \noutside\n \nthe larger sphere. If you want to run simulations in which the \nsmaller sphere lies outside the larger sphere, you will need to \nwrite a new \n.scuffgeo\n file in which that condition \nis satisfied from the start.\n\n\n(Also, you may not write a geometrical transformation that \ndisplaces the smaller sphere in such a way that its surface\nintersects the surface of the larger sphere -- in that case,\nyour geometry would contain a\n\nmulti-material junction\n\nand would require a \n.scuffgeo\n description in terms of \n\nREGIONS\n and \nSURFACES\n instead of the simpler \ndescription in terms of \nOBJECTS\n\nthat suffices for fully-embedded geometries.)\n\n\nAs another example, suppose you want to compute the Casimir force \nbetween two identical dielectric objects over a range of separations. \nIn this case, you might be tempted to write a \n.scuffgeo\n \nfile in which the two objects start out lying on top of each other,\nand then displace them using geometrical transformations in the\nactual force computation. However, this won't work: when \n\nscuff-em\n first processes the \n\n.scuffgeo\n file, it will be confused by the appearance\nof two objects appearing to coexist in the same physical space,\nand the nesting topology will be incorrectly characterized.\nInstead, you will want to start out with a \n.scuffgeo\n\nfile in which the objects are displaced from one another; you can,\nof course, subsequently rotate or displace them further to your\nheart's content using geometrical transformations.", 
            "title": "Geometric transformations"
        }, 
        {
            "location": "/reference/Transformations/#1-syntax-of-the-trans-file", 
            "text": "You will list your geometrical transformations in a file \nwhose name conventionally has file extension  .trans .\nThis is the file you will specify using the  --transfile  option to  scuff-cas3d  \nand other codes.  The  .trans  file may contain any number of \ntransformations. \nEach transformation will specify  which  objects in your\ngeometry are to be transformed, and  how  those objects \nwill be displaced or rotated.   Each transformation will be specified by a section of the file\nthat looks something like this:   TRANSFORMATION   name-of-transformation        OBJECT   FirstObjectLabel              displacement-or-rotation              displacement-or-rotation             ...        OBJECT   SecondObjectLabel              displacement-or-rotation              displacement-or-rotation             ...  ENDTRANSFORMATION   The  name-of-transformation  field after the  TRANSFORMATION  keyword specifies a mandatory label\nassigned to this transformation, which will be used\nin output files to identify quantities computed under this\ntransformation.   The  FirstObjectLabel  field should be the label of\nan object in your geometry (as assigned using the  OBJECT \nkeyword in a  .scuffgeo  file .\nDisplacements and rotations specified after this line will apply to the\nobject named on this line, until the next  OBJECT  line is \nencountered.  Each  displacement-or-rotation  line should look either like\nthis:    DISPLACED     xx yy zz    or like this:    ROTATED   dd   ABOUT   nx ny nz    The former case specifies that the object in question is to be displaced\nthrough a displacement vector with cartesian coordinates  (xx,yy,zz) .  The latter case specifies that the object in question is to be rotated\nthrough  dd  degrees about an axis passing through the origin\nand through the point with cartesian coordinates  (xx,yy,zz). \nNote that  ABOUT  is a fixed keyword that must be repeated\nverbatim. (Note that the rotation angle is specified in \ndegrees, not radians.)  You may specify any number of  DISPLACEMENT  and  ROTATION  statements to be applied to each object.\nThese statements will be applied in the order they are \nspecified in the  .trans  file.  Note that  TRANSFORMATION...ENDTRANSFORMATION \nsections are not cumulative; two consecutive such sections do not \nbuild on each other, but instead describe distinct transformations\napplied to the geometry starting in its original state as described \nin the  .scuffgeo  file.  (However, if your  .scuffgeo  included any  DISPLACED  or  ROTATED  statements to\ntransform object meshes prior to their inclusion in the\ngeometry, then the transformations in a  .trans \nfile  are  cumulative with respect to those, as any\nsuch transformations are considered to be included\ninto the base default configuration of the geometry.)  Blank lines and comments (lines beginning with  # ) in .trans  files are ignored.", 
            "title": "1. Syntax of the .trans file"
        }, 
        {
            "location": "/reference/Transformations/#abbreviated-syntax", 
            "text": "For simple transformations you may use the following\nabbreviated one-line syntax in place of an entire TRANSFORMATION...ENDTRANSFORMATION  section:   TRANS   name   OBJECT   Label     displacement-or-rotation   This differs from the syntax outlined above in the following\nways:    The entire transformation is specified on a single line.  The line begins with the shortened keyword  TRANS , and there is no terminating keyword.", 
            "title": "Abbreviated Syntax"
        }, 
        {
            "location": "/reference/Transformations/#empty-transformations", 
            "text": "The following transformations are perfectly legal:  TRANSFORMATION Nothing\nENDTRANSFORMATION  TRANS Default  These define  transformations  that actually leave the geometry\nuntouched from the configuration specified in the  .scuffgeo \nfile. You may name these transformations anything you please, just\nas with any other transformations. This is sometimes useful for\ncarrying out computations on a sequence of geometric configurations\nof which one is the unmodified configuration of the  .scuffgeo \nfile.", 
            "title": "Empty Transformations"
        }, 
        {
            "location": "/reference/Transformations/#2-an-example-of-a-trans-file", 
            "text": "Here's an example of a  .trans  file designed to \nbe used with  this geometry file ,\nwhich contains two objects with\nuser-assigned labels  TheSphere  and  TheCube .  Note that, in the  .scuffgeo  file, the cube is \ndisplaced 3 units in the positive  z  direction relative \nto the configuration of its mesh file; as noted above,\ntransformations in the  .trans  are \ncarried out starting from that displaced configuration.  This file declares three separate transformations:    The first (labeled  2.0 ) displaces the sphere 2.0 \nlength units in the  y  direction, while simultaneously \ndisplacing the cube 2.0 units in the  x  direction.      The second (labeled  2.0R ) is the same as the \nfirst, but with the cube first rotated 45 degrees \n( /4 radians) about the  z  axis before it is \ndisplaced.      The third (labeled  -3.0 ) displaces the sphere \nnegative 3.0 length units in the  y  direction, while\nleaving the cube untouched.    # a transformation in which both cube and sphere are displaced \nTRANSFORMATION 2.0\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# similar to the above, but now the square is rotated before it is displaced\nTRANSFORMATION 2.0R\n\nOBJECT       TheSphere\nDISPLACED    0.0 2.0 0.0 \n\nOBJECT       TheCube\nROTATED      45 ABOUT 0 0 1 \nDISPLACED    2.0 0.0 0.0\n\nENDTRANSFORMATION\n\n# in this transformation, only the sphere is affected, so we can use the abbreviated syntax\nTRANS -3.0 OBJECT TheSphere DISP 0.0 -3.0 0.0", 
            "title": "2. An example of a .trans file"
        }, 
        {
            "location": "/reference/Transformations/#3-visualizing-the-effect-of-the-transformations-you-specified", 
            "text": "Before running a full calculation using a  .trans \nfile, you will generally want to double-check to make sure \nthat the geometrical transformations as interpreted by  scuff-em  are actually what \nyou intended.   A simple way to do this is to use the  scuff-analyze \nutility application that comes with the  scuff-em  distribution. \nInvoking this utility\nwith the  --geometry  and  --transfile \noptions to specify your  .scuffgeo  and  .trans  files will produce an output file \ncalled  MyGeometry.transformed.pp  \n(where  MyGeometry.scuffgeo  was the name of the \nyour geometry file) which you can open in  gmsh .  For example, to visualize the impact of the transformations \nin the example above, we could proceed as follows.\n(All the files needed to execute this example may be found\nin the  examples/SphereCube  directory of the  scuff-em  source distribution.)  % scuff-analyze --geometry SphereCube.scuffgeo --transfile SphereCube.trans  This will generate a file named  SphereCube.transformed.pp \nthat you can open in  gmsh :  % gmsh SphereCube.transformed.pp     Note that the items in the  gmsh \nmenu here are labeled using the strings you assigned to each\ntransformation in your  .trans  file (the name-of-transformation  field in the syntax \ndescription above).", 
            "title": "3. Visualizing the effect of the transformations you specified"
        }, 
        {
            "location": "/reference/Transformations/#4-geometrical-transformations-may-not-change-the-nesting-topology", 
            "text": "An important restriction on the use of geometrical transformations \nin  scuff-em  is that transformations \nmay not change the  nesting topology  of a  scuff-em  geometry -- that is, the \ncontainership relations that classify which objects are \nembedded inside which other objects. This is because  scuff-em  autodetects the nesting \ntopology when it first reads in the  .scuffgeo \nfile and cannot subsequently redefine it.  For example, perhaps your  .scuffgeo  file describes \na geometry consisting of a big sphere (perhaps filled with a dielectric \nliquid like water) and a smaller sphere (perhaps a ball of silicon) \ninside this sphere. In this case, you can use geometrical \ntransformations to move the smaller sphere around  within  the \nlarger sphere, but you may not write a geometrical transformation\nthat displaces the smaller sphere all the way  outside  \nthe larger sphere. If you want to run simulations in which the \nsmaller sphere lies outside the larger sphere, you will need to \nwrite a new  .scuffgeo  file in which that condition \nis satisfied from the start.  (Also, you may not write a geometrical transformation that \ndisplaces the smaller sphere in such a way that its surface\nintersects the surface of the larger sphere -- in that case,\nyour geometry would contain a multi-material junction \nand would require a  .scuffgeo  description in terms of  REGIONS  and  SURFACES  instead of the simpler \ndescription in terms of  OBJECTS \nthat suffices for fully-embedded geometries.)  As another example, suppose you want to compute the Casimir force \nbetween two identical dielectric objects over a range of separations. \nIn this case, you might be tempted to write a  .scuffgeo  \nfile in which the two objects start out lying on top of each other,\nand then displace them using geometrical transformations in the\nactual force computation. However, this won't work: when  scuff-em  first processes the  .scuffgeo  file, it will be confused by the appearance\nof two objects appearing to coexist in the same physical space,\nand the nesting topology will be incorrectly characterized.\nInstead, you will want to start out with a  .scuffgeo \nfile in which the objects are displaced from one another; you can,\nof course, subsequently rotate or displace them further to your\nheart's content using geometrical transformations.", 
            "title": "4. Geometrical transformations may not change the nesting topology"
        }, 
        {
            "location": "/reference/IncidentFields/", 
            "text": "Incident fields in \nscuff-em\n\n\nFor the classical scattering problems solved by\n\nscuff-scatter\n\nor by C++ or python codes using the\n\nscuff-em\n API\n,\nyou will want to specify the incident fields that\nscatter from your geometry.\n\n\nThe default \nscuff-em\n distribution offers three\nbuilt-in types of incident fields:\n\n\n\n\nPlane waves\n\n\nGaussian beams\n\n\nThe fields of \npoint electric or magnetic dipole sources.\n\n\n\n\nIf you only need to run scattering calculations with a single\ntype of incident field, you can just specify that field on\nthe command line, as described in the sections below. If you\nwant to run scattering calculations with multiple types of\nincident field (for example, perhaps at each frequency you\nwant to consider two different plane-wave polarizations,\nor three different point-source locations) you will want\nto write an \n\nincident-field file\n describing an entire \nlist\n\nof incident fields.\n\n\nTable of Contents\n\n\nIncident fields in \nscuff-em\n\n\nBuilt-in types of incident field\n\n\nPlane waves\n\n\nGaussian beams\n\n\nPoint sources\n\n\n\n\n\n\nSpecifying an entire list of incident fields\n\n\nExample of an incident-field file\n\n\n\n\n\n\nUsing incident fields in API programs\n\n\n\n\n\n\nIt is also easy to \ndefine your own custom incident fields\n\nfor use in API programs.\n\n\nBuilt-in types of incident field\n\n\n\n\nPlane waves\n\n\nscuff-scatter\n command-line syntax:\n\n\n--pwDirection nx ny nz\n--pwPolarization Ex Ey Ez \n\n\n\n\nC++ code:\n\n\n  double  nHat[3] = {nx, ny, nz};\n  cdouble E0[3]   = {Ex, Ey, Ez};\n  PlaneWave *PW=new PlaneWave(E0, nHat);\n\n\n\n\nSelects the incident field to be a plane wave, with propagation vector \n\nn\n=\n(nx,ny,nz)\n and \nE\n-field polarization vector \nE\n=\n(Ex,Ey,Ez).\n\n\nMore specifically, the fields of a plane wave are\n\n\n\n\nwhere the components of the vectors \n\\mathbf{\\hat n}\n \nand \n\n\\mathbf{E}_0\n\nare what you specify with the \n--pwDirection\n and \n\n--pwPolarization\n options to \nscuff-scatter\n. (The frequency \n\n\\omega\n is specified elsewhere, for example using \ncommand-line options like \n--omega.\n The\nquantities \n\\epsilon\n and \n\\mu\n are the material properties of\nthe exterior medium at this frequency, which are determined by\nthe material property designation you give the external medium\nin the \n.scuffgeo\n file; the wave impedance of the medium is\n\nZ=\\sqrt{\\mu/\\epsilon}\\approx 377\\,\\Omega\n in vacuum.)\n\n\nThe values specified for \n--pwPolarization\n may be\n\ncomplex numbers.\n\n\nAs an example, the \nscuff-scatter\n command-line options\n\n\n--pwDirection 0 0 1 --pwPolarization 0.7071 0.7071i 0.0\n\n\n\n\nwill specify an incident field consisting of a circularly\npolarized plane wave traveling in the positive \nz\n direction.\n\n\n\n\nGaussian beams\n\n\nscuff-scatter\n command-line syntax:\n\n\n--gbCenter Cx Cy Cz\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbWaist W\n\n\n\n\nC++ code:\n\n\n  double X0[3]={Cx, Cy, Cz};     /* beam center point */\n  double KProp[3]={nx, ny, nz};  /* beam propagation vector */\n  cdouble E0[3]={Ex, Ey, Ez};    /* complex field-strength vector */\n  double W0=W;                   /* beam waist */\n  GaussianBeam *GB=new GaussianBeam(X0, KProp, E0, W0);\n\n\n\n\nSelects the incident field to be a focused Gaussian beam, \ntraveling in the direction defined by the unit vector \n\nn\n=\n(nx,ny,nz)\n, with \nE\n-field polarization \nvector \nE\n=\n(Ex,Ey,Ez)\n, beam center point with cartesian \ncoordinates \nC\n=\n(Cx,Cy,Cz)\n, and beam waist \nW\n.\n\n\nThe values specified for \n--gbPolarization\n may be\n\ncomplex numbers.\n\n\nThe \nscuff-em\n implementation of the\nfield of a Gaussian laser beam was contributed by \nJohannes Feist and follows this paper:\n\n\n\n\nSheppard and Saghafi, \"Electromagnetic Gaussian Beams \nBeyond the Paraxial Approximation,\" \nJournal of the Optical \nSociety of America A\n \n16\n 1381 (1999), \nhttp://dx.doi.org/10.1364/JOSAA.16.001381\n.\n\n\n\n\n\n\nPoint sources\n\n\nscuff-scatter\n command-line syntax:\n\n\n--psStrength Px Py Pz\n--psLocation xx yy zz\n\n\n\n\nC++ code:\n\n\n  double  X0[3] = {xx, yy, zz};\n  cdouble P0[3] = {Px, Py, Pz};\n  PointSource *PS=new PointSource(X0, P0);\n\n\n\n\nSelects the incident field to be the field of a pointlike\nelectric dipole radiator with dipole moment \nP\n=\n(Px,Py,Pz)\n\nand located at cartesian coordinates (\nxx,yy,zz\n).\n\n\nMore specifically, the fields of a point source are given by\n\n\n\n\nThe values specified for \n--psStrength\n may be\n\ncomplex numbers.\n\n\nYou may define the incident field to be a superposition of\nthe fields of multiple point sources by specifying these\noptions more than once. (The \nn\nth occurrence of \n--psStrength\n\nwill be paired with the \nn\nth occurrence of \n--psLocation.\n)\n\n\nIn API codes (but not in \nscuff-scatter\n) it is also\npossible to a define a magnetic point source as follows:\n\n\n  PointSource *PS=new PointSource(X0, P0);\n\n\n\n\n\n\nSpecifying an entire list of incident fields\n\n\nA feature of the \n\nsurface-integral-equation solver implemented by \nscuff-em\n\nis that, once the computational work needed to solve a single\nscattering problem (for a given geometry at given frequency irradiated\nby a single incident field) has been done, there is relatively little\ncomputational cost required to solve additional problems (for the same \ngeometry at the same frequency) with different incident fields.\nTo exploit this feature, you may write an \"incident-field file\"\n(a simple text file) describing multiple types of incident field \nwith which to irradiate your geometry.\n\n\nExample of an incident-field file\n\n\nHere's an example\n of an incident-field file describing 9 \ndifferent incident fields. If you specify this file\nusing the \n--IFFile\n command-line option to\n\nscuff-scatter\n,\nthen every calculation you request (scattered fields,\npower/force/torque, visualization, etc.) will be \ndone 7 times at each frequency, once for each field.\n\n\nEX    PW    0  0  1       1          0          0\nEY    PW    0  0  1       0          1          0\nLC    PW    0  0  1       0.7071     0.7071i    0\nRC    PW    0  0  1       0.7071    -0.7071i    0\n\nPS1   PS    1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\nPS2   MPS   1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\n\nGB    GB    0.0 0.0 0.0   0.0 0.0 1.0    1.0 0.0 0.0    0.5\n\nCOMPOUND1\n  PW    0   0  1      1        0        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND\n\nCOMPOUND2\n  PW    0   0  1      0        1        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND\n\n\n\n\nHere's how to understand the 9 incident fields described\nby this file.\n\n\n\n\n\n\nThe first several lines define various types of incident\nfields in which there is only a single field source. For \nthis type of incident field, the first word on the \nline is an \narbitrary user-specified label (such as \nEX\n or \nPS1\n)\nthat will be used to identify data corresponding to \nthis incident field in output files.\nThe second word on the line is one of the four \nkeywords \nPW|PS|MPS|GB\n. The remainder of the line\nconsists of numerical parameters:\n\n\n\n\n\n\nFor \nplane waves\n (keyword \nPW\n) there are 6 numerical parameters: \nnx ny nz Ex Ey Ez\n. In the example above, \nEX\n and \nEY\n are linearly-polarized plane waves, while \nLC\n and \nRC\n are left- and right-circularly polarized waves.\n\n\n\n\n\n\nFor \nelectric-dipole point sources\n (keyword \nPS\n) there are 6 numerical parameters: \nxx yy zz Px Py Pz\n.\n\n\n\n\n\n\nFor \nmagnetic-dipole point sources\n (keyword \nMPS\n) there are 6 numerical parameters: \nxx yy zz Mx My Mz\n.\n\n\n\n\n\n\nFor \ngaussian beams\n (keyword \nGB\n) there are 10 numerical parameters: \nCx Cy Cz nx ny nz Ex Ey Ez W\n.    \n\n\n\n\n\n\n\n\n\n\nThe final two sections of the file describe \ncompound\n fields---that is,\nincident fields produced by more than one source acting simultaneously.\nThese types of fields are described by putting their label (here\n\nCOMPOUND1\n or \nCOMPOUND2\n) on line by itself, then specifying\nas many \nPW|PS|MPS|GB\n lines as you like, and finally closing \nthe compound-field definition with the \nEND\n keyword.\nFor example, the field we labeled \nCOMPOUND1\n consists of a\nplanewave acting simultaneously with the field of a point source.\n\n\n\n\n\n\n\n\nUsing incident fields in API programs\n\n\nPlease see \n\nhere\n\nfor further details and examples of how incident fields are manipulated in API codes, including an example of how to create your\nown custom-designed incident field.", 
            "title": "Incident fields"
        }, 
        {
            "location": "/reference/IncidentFields/#built-in-types-of-incident-field", 
            "text": "", 
            "title": "Built-in types of incident field"
        }, 
        {
            "location": "/reference/IncidentFields/#plane-waves", 
            "text": "scuff-scatter  command-line syntax:  --pwDirection nx ny nz\n--pwPolarization Ex Ey Ez   C++ code:    double  nHat[3] = {nx, ny, nz};\n  cdouble E0[3]   = {Ex, Ey, Ez};\n  PlaneWave *PW=new PlaneWave(E0, nHat);  Selects the incident field to be a plane wave, with propagation vector  n = (nx,ny,nz)  and  E -field polarization vector  E = (Ex,Ey,Ez).  More specifically, the fields of a plane wave are   where the components of the vectors  \\mathbf{\\hat n}  \nand  \\mathbf{E}_0 \nare what you specify with the  --pwDirection  and  --pwPolarization  options to  scuff-scatter . (The frequency  \\omega  is specified elsewhere, for example using \ncommand-line options like  --omega.  The\nquantities  \\epsilon  and  \\mu  are the material properties of\nthe exterior medium at this frequency, which are determined by\nthe material property designation you give the external medium\nin the  .scuffgeo  file; the wave impedance of the medium is Z=\\sqrt{\\mu/\\epsilon}\\approx 377\\,\\Omega  in vacuum.)  The values specified for  --pwPolarization  may be complex numbers.  As an example, the  scuff-scatter  command-line options  --pwDirection 0 0 1 --pwPolarization 0.7071 0.7071i 0.0  will specify an incident field consisting of a circularly\npolarized plane wave traveling in the positive  z  direction.", 
            "title": "Plane waves"
        }, 
        {
            "location": "/reference/IncidentFields/#gaussian-beams", 
            "text": "scuff-scatter  command-line syntax:  --gbCenter Cx Cy Cz\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbWaist W  C++ code:    double X0[3]={Cx, Cy, Cz};     /* beam center point */\n  double KProp[3]={nx, ny, nz};  /* beam propagation vector */\n  cdouble E0[3]={Ex, Ey, Ez};    /* complex field-strength vector */\n  double W0=W;                   /* beam waist */\n  GaussianBeam *GB=new GaussianBeam(X0, KProp, E0, W0);  Selects the incident field to be a focused Gaussian beam, \ntraveling in the direction defined by the unit vector  n = (nx,ny,nz) , with  E -field polarization \nvector  E = (Ex,Ey,Ez) , beam center point with cartesian \ncoordinates  C = (Cx,Cy,Cz) , and beam waist  W .  The values specified for  --gbPolarization  may be complex numbers.  The  scuff-em  implementation of the\nfield of a Gaussian laser beam was contributed by \nJohannes Feist and follows this paper:   Sheppard and Saghafi, \"Electromagnetic Gaussian Beams \nBeyond the Paraxial Approximation,\"  Journal of the Optical \nSociety of America A   16  1381 (1999),  http://dx.doi.org/10.1364/JOSAA.16.001381 .", 
            "title": "Gaussian beams"
        }, 
        {
            "location": "/reference/IncidentFields/#point-sources", 
            "text": "scuff-scatter  command-line syntax:  --psStrength Px Py Pz\n--psLocation xx yy zz  C++ code:    double  X0[3] = {xx, yy, zz};\n  cdouble P0[3] = {Px, Py, Pz};\n  PointSource *PS=new PointSource(X0, P0);  Selects the incident field to be the field of a pointlike\nelectric dipole radiator with dipole moment  P = (Px,Py,Pz) \nand located at cartesian coordinates ( xx,yy,zz ).  More specifically, the fields of a point source are given by   The values specified for  --psStrength  may be complex numbers.  You may define the incident field to be a superposition of\nthe fields of multiple point sources by specifying these\noptions more than once. (The  n th occurrence of  --psStrength \nwill be paired with the  n th occurrence of  --psLocation. )  In API codes (but not in  scuff-scatter ) it is also\npossible to a define a magnetic point source as follows:    PointSource *PS=new PointSource(X0, P0);", 
            "title": "Point sources"
        }, 
        {
            "location": "/reference/IncidentFields/#specifying-an-entire-list-of-incident-fields", 
            "text": "A feature of the  surface-integral-equation solver implemented by  scuff-em \nis that, once the computational work needed to solve a single\nscattering problem (for a given geometry at given frequency irradiated\nby a single incident field) has been done, there is relatively little\ncomputational cost required to solve additional problems (for the same \ngeometry at the same frequency) with different incident fields.\nTo exploit this feature, you may write an \"incident-field file\"\n(a simple text file) describing multiple types of incident field \nwith which to irradiate your geometry.", 
            "title": "Specifying an entire list of incident fields"
        }, 
        {
            "location": "/reference/IncidentFields/#example-of-an-incident-field-file", 
            "text": "Here's an example  of an incident-field file describing 9 \ndifferent incident fields. If you specify this file\nusing the  --IFFile  command-line option to scuff-scatter ,\nthen every calculation you request (scattered fields,\npower/force/torque, visualization, etc.) will be \ndone 7 times at each frequency, once for each field.  EX    PW    0  0  1       1          0          0\nEY    PW    0  0  1       0          1          0\nLC    PW    0  0  1       0.7071     0.7071i    0\nRC    PW    0  0  1       0.7071    -0.7071i    0\n\nPS1   PS    1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\nPS2   MPS   1.1 2.2 3.3   0.4+0.5i   0.7        -0.8\n\nGB    GB    0.0 0.0 0.0   0.0 0.0 1.0    1.0 0.0 0.0    0.5\n\nCOMPOUND1\n  PW    0   0  1      1        0        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND\n\nCOMPOUND2\n  PW    0   0  1      0        1        0\n  PS    1.1 2.2 3.3   0.4+0.5i 0.7      -0.8\nEND  Here's how to understand the 9 incident fields described\nby this file.    The first several lines define various types of incident\nfields in which there is only a single field source. For \nthis type of incident field, the first word on the \nline is an \narbitrary user-specified label (such as  EX  or  PS1 )\nthat will be used to identify data corresponding to \nthis incident field in output files.\nThe second word on the line is one of the four \nkeywords  PW|PS|MPS|GB . The remainder of the line\nconsists of numerical parameters:    For  plane waves  (keyword  PW ) there are 6 numerical parameters:  nx ny nz Ex Ey Ez . In the example above,  EX  and  EY  are linearly-polarized plane waves, while  LC  and  RC  are left- and right-circularly polarized waves.    For  electric-dipole point sources  (keyword  PS ) there are 6 numerical parameters:  xx yy zz Px Py Pz .    For  magnetic-dipole point sources  (keyword  MPS ) there are 6 numerical parameters:  xx yy zz Mx My Mz .    For  gaussian beams  (keyword  GB ) there are 10 numerical parameters:  Cx Cy Cz nx ny nz Ex Ey Ez W .          The final two sections of the file describe  compound  fields---that is,\nincident fields produced by more than one source acting simultaneously.\nThese types of fields are described by putting their label (here COMPOUND1  or  COMPOUND2 ) on line by itself, then specifying\nas many  PW|PS|MPS|GB  lines as you like, and finally closing \nthe compound-field definition with the  END  keyword.\nFor example, the field we labeled  COMPOUND1  consists of a\nplanewave acting simultaneously with the field of a point source.", 
            "title": "Example of an incident-field file"
        }, 
        {
            "location": "/reference/IncidentFields/#using-incident-fields-in-api-programs", 
            "text": "Please see  here \nfor further details and examples of how incident fields are manipulated in API codes, including an example of how to create your\nown custom-designed incident field.", 
            "title": "Using incident fields in API programs"
        }, 
        {
            "location": "/reference/BrillouinZoneIntegration/", 
            "text": "Brillouin-zone integration in \nscuff-em\n\n\nMany codes in the \nscuff-em\n suite require evaluating\nintegrals over the Brillouin zone (BZ) of a 1D or 2D\nreciprocal lattice, i.e.\n\n\n\n\nQ(\\omega) = \\int_\\text{BZ} \\overline{Q}(\\omega, \\mathbf{k}_\\text{B}) \n \\,d\\mathbf{k}_\\text{B}\n\n\n\n\nwhere we generically use the overlined symbol\n\n\\overline{Q}(\\mathbf{k}_\\text{B})\n to denote\nthe contribution of Bloch vector \n\\mathbf{k}_\\text{B}\n\nto quantity \nQ\n. Examples of calculations that require\nBrillouin-zone integrations include\n\n\n\n\n\n\nthe Casimir force per unit imaginary frequency\n\n\\omega=i\\xi\n \non an extended object in\n\nscuff-cas3d\n\n\n\n\n\n\nthe Casimir-Polder potential per unit imaginary frequency\n\n\\omega=i\\xi\n \nexperienced by a polarizable particle near an extended surface\nin \n\nscuff-caspol\n\n\n\n\n\n\nthe local density of states at a given angular frequency\n\n\\omega\n\nat user-specified evaluation points in \n\nscuff-ldos\n.\n\n\n\n\n\n\nIn general, Brillouin-zone integrations are evaluated\nby numerical cubature---that is, as weighted sums of\nintegrand samples:\n\n Q(\\omega) \\approx \\sum w_n \\overline Q(\\omega, \\mathbf{k}_n)\n\nwhere \n\\{w_n, \\mathbf{k}_n\\}\n are the weights and points in\na cubature rule for the Brillouin zone of your reciprocal\nlattice, and where each integrand sample\n\n\\overline Q(\\omega, \\bf k_n)\n is computed by performing a\nsingle \nscuff-em\n calculation at a fixed Bloch\nwavevector. The \nscuff-em\n workflow offers two \noptions for evaluating such cubatures:   \n\n\n\n\nYou can design and implement your own cubature scheme\ninvolving your own custom-chosen weights and points\n\n\\{w_n, \\bf k_n\\}\n. In this case, you will use \nthe \n--byOmegakBloch\n command-line option to instruct\na \nscuff-em\n application code to report values of the\nquantity \n\\overline Q(\\omega, \\bf k_n)\n at each of your points\n(this output will typically be written to file with\nextension \n.byOmegakBloch\n or \n.byXikBloch\n),\nthen compute the weighted sums yourself in e.g.\n\njulia\n.    \n\n\n\n\n\n\n\n\nAlternatively, you can ask \nscuff-em\n to perform the\nBZ integration internally, using one of several\nbuilt-in cubature schemes. In this case the BZ-integrated\nquantities \nQ(\\omega)\n will typically be written to \nan output file with extension \n.byOmega\n or \n.byXi\n.\nYou will \nalso\n get an output file named \n.byOmegakBloch\n\nor \n.byXikBloch\n that reports the Bloch-vector-resolved\nintegrand samples \n\\overline Q(\\omega, \\bf k_n)\n\nchosen internally by the \nscuff-em\n BZ integrator.\n\n\n\n\nCommand-line options for customizing internal BZ integration\n\n\nIf you choose the second option above, you may specify\nvarious command-line options to customize the algorithm\nused by \nscuff-em\n to select the cubature points and\nweights \n\\{w_n, \\mathbf{k}_n\\}\n. The options are \nlisted here and discussed in more detail below.\n\n\n--BZIMethod [CC | TC | Polar | Polar2]\n\n\n\n\nSelects the integration algorithm (see below for details).\n\n\n--BZIOrder NN\n\n\n\n\nSets the order (accuracy parameter) of the integration\nalgorithm to \nNN\n. The allowed values of \nNN\n here depend\non the integration algorithm you chose (see below).\n\n\n--BZIRelTol xx\n--BZIAbsTol xx\n--BZIMaxEvals NN\n\n\n\n\nFor adaptive integration algorithms in which the \norder is determined internally (see below), these \noptions allow you to specify relative and absolute\nerror tolerances and an upper limit on the number of \nintegrand samples that will be used.\n\n\n--BZSymmetryFactor [2|4|8]\n\n\n\n\nThis option lets you tell \nscuff-em\n that your\nintegrand function \n\\overline Q(\\mathbf k_\\text{B})\n\nis invariant under 2, 4, or 8-fold rotational \nsymmetry transformations applied to \n\\mathbf k_\\text{B}\n. \nSee below for more details on what this means.\n\n\nUnderstanding the internal BZ integration algorithms\n\n\nTo help you understand how to configure the various\ncommand-line options above, this section\ndescribes the various integration algorithms available\nand how they are affected by the command-line parameters.\n\n\nIntegration methods for 1D Brillouin zones\n\n\nFor one-dimensional Brillouin zones, there is only one\nBZ integration method available---namely,\n\nClenshaw-Curtis quadrature\n\n(\n--BZIMethod CC\n, the default)\nwith the number of integrand samples either fixed\nor chosen adaptively until user-specified error tolerances\nare achieved.\n\n\nMore specifically, you may say either\n\n\n\n\n--BZIOrder [11 | 13 | 15 | ... | 97 | 99]\n\n\n\n\nor \n\n\n\n\n--BZIOrder 0\n\n\n\n\nThe former option selects fixed-order CC cubature\nwith 11, 13, ... 99 sample points. (This number must \nbe an odd integer between 11 and 99 inclusive.)\n\n\nThe latter option selects adaptive\nCC cubature\nusing \nthis algorithm\n.\nIn this case the number of sample points will be chosen\nautomatically subject to the values you select for the\n\n--BZIRelTol\n, \n--BZIAbsTol\n, and \n--BZIMaxEvals\n\ncommand-line options.\n\n\nSymmetry factors for 1D Brillouin zones\n\n\nFor 1D Brillouin zones, the only allowed \nvalue of the \n--BZSymmetryFactor\n option is \n2\n,\nindicating that your integrand is symmetric under\nsign flip of the Bloch wavevector, i.e.\n\n\\overline Q(k_x) = \\overline Q(-k_x)\n.\nIn this case the BZ integration may be restricted to \nthe range \n0\\le k_x \\le \\frac{\\pi}{L_x}.\n\n\n\n\nIntegration methods for 2D Brillouin zones\n\n\nThe following integration methods are implemented for \n2D Brillouin zones. (See below for pictures of where\nthe various methods place their sample points.)\n\n\n\n\n\n\nClenshaw-Curtis cubature\n (\n--BZIMethod CC\n)\n\n\nNested 2D fixed-order or adaptive Clenshaw-Curtis cubature.\n\n\nFor fixed-order nested CC cubature with \nNN\n sample points\nper dimension, say \n--BZIOrder NN\n. Here \nNN\n must be \nan odd integer between 11 and 99 inclusive.\n\n\nFor adaptive 2D CC cubature (subject to your specified values\nof \n--BZIRelTol\n, \n--BZIAbsTol\n, and \n--BZIMaxEvals\n)\nsay \n--BZIOrder 0.\n    \n\n\n\n\n\n\n\n\n\n\n\n\nTriangle cubature\n (\n--BZIMethod TC\n)\n\n\nThis algorithm divides the Brillouin zone into 8\ntriangles and applies a fixed-order triangle cubature scheme\nto each triangle, omitting repetition of triangles\nthat are symmetry-equivalent given the value you specified\nfor \n--BZSymmetryFactor\n (see pictures below).\n\n\nFor this algorithm, the allowed values of\n\n--BZIOrder\n are 1, 2, 4, 5, 7, 9, 13, 14, 16, 20, or 25.\n\n\n\n\n\n\n\n\n\n\n\n\nPolar cubature\n (\n--BZIMethod Polar\n)\n\n\nThis algorithm uses a polar decomposition\n\n(k_x,k_y) \\to (k_\\rho, k_\\theta)\n to\nevaluate the BZ integral as two nested 1D integrals,\none over \nk_\\rho\n and the second over \nk_\\theta\n.\n(The \nk_\\rho\n integral is evaluated via\n Clenshaw-Curtis quadrature, and the \nk_\\theta\n \n quadrature is evaluated using rectangular-rule quadrature,\n not necessarily of the same order).\n\n\nThis algorithm is useful for integrands that are strongly \npeaked near the origin of the Brillouin zone and highly\nattenuated near the boundaries, so that most of the integral\ncomes from the region near the origin.\n\n\nFor this algorithm, the number of integration points\nused for the \nk_\\rho\n and \nk_\\theta\n integrals (call these\nnumbers \nN_\\rho\n and \nN_\\theta\n) are encoded \ninto the value passed to \n--BZIOrder\n\nin the form \n100\\times N_\\rho + N_\\theta,\n\nwhere \nN_\\rho\n and \nN_\\theta\n are each odd integers \nbetween 11 and 99 inclusive.\n\n\nThus, for example, \n--BZIOrder 3321\n specifies that the\n\nk_\\rho\n integral is to be evaluated via 33-point CC\ncubature, while the \nk_\\theta\n integral is to be evaluated\nvia 21-point rectangular-rule cubature.\n\n\n\n\n\n\n\n\n\n\n\n\n Polar cubature with change of variables\n     \nk_\\rho \\to k_z\n \n (\n--BZIMethod Polar2\n)\n\n\nThis is the same as \n--BZIMethod Polar\n, but with\ntwo modifications: \n(a)\n The \nk_\\rho\n integral \nis split into two separate integrals covering the\nranges \nk_\\rho < k_0\n and \nk_\\rho >k_0\n \n(where \nk_0\\equiv \\frac{\\omega}{c}\n is the vacuum photon\nwavenumber at the frequency in question).\n\n(b)\n In each of the two \nk_\\rho\n integrals we\nmake the change of variables\n\n k_\\rho \\to k_z\\equiv \\sqrt{|k_0^2 - k_\\rho^2|}.\n\n\n\n\nThese modifications are useful\nfor cases in which the free-space wavevector \nk_0\n\nfalls within the Brillouin zone. In these cases,\nthe convergence of the \nk_\\rho\n integral is\ndegraded by the phenomena known as \"Wood anomalies\"\nin optics or \"van Hove singularities\" in solid-state\nphysics, and changing variables to \nk_z\n introduces\na Jacobian factor that neutralizes these singularities\nto yield a better-behaved integrand.    \n\n\n\n\n\n\n Special \nN_\\theta\n values for rotationally-invariant integrands \n\n\nAs discussed above, for the \nPolar\n and \nPolar2\n integration methods\nthe value of the \n--BZIOrder\n option is interpreted as the composite \nquantity \n100\\times N_\\rho + N_\\theta\n,\nwhere \nN_\\rho\n and \nN_\\theta\n are odd integers in the range \n[11,99]\n\nspecifying the number of cubature points used for the \nk_\\rho\n and \n\nk_\\theta\n integrals (or set to 0 to request adaptive quadrature).\n\n\nFor \nfully\n rotationally-symmetric geometries in which the BZ integrand\n\n\\overline{Q}\n is independent of \nk_\\theta\n, you can specify\n\nN_\\theta=\\{2,4,6\\}\n to indicate that the \nk_\\theta\n integral\nis to be evaluated by a 1-point cubature with the single \nk_\\theta\n\nsample taken at \nk_\\theta=\\{0,\\frac{\\pi}{2},\\frac{\\pi}{4}\\}\n.\n\n\n(Of course, no geometry discretized into triangles can actually\nbe fully rotationally invariant, but pretending so may be a\nreasonable approximation in some cases, such as \nthis one\n.)\n\n\nSymmetry factors for 2D Brillouin zones\n\n\nFor 2D geometries, the option \n--BZSymmetryFactor\n may\ntake the value 2, 4, or 8, specifying that the Brillouin-zone\nintegrand \n\\overline{Q}(k_x, k_y)\n obeys symmetries as follows:\n\n\n\n\n\n\n--BZSymmetryFactor 2\n: \n\n\nWe have\n\n\\overline{Q}(k_x,k_y) = \\overline{Q}(k_x,-k_y),\n so the BZ integration\nmay be restricted to just the right half of the BZ.\n\n\n\n\n\n\n\n\n\n\n\n\n--BZSymmetryFactor 4\n:\n\n\nWe have\n\n\\overline{Q}(k_x,k_y) = \\overline{Q}(\\pm k_x, \\pm k_y),\n \nso the BZ integration\nmay be restricted to just the upper-right quadrant of the BZ.\n\n\n\n\n\n\n\n\n\n\n--BZSymmetryFactor 8\n: \n    In addition to symmetry under sign changes, the integrand\n    is symmetric under \nk_x\\leftrightarrow k_y\n,\n    so the BZ integration\n    may be restricted to the triangular region\n    \n0\\le k_y \\le k_x \\le \\frac{\\pi}{L_x}.\n\n    (This is only possible for square lattices.)\n\n\n\n\nLocations of quadrature points for 2D Brillouin zones\n\n\nHere are some diagrams indicating the Bloch wavevectors\nthat will be sampled by the internal algorithms for Brillouin-zone\nintegration with various values of the command-line parameters:\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 2\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 4\n\n\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  21    --BZSymmetryFactor 8\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 2\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 4\n\n\n\n\n\n\n\n\n--BZIMethod TC    --BZIOrder  20    --BZSymmetryFactor 8\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 2\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 4\n\n\n\n\n\n\n\n\n--BZIMethod Polar --BZIOrder 3111 --BZSymmetryFactor 8\n\n\n\n\n\n\n\n\nNote:\n The next four diagrams are for a frequency of\n\n\\frac{\\omega}{c}\\approx 0.32\\cdot \\frac{2\\pi}{L}\n. The accumulation\nof points near \n|\\mathbf{k}_\\text{B}|=\\frac{\\omega}{c}\n\nis noticeable for the \nPolar2\n integration strategy.\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 1\n\n\n\n\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 2\n\n\n\n\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 4\n\n\n\n\n\n\n--BZIMethod Polar2 --BZIOrder 1111 --BZSymmetryFactor 8\n\n\n\n\n\n\nLocations of quadrature points for 1D Brillouin zones\n\n\n--BZIMethod CC    --BZIOrder  31    --BZSymmetryFactor 1\n\n\n\n\n\n\n\n\n--BZIMethod CC    --BZIOrder  31    --BZSymmetryFactor 2", 
            "title": "Brillouin zone integration"
        }, 
        {
            "location": "/reference/FAQ/", 
            "text": "Frequently asked questions about \nscuff-em\n\n\n\n\nWhat units does \nscuff-em\n use for physical quantities like length, frequency, field strengths, power, force, torque, etc?\n\n\nLength and frequency\n\n\nShort answer: The default units are \nL_0=1\\, \\mu\\text{m}\n for length\nand \n\\omega_0=3\\cdot 10^{14}\n rad/sec (=\nc/L_0)\n for angular frequency.\n\n\nThus, if you write a \n\ngmsh\n\ngeometry (\n.geo\n) file describing a sphere\nof radius \n1.3\n and use the resulting surface mesh in a\n\nscuff-scatter\n calculation\nwith an angular-frequency specification of \n--omega 2.0\n,\nthen you will be studying a sphere of radius 1.3 microns\nat an angular frequency of \n6\\cdot 10^{14}\n rad/sec \n(corresponding to a free-space wavelength of \n\n\\lambda=\\frac{2\\pi c}{\\omega} = 3.1415\\,\\mu\nm,\nwhich could alternatively be specified by saying\n\n--lambda 3.1415\n instead of \n--omega 2.0\n).\n[The dimensionless quantity \na=\\frac{\\omega R}{c}\n\n (the \"size parameter\" in Mie theory) \n  is just the product of the numerical values specified\n  for the radius and \n--omega\n, i.e. \na=1.3 \\cdot 2.0=2.6\n\n  in this case.]\n\n\nLonger answer: \nFor a problem involving only bodies with\n\nfrequency-independent material properties\n\n(permeability \n\\epsilon\n and permittivity \n\\mu\n),\nincluding perfectly-conducting (\nPEC\n) bodies and\nfrequency-independent dielectrics\n(such as \nCONST_EPS_10+1i\n), the scale invariance\nof Maxwell's equations means that the same\ncomputational results can be interpreted on different\nlength scales. For example, if your mesh file\ndescribes a sphere of radius \n0.9' and you run\na [[scuff-em]] calculation at angular frequency\n1.2`, \nthen the results can be equally well interpreted as describing\n\n\n\n\n\n\na sphere of radius 0.9 \n\\mu\nm at an angular frequency of\n\n1.2 \\cdot 3\\cdot 10^{14}\n rad/sec, or\n\n\n\n\n\n\na sphere of radius 0.9 mm at an angular frequency of\n\n1.2 \\cdot 3\\cdot 10^{11}\n rad/sec, or\n\n\n\n\n\n\na sphere of radius 0.9 nm at an angular frequency of\n\n1.2 \\cdot 3\\cdot 10^{17}\n rad/sec, etc. (Of course,\nthe continuum\n\n\n\n\n\n\nHowever, this scale invariance is broken by\nfrequency-dependent dielectric functions \n(or frequency-dependent permeabilities) such\nas the \nSILICON\n material definition in\n\nthis example\n. The convention\nadopted by \nscuff-em\n is that\n\n\\omega\n values in frequency-dependent material\ndefinitions are always interpreted in units of radians/second\n,\n\nnot\n specialized units like \n3 \\cdot 10^{14} rad/sec\n.\nThus, if your calculation involves a frequency-dependent \nmaterial function (either a [user-defined function][UserDefined] or\na [datafile][Tabulated]),\nthen \nscuff-em\n will eventually need to convert the numerical\nvalues you specify for \n--Omega\n inputs into absolute\nangular frequencies. For this purpose, \nscuff-em\n generally\nmakes the scale-breaking assumption that numerical \n--Omega\n values\nare given in units of \n\\omega_0=3\\cdot 10^{14}\n rad/sec,\ncorresponding to the default length scale of \nL_0=1\\,\\mu\nm.\n(The one exception to this rule is\n[\nscuff-rf\n][scuff-rf], which uses\nlength and frequency units more appropriate for RF modeling;\nthis is discussed in the \n[\nscuff-rf\n documentation][scuff-rf].)\n\n\nElectric and magnetic field strengths\n\n\nThe only code in the \nscuff-em\n suite that directly outputs\nnumerical values of electric and magnetic field components is\n\nscuff-scatter\n. For this\ncode, there is always a user-specified incident field with\na user-specified numerical field-strength parameter, and the\nunits of electric-field components reported by \nscuff-scatter\n\nare understood simply to be the same as the units of the incident-field\nspecifications.\nThe units of magnetic-field components are the units of electric-field\ncomponents divided by ohms (volts/amperes); thus, if \nE\n-field \ncomponents have units of volts/micron then \nH\n-field components\nhave units of amps/micron.\n\n\nThus, to run a \nscuff-scatter\n calculation to model the\nscattering of an incident plane wave of amplitude 1 volt/micron,\nuse the command-line option \n--pwPolarization 0 0 1\n\nand interpret the numbers reported for \nE\n-field (\nH\n-field)\ncomponents in units of volts/micron (amps/micron).\nAlternatively, to describe the scattering of a plane wave of \namplitude 1 volt/meter, use the same command-line options,\nbut now interprety the output numbers in units of \nvolts/meter (amps/meter).\n\n\nPower, force, torque\n\n\nThe units in which numerical values of power, force, and torque are\nreported differ slightly for different codes in the \nscuff-em\n suite:\n\n\n\n\n\n\nFor \nscuff-scatter\n,\nand torque in\n\n\n\n\n\n\nFor \nscuff-cas3D\n,\n\n\n\n\n\n\nequilibrium Casimir energies are reported in units of \n  \n\\hbar c/1\\,\\mu\\text{m}\n=0.1973 eV = 3.16\\cdot 10^{-20}$ joules,\n\n\n\n\n\n\nequilibrium Casimir forces are reported in units of \n  \n\\hbar c/(1\\,\\mu\\text{m})^2\n=31.6 femtoNewtons\n\n\n\n\n\n\nequilibrium Casimir torques are reported in units of\n  \n\\hbar c/(1\\,\\mu\\text{m})\n=31.6 femtoNewtons\n microns.\n\n\n\n\n\n\n\n\n\n\nscuff-neq\n reports power in watts,\nforce in nanoNewtons, torque in nanoNewtons\nmicrons.\n(More specifically, what \nscuff-neq\n actually reports are\n\nfluxes\n of energy and momentum; these are quantities\nthat need to be multiplied by energy prefactors and integrated\nover angular frequencies to yield heat-transfer rates, forces, and torques;\nthis is discussed in more detail in the \n\nscuff-neq\n documentation.\n\n\n\n\n\n\nI'm working on a big project involving multiple calculations on a geometry with various different values of geometric parameters, material properties, and meshing fineness. It's getting unwieldy to have all of these \n.geo\n and \n.msh\n and \n.scuffgeo\n files cluttering up my project directory. How would you suggest organizing things?\n\n\nHere is what I typically do:\n\n\n\n\n\n\nWithin your top-level project directory (I'll call it\n      \n~/myProject/\n), create the following subdirectories:\n\n\n\n\n~/myProject/geoFiles\n (for \ngmsh\n geometry files)\n\n\n~/myProject/mshFiles\n (for surface mesh files)\n\n\n~/myProject/scuffgeoFiles\n (for \nscuff-em\n geometry files\n).\n\n\n\n\n\n\n\n\nBefore running any \nscuff-em\n calculations, set the\n    environment variable \nSCUFF_MESH_PATH\n to the directory\n    you created for mesh files:\n\n\n\n\n\n\n% export SCUFF_MESH_PATH=~/myProject/mshFiles\n\n\n\n\n(Or just include this line in any scripts you write to launch jobs; see below).\n\n\n\n\n\n\nFrom the top-level project directory, create subdirectories for\n    each separate run you plan to do. For example, to do separate\n    runs for PEC and real gold, with coarse and fine resolutions \n    in both cases, I might create four directories called \n    \nPEC_Coarse\n, \nPEC_Fine\n, \nGold_Coarse\n, and \nGold_Fine.\n\n\n\n\n\n\nAssuming you want to look at the same frequencies, evaluation points,\n    incident fields, geometrical transformations, etc. in each case, \n    put files like \nOmegaFile\n, \nEPFile\n, \nIFFile\n, and \nTransFile\n \n    in the top-level directory (\n~/myProject/\n).\n\n\n\n\n\n\nWithin e.g. the \nPEC_Fine\n subdirectory, create a run script\n    that explicitly specifies the locations in which it expects\n    to find files, something like this:\n\n\n\n\n\n\n#!/bin/bash\n\nexport FILEBASE=${HOME}/myProject\nexport SCUFF_MESH_PATH=${FILEBASE}/mshFiles\nexport SCUFF_GEO_PATH=${FILEBASE}/scuffgeoFiles\n\nARGS=\n\nARGS=\n${ARGS} --geometry  ${SCUFF_GEO_PATH}/PEC_Fine.scuffgeo\n\nARGS=\n${ARGS} --OmegaFile ${FILEBASE}/OmegaFile\n\nARGS=\n${ARGS} --EPFile    ${FILEBASE}/EPFile\n\nARGS=\n${ARGS} --IFFile    ${FILEBASE}/IFFile\n  \n\nscuff-scatter ${ARGS}\n\n\n\n\n\n\n\n\n\nNow you can copy this run script to each new run directory \n    and make only minor changes (i.e. specify different \n.scuffgeo\n)\n    files to launch the new job.\n\n\n\n\n\n\nWhen running multiple jobs simultaneously on a single\n    multi-core workstation, I usually use the environment variables\n    \nOMP_NUM_THREADS\n and \nGOMP_CPU_AFFINITY\n to specify an \n    explicit divvying up of the available CPU cores so that \n    the various jobs don't step on each others' toes. (The\n    OS scheduler should be able to do this automatically, but \n    I haven't had good luck with that.)\n\n\nFor example, suppose I'm on a workstation that has 24 CPU cores,\nand I want to run 3 simultaneous \nscuff-em\n jobs.\nThen in the run scripts for the three jobs I will include\nthe following lines:\n\n\n\n\n\n\n...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY=\n0-7\n\n...\n\n\n\n\nfor the first run script,\n\n\n...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY=\n8-15\n\n...\n\n\n\n\nfor the second run script, and \n\n\n...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY=\n16-23\n\n...\n\n\n\n\nfor the third run script. Once all three jobs\nare running, you can use \n\nhtop\n\nor similar utilities to double check that each \njob is running on its own set of 8 cores and \nnot interfering with the other jobs.", 
            "title": "FAQ"
        }, 
        {
            "location": "/reference/FAQ/#what-units-does-scuff-em-use-for-physical-quantities-like-length-frequency-field-strengths-power-force-torque-etc", 
            "text": "Length and frequency  Short answer: The default units are  L_0=1\\, \\mu\\text{m}  for length\nand  \\omega_0=3\\cdot 10^{14}  rad/sec (= c/L_0)  for angular frequency.  Thus, if you write a  gmsh \ngeometry ( .geo ) file describing a sphere\nof radius  1.3  and use the resulting surface mesh in a scuff-scatter  calculation\nwith an angular-frequency specification of  --omega 2.0 ,\nthen you will be studying a sphere of radius 1.3 microns\nat an angular frequency of  6\\cdot 10^{14}  rad/sec \n(corresponding to a free-space wavelength of  \\lambda=\\frac{2\\pi c}{\\omega} = 3.1415\\,\\mu m,\nwhich could alternatively be specified by saying --lambda 3.1415  instead of  --omega 2.0 ).\n[The dimensionless quantity  a=\\frac{\\omega R}{c} \n (the \"size parameter\" in Mie theory) \n  is just the product of the numerical values specified\n  for the radius and  --omega , i.e.  a=1.3 \\cdot 2.0=2.6 \n  in this case.]  Longer answer: \nFor a problem involving only bodies with frequency-independent material properties \n(permeability  \\epsilon  and permittivity  \\mu ),\nincluding perfectly-conducting ( PEC ) bodies and\nfrequency-independent dielectrics\n(such as  CONST_EPS_10+1i ), the scale invariance\nof Maxwell's equations means that the same\ncomputational results can be interpreted on different\nlength scales. For example, if your mesh file\ndescribes a sphere of radius  0.9' and you run\na [[scuff-em]] calculation at angular frequency 1.2`, \nthen the results can be equally well interpreted as describing    a sphere of radius 0.9  \\mu m at an angular frequency of 1.2 \\cdot 3\\cdot 10^{14}  rad/sec, or    a sphere of radius 0.9 mm at an angular frequency of 1.2 \\cdot 3\\cdot 10^{11}  rad/sec, or    a sphere of radius 0.9 nm at an angular frequency of 1.2 \\cdot 3\\cdot 10^{17}  rad/sec, etc. (Of course,\nthe continuum    However, this scale invariance is broken by\nfrequency-dependent dielectric functions \n(or frequency-dependent permeabilities) such\nas the  SILICON  material definition in this example . The convention\nadopted by  scuff-em  is that \\omega  values in frequency-dependent material\ndefinitions are always interpreted in units of radians/second , not  specialized units like  3 \\cdot 10^{14} rad/sec .\nThus, if your calculation involves a frequency-dependent \nmaterial function (either a [user-defined function][UserDefined] or\na [datafile][Tabulated]),\nthen  scuff-em  will eventually need to convert the numerical\nvalues you specify for  --Omega  inputs into absolute\nangular frequencies. For this purpose,  scuff-em  generally\nmakes the scale-breaking assumption that numerical  --Omega  values\nare given in units of  \\omega_0=3\\cdot 10^{14}  rad/sec,\ncorresponding to the default length scale of  L_0=1\\,\\mu m.\n(The one exception to this rule is\n[ scuff-rf ][scuff-rf], which uses\nlength and frequency units more appropriate for RF modeling;\nthis is discussed in the \n[ scuff-rf  documentation][scuff-rf].)  Electric and magnetic field strengths  The only code in the  scuff-em  suite that directly outputs\nnumerical values of electric and magnetic field components is scuff-scatter . For this\ncode, there is always a user-specified incident field with\na user-specified numerical field-strength parameter, and the\nunits of electric-field components reported by  scuff-scatter \nare understood simply to be the same as the units of the incident-field\nspecifications.\nThe units of magnetic-field components are the units of electric-field\ncomponents divided by ohms (volts/amperes); thus, if  E -field \ncomponents have units of volts/micron then  H -field components\nhave units of amps/micron.  Thus, to run a  scuff-scatter  calculation to model the\nscattering of an incident plane wave of amplitude 1 volt/micron,\nuse the command-line option  --pwPolarization 0 0 1 \nand interpret the numbers reported for  E -field ( H -field)\ncomponents in units of volts/micron (amps/micron).\nAlternatively, to describe the scattering of a plane wave of \namplitude 1 volt/meter, use the same command-line options,\nbut now interprety the output numbers in units of \nvolts/meter (amps/meter).  Power, force, torque  The units in which numerical values of power, force, and torque are\nreported differ slightly for different codes in the  scuff-em  suite:    For  scuff-scatter ,\nand torque in    For  scuff-cas3D ,    equilibrium Casimir energies are reported in units of \n   \\hbar c/1\\,\\mu\\text{m} =0.1973 eV = 3.16\\cdot 10^{-20}$ joules,    equilibrium Casimir forces are reported in units of \n   \\hbar c/(1\\,\\mu\\text{m})^2 =31.6 femtoNewtons    equilibrium Casimir torques are reported in units of\n   \\hbar c/(1\\,\\mu\\text{m}) =31.6 femtoNewtons  microns.      scuff-neq  reports power in watts,\nforce in nanoNewtons, torque in nanoNewtons microns.\n(More specifically, what  scuff-neq  actually reports are fluxes  of energy and momentum; these are quantities\nthat need to be multiplied by energy prefactors and integrated\nover angular frequencies to yield heat-transfer rates, forces, and torques;\nthis is discussed in more detail in the  scuff-neq  documentation.", 
            "title": "What units does scuff-em use for physical quantities like length, frequency, field strengths, power, force, torque, etc?"
        }, 
        {
            "location": "/reference/FAQ/#im-working-on-a-big-project-involving-multiple-calculations-on-a-geometry-with-various-different-values-of-geometric-parameters-material-properties-and-meshing-fineness-its-getting-unwieldy-to-have-all-of-these-geo-and-msh-and-scuffgeo-files-cluttering-up-my-project-directory-how-would-you-suggest-organizing-things", 
            "text": "Here is what I typically do:    Within your top-level project directory (I'll call it\n       ~/myProject/ ), create the following subdirectories:   ~/myProject/geoFiles  (for  gmsh  geometry files)  ~/myProject/mshFiles  (for surface mesh files)  ~/myProject/scuffgeoFiles  (for  scuff-em  geometry files ).     Before running any  scuff-em  calculations, set the\n    environment variable  SCUFF_MESH_PATH  to the directory\n    you created for mesh files:    % export SCUFF_MESH_PATH=~/myProject/mshFiles  (Or just include this line in any scripts you write to launch jobs; see below).    From the top-level project directory, create subdirectories for\n    each separate run you plan to do. For example, to do separate\n    runs for PEC and real gold, with coarse and fine resolutions \n    in both cases, I might create four directories called \n     PEC_Coarse ,  PEC_Fine ,  Gold_Coarse , and  Gold_Fine.    Assuming you want to look at the same frequencies, evaluation points,\n    incident fields, geometrical transformations, etc. in each case, \n    put files like  OmegaFile ,  EPFile ,  IFFile , and  TransFile  \n    in the top-level directory ( ~/myProject/ ).    Within e.g. the  PEC_Fine  subdirectory, create a run script\n    that explicitly specifies the locations in which it expects\n    to find files, something like this:    #!/bin/bash\n\nexport FILEBASE=${HOME}/myProject\nexport SCUFF_MESH_PATH=${FILEBASE}/mshFiles\nexport SCUFF_GEO_PATH=${FILEBASE}/scuffgeoFiles\n\nARGS= \nARGS= ${ARGS} --geometry  ${SCUFF_GEO_PATH}/PEC_Fine.scuffgeo \nARGS= ${ARGS} --OmegaFile ${FILEBASE}/OmegaFile \nARGS= ${ARGS} --EPFile    ${FILEBASE}/EPFile \nARGS= ${ARGS} --IFFile    ${FILEBASE}/IFFile   \n\nscuff-scatter ${ARGS}    Now you can copy this run script to each new run directory \n    and make only minor changes (i.e. specify different  .scuffgeo )\n    files to launch the new job.    When running multiple jobs simultaneously on a single\n    multi-core workstation, I usually use the environment variables\n     OMP_NUM_THREADS  and  GOMP_CPU_AFFINITY  to specify an \n    explicit divvying up of the available CPU cores so that \n    the various jobs don't step on each others' toes. (The\n    OS scheduler should be able to do this automatically, but \n    I haven't had good luck with that.)  For example, suppose I'm on a workstation that has 24 CPU cores,\nand I want to run 3 simultaneous  scuff-em  jobs.\nThen in the run scripts for the three jobs I will include\nthe following lines:    ...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY= 0-7 \n...  for the first run script,  ...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY= 8-15 \n...  for the second run script, and   ...\nexport OMP_NUM_THREADS=8\nexport GOMP_CPU_AFFINITY= 16-23 \n...  for the third run script. Once all three jobs\nare running, you can use  htop \nor similar utilities to double check that each \njob is running on its own set of 8 cores and \nnot interfering with the other jobs.", 
            "title": "I'm working on a big project involving multiple calculations on a geometry with various different values of geometric parameters, material properties, and meshing fineness. It's getting unwieldy to have all of these .geo and .msh and .scuffgeo files cluttering up my project directory. How would you suggest organizing things?"
        }, 
        {
            "location": "/applications/GeneralReference/", 
            "text": "General reference for \nscuff-em\n command-line applications\n\n\nThis page collects some general information that applies\nto many or all of the standalone command-line applications\nin the \nscuff-em\n suite.\n\n\nTable of Contents\n\n\nGeneral reference for scuff-em command-line applications\n\n\n1. Common command-line arguments\n\n\nOptions specifying geometry inputs\n\n\nOptions specifying individual frequencies and Bloch vectors at which to calculate\n\n\nOptions specifying evaluation points\n\n\nOptions controlling frequency integrations\n\n\nOptions controlling Brillouin-zone integrations\n\n\nMiscellaneous options\n\n\n\n\n\n\n2. Passing command-line options via text file\n\n\n3. Complex numbers\n\n\n4. Log files\n\n\n5. Output Files\n\n\n6. Environment variables\n\n\n\n\n\n\n\n\n1. Common command-line arguments\n\n\nThe various standalone applications in the \nscuff-em\n suite\nshare a number of command-line arguments in common,\nas described below.\nNot all codes accept all arguments (for example, \n\nscuff-transmission\n does not accept \n--TransFile\n), but the \nformat of each arguments is standardized among all codes that \ndo\n \naccept that argument.\n\n\nOptions specifying geometry inputs\n\n\n--geometry MyGeometry.scuffgeo\n\n\n\n\nSpecifies the \n\nscuff-em\n geometry file\n\ndescribing your geometry. This option is always mandatory.\n\n\n\n\n--TransFile MyTransformations.trans\n\n\n\n\nSpecifies an optional file describing one or more\n\ngeometrical transformations\n\nto be applied to your geometry. Omitting the \n--TransFile\n option\n(when running a code that accepts it) is equivalent to specifying\nan empty transformation named \nDEFAULT\n that leaves the geometry\nunchanged from the configuration described by the \n.scuffgeo\n file.\n\n\n\n\nOptions specifying individual frequencies and Bloch vectors at which to calculate\n\n\n--Omega 3.34\n--Omega 4.25+0.9i\n--Lambda 2.3\n--OmegaFile MyOmegaFile\n--LambdaFile MyLambdaFile\n\n\n\n\nSpecifies one or more frequencies at which to perform calculations.\n\n\n--Omega\n specifies the angular frequency in units of \n\n\\omega_0=3\\cdot 10^{14}\n rad/sec. The argument of \n--Omega\n may be a\n\ncomplex number\n.\n\n\nThe alternative option \n--Lambda\n instead specifies the frequency\nin terms of the corresponding free-space wavelength \n\\lambda=c/\\omega\n \n(where \nc\n is the \nvacuum\n speed of light, irrespective of the material\nproperties of your geometry.)\n\n--Lambda\n values are interpreted in units of microns (\n\\mu\nm).\n\n\nThe options \n--OmegaFile\n or \n--LambdaFile\n may be used to specify a \nfile containing one or more \n--Omega\n or \n--Lambda\n values, one \nper line (blank lines and comments are ignored.)\n\n\n\n\n--OmegakBlochFile MyOkBFile\n\n\n\n\nSimilar to \n--OmegaFile\n, but specifies a list of\n(frequency, Bloch vector) points at which to perform calculations.\nThis option only makes sense when used with \n\nextended geometries\n\n\nThe argument specified for \n--OmegakBlochFile\n should\nbe a file containing two numbers on each line (for 1D extended \ngeometries) or three numbers on each line (for 2D extended \ngeometries). (Blank lines and comment lines beginning with \n#\n\nare ignored.) The first number on each line is the \n--Omega\n\nvalue; the next one or two numbers are the components of the \n1D or 2D Bloch wavevector, measured in units of (\n\\mu\nm)\n^{-1}\n.\n\n\n\n\n--Xi 0.39 \n--XiFile MyXiFile\n--XikBlochFile MyXkBFile\n\n\n\n\nSimilar to \n--Omega\n, \n--OmegaFile\n, and \n--OmegakBlochFile,\n \nbut used for codes (\nscuff-cas3d\n and\n\nscuff-caspol\n) that perform calculations\nat pure imaginary frequencies, \n\\omega=i\\xi\n.\nValues specified for \n--Xi\n should be positive real numbers.\n\n\n\n\n\n\nOptions specifying evaluation points\n\n\n--EPFile MyEPFile\n\n\n\n\nFor codes that compute spatially-resolved output quantities,\nthis option specifies a file describing a list of spatial \nevaluation points. (\nWhich\n output quantity depends\non the code you are running; for example,\n\nscuff-scatter\n\nwill report components of the scattered and total fields at the \nevaluation points, while\n\nscuff-neq\n\nwill report values of the thermally-averaged fluxes of\nenergy and momentum at the evaluation points.)\n\n\nThe argument to \n--EPFile\n should be a file containing one or more\nlines, each of which contains three space-separated numbers\n(the Cartesian coordinates of the evaluation point). \nBlank lines and comments (lines beginning with \n#\n) are ignored.\nFor example,\nto ask \nscuff-scatter\n for the scattered field components\nat points on the \nz\n axis, the file might look like this:\n\n\n# evaluation points\n0.0 0.0 -2.0\n0.0 0.0 -1.9\n...\n0.0 0.0  1.9\n0.0 0.0  2.0\n\n\n\n\nOptions controlling frequency integrations\n\n\n--OmegaQuadrature [adaptive | cliff]\n--OmegaMin 0.01\n--XiQuadrature [adaptive | cliff]\n--XiMin 0.01\n--AbsTol\n--RelTol\n\n\n\n\nThese arguments affect the behavior of application codes\nthat compute output quantities by performing numerical\nintegrations over angular frequencies---either real\nangular frequencies \n\\omega\n or imaginary angular\nfrequencies \n\\xi\n. (More specifically, \nscuff-neq\n\nperforms \n\\omega\n integrations, while \nscuff-cas3d\n and\n\nscuff-caspol\n perform \n\\xi\n integrations.)\n\n\n--OmegaQuadrature\n or \n--XiQuadrature\n specify the\nnumerical quadrature algorithm. If these\noptions are left unspecified, an appropriate algorithm \nis chosen automatically.\n\n\n--OmegaMin\n or \n--XiMin\n specify the minimum angular\nfrequency at which numerical \nscuff-em\n calculations \nare performed. For cases in which the lower limit of the \n\n\\omega\n or \n\\xi\n integration is 0, the integrand is \nassumed to be constant between 0 and the value specified here.\nThese options are interpreted in the usual \nscuff-em\n\nfrequency units of \n3\\times 10^{14}\n rad/sec, so typical\nvalues will be something like \n0.001.\n\n\n--AbsTol\n and \n--RelTol\n may be used to specify\nabsolute and relative error tolerances for adaptive\nquadrature algorithms. If an adaptive cubature method\nseems be spending too much time attempting to achieve\nhigh accuracy in a frequency quadrature, try increasing\n\n--RelTol\n to something like \n0.1\n or even \n0.5.\n\n\n\n\nOptions controlling Brillouin-zone integrations\n\n\n--BZQuadrature [adaptive | cliff]\n--BZSymmetry [adaptive | cliff]\n--MaxBZSamples 1000;\n\n\n\n\nThese arguments affect the behavior of application codes\nthat compute output quantities for periodic geometries\nby performing numerical integrations over the Brillouin\nzone. Such codes include \nscuff-ldos\n, \nscuff-neq\n,\n\nscuff-cas3d\n, and \nscuff-caspol\n.\n\n\n--BZSymmetry\n may be used for 2D periodic geometries to\ndeclare that the Brillouin-zone integrand \nf(k_x, k_y)\n\nis symmetric under the interchange \nk_x \\leftrightarrow k_y\n.\n\n\n--MaxBZSamples 1000\n may be used to restrict adaptive\nintegration algorithms to a maximum of 1,000 evaluations\nof the Brillouin-zone integrand.\n\n\n\n\nMiscellaneous options\n\n\n--FileBase MyFileBase\n\n\n\n\nSpecifies the base file name for output files (so that, for example,\nthe frequency-resolved output file written by \nscuff-cas3d\n\nwill be \nMyFileBase.byXi\n, while the frequency-integrated \noutput file will be \nMyFileBase.out\n). If this option is not \nspecified, the file base is taken to be the base filename of the \n\n.scuffgeo\n file.\n\n\n\n\n2. Passing command-line options via text file\n\n\nAll of the standalone applications in the \nscuff-em\n suite allow \ntheir command-line options to be passed via a text file fed into \nstandard input.\n\n\nEach line of this text file should consist of a single \ncommand-line option (minus the -- at the beginning) followed by any \narguments the option might take.\n\n\nFor example, running \nscuff-scatter\n with the command-line options\n\n\n% scuff-scatter --geometry Spheres.scuffgeo --omega 1.0 --pwPolarization 1 0 0 --pwDirection 0 0 1 --EPFile MyEPFile \n\n\n\n\nis equivalent to running\n\n\n% scuff-scatter \n MyOptionsFile\n\n\n\n\nwhere the file \nMyOptionsFile\n looks like this:\n\n\n# options for scuff-scatter \ngeometry Spheres.scuffgeo\nomega 1.0\n\npwPolarization 1 0 0 \npwDirection 0 0 1\n\nEPFile MyEPFile\n\n\n\n\nNote that blank lines and comments (lines starting with #) are ignored.\n\n\nYou may also combine the two methods of specifying options by passing \nsome options via text file and others on the command line. If there are \nany conflicts, the values specified on the command line take precedence. \nFor instance, to re-run the example above at a new frequency with \neverything else unchanged, you could say\n\n\n % scuff-scatter --Omega 2.0 \n MyOptionsFile\n\n\n\n\n\n\n3. Complex numbers\n\n\nMany of the standalone programs in the \nscuff-em\n suite have \noptions for which you may specify complex numbers. (An example \nis the --omega option accepted by \nscuff-scatter\n and other \ncodes, for which you may specify complex or even pure imaginary \nnumbers to do calculations at complex frequencies.)\n\n\nTo specify a complex number as a parameter value, write both the \nreal and imaginary parts together as a single string (no spaces), \nseparated by \n+\n or \n-\n, with the imaginary part terminated by \n\ni\n or \nI\n (you may also use \nj\n or \nJ\n). For example, all \nof the following are valid frequency specifications:\n\n\n --omega 2.3+4.5i\n --omega 2.3\n --omega 4.5j\n --omega 12.3e2+45.4e2I\n\n\n\n\n \n\n\n4. Log files\n\n\nAll command-line codes in the \nscuff-em\n suite\nwrite logging information to text-based logfiles\nwith extension \n.log.\n You can monitor these\nfiles to follow the progress of your calculations.\n\n\nFor example, after launching \n\nthis sample \nscuff-cas3d\n run\n,\ntype the following at a terminal window:\n\n\n% tail -f SiliconSlabs_L2_40.log\n\n\n\n\nThis produces a running list of log messages, something like this:\n\n\n06/15/15::10:13:40: scuff-cas3D running on superhr1\n06/15/15::10:13:40: Added /home/homer/work/scuff-em-sandbox/mshFiles to mesh search path.\n06/15/15::10:13:40: Adding lattice basis vector (2,0).\n06/15/15::10:13:40: Adding lattice basis vector (0,2).\n06/15/15::10:13:40: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.19635,0.19635)\n06/15/15::10:13:49: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.217586,0.172518)\n06/15/15::10:13:51: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.256543,0.106264)\n06/15/15::10:13:52: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.275845,0.0318681) \n\n\n\n\n\n\n5. Output Files\n\n\nThe \nscuff-em\n application codes generally produce\noutput in the form of human-readable text-based\ndata files. The typical naming convention for \nthese files is \nGeometry.Extension\n, where \nGeometry.scuffgeo\n\nis the name of the \nscuff-em\n geometry file \non which the calculation was run, and where \nExtension\n\nis an application-specific file extension that attempts \nto describe the content of the file; for example, \n\nscuff-scatter\n produces files named \nGeometry.PFT\n\nto report the power, force, and torque on bodies \nirradiated by external fields. You can use the \n\n--filebase\n command-line option to \nscuff-em\n\ncodes to select a base filename other than \n\nGeometry.\n\n\nAll text-based data files produced by \nscuff-em\n\ncodes should contain a human-readable \nheader\n at the \ntop of the file explaining how to interpret its content.\nFor example, the first few lines of the \n\n.PFT\n output file produced by \nscuff-scatter\n\nlook like this:\n\n\n# scuff-scatter running on hikari 08/03/15::23:15:45\n# data file columns: \n# 1 omega \n# 2 surface label \n# 3 absorbed power (watts)\n# 4 scattered power (watts)\n# 5 x-force (nanoNewtons)\n# 6 y-force (nanoNewtons)\n# 7 z-force (nanoNewtons)\n# 8 x-torque (nanoNewtons*microns)\n# 9 y-torque (nanoNewtons*microns)\n# 10 z-torque (nanoNewtons*microns)\n0.05 Particle 6.994160e-04 1.562608e-03 -1.120907e-04 7.169210e-03 7.128598e-03 -3.622586e-03 1.005173e-03 9.428114e-02 \n\n\n\n\nIf you encounter a situation in which a \nscuff-em\n\napplication code fails to write an appropriate file\nheader to an output file, please file an issue\non the \n\nscuff-em\n GitHub page\n.\n\n\nOther types of output files produced by \nscuff-em\n\napplication codes include \n.hdf5\n binary data\nfiles and \n.pp\n files containing visualization data\nthat may be viewed in \ngmsh\n.\n\n\n6. Environment variables\n\n\nHere are some environment-variable settings that \naffect the behavior of \nscuff-em\n.\n\n\n% export SCUFF_MESH_PATH=/path/to/msh/files\n\n\n\n\n\n\nSpecifies a directory in which to look for mesh files\n(such as \n.msh\n files produced by \ngmsh\n) \nreferred to by \n.scuffgeo\n files.\n\n\n\n\n% export SCUFF_LOGLEVEL=\nNONE\n\n% export SCUFF_LOGLEVEL=\nTERSE\n\n% export SCUFF_LOGLEVEL=\nVERBOSE\n\n% export SCUFF_LOGLEVEL=\nVERBOSE2\n\n\n\n\n\n\n\nSets the verbosity of messages written to the \n.log\n file.\n\n\n\n\n% export SCUFF_INTERPOLATION_TOLERANCE=1.0e-3\n\n\n\n\n\n\nThis option, which is only relevant for\n\nextended geometries\n,\nset an internal tolerance parameter that controls\nthe accuracy with which BEM matrix elements and\nscattered fields are computed. Its default value\nis \n1.0e-6\n, but this is probably overly stringent,\nand may generally be relaxed to \n1e-3\n or so\nto reduce memory usage and CPU time without \nsignificant accuracy penalties. If your calculation\nis running out of memory or taking too long to run,\ntry setting it to \n1.0e-4\n or \n1.0e-3.\n\nPlease tell us about your experiences \nwith this parameter!\n\n\n(More specifically: \nscuff-em\n uses Ewald summation\nto accelerate the calculation of the periodic Green's\nfunction, but even this accelerated calculation is \nnot fast enough to handle the many millions of \nevaluations needed to assemble the full BEM matrix.\nFor this reason, when assembling the BEM matrix at\na given frequency and Bloch vector, \nscuff-em\n first\nprecomputes Ewald-summed values of the periodic DGF \nat grid points of an interpolation grid, after which\nvalues are obtained by interpolation (bypassing \nEwald summation). The spacing of the grid points is \nchosen automatically to ensure that the maximum relative \nerror between the interpolated and exact values at any \npoint within the grid boundaries is less than \n\nSCUFF_INTERPOLATION_TOLERANCE.\n\n\n\n\n% export OMP_NUM_THREADS=\n8\n\n% export GOMP_CPU_AFFINITY=\n0-7\n\n\n\n\n\n\n\nThese options \nshould not\n be necessary, but \nmay\n be\nneeded to ensure that \nscuff-em\n takes advantage\nof all available CPU cores on your system. The former \noption says that you want to use 8 cores, and the latter \noption says that you want these 8 cores to be the first\n8 available (as opposed to, say, the second set of 8\navailable cores on a 16-core machine).", 
            "title": "General command-line reference"
        }, 
        {
            "location": "/applications/GeneralReference/#1-common-command-line-arguments", 
            "text": "The various standalone applications in the  scuff-em  suite\nshare a number of command-line arguments in common,\nas described below.\nNot all codes accept all arguments (for example,  scuff-transmission  does not accept  --TransFile ), but the \nformat of each arguments is standardized among all codes that  do  \naccept that argument.  Options specifying geometry inputs  --geometry MyGeometry.scuffgeo   Specifies the  scuff-em  geometry file \ndescribing your geometry. This option is always mandatory.   --TransFile MyTransformations.trans   Specifies an optional file describing one or more geometrical transformations \nto be applied to your geometry. Omitting the  --TransFile  option\n(when running a code that accepts it) is equivalent to specifying\nan empty transformation named  DEFAULT  that leaves the geometry\nunchanged from the configuration described by the  .scuffgeo  file.   Options specifying individual frequencies and Bloch vectors at which to calculate  --Omega 3.34\n--Omega 4.25+0.9i\n--Lambda 2.3\n--OmegaFile MyOmegaFile\n--LambdaFile MyLambdaFile   Specifies one or more frequencies at which to perform calculations.  --Omega  specifies the angular frequency in units of  \\omega_0=3\\cdot 10^{14}  rad/sec. The argument of  --Omega  may be a complex number .  The alternative option  --Lambda  instead specifies the frequency\nin terms of the corresponding free-space wavelength  \\lambda=c/\\omega  \n(where  c  is the  vacuum  speed of light, irrespective of the material\nproperties of your geometry.) --Lambda  values are interpreted in units of microns ( \\mu m).  The options  --OmegaFile  or  --LambdaFile  may be used to specify a \nfile containing one or more  --Omega  or  --Lambda  values, one \nper line (blank lines and comments are ignored.)   --OmegakBlochFile MyOkBFile   Similar to  --OmegaFile , but specifies a list of\n(frequency, Bloch vector) points at which to perform calculations.\nThis option only makes sense when used with  extended geometries  The argument specified for  --OmegakBlochFile  should\nbe a file containing two numbers on each line (for 1D extended \ngeometries) or three numbers on each line (for 2D extended \ngeometries). (Blank lines and comment lines beginning with  # \nare ignored.) The first number on each line is the  --Omega \nvalue; the next one or two numbers are the components of the \n1D or 2D Bloch wavevector, measured in units of ( \\mu m) ^{-1} .   --Xi 0.39 \n--XiFile MyXiFile\n--XikBlochFile MyXkBFile   Similar to  --Omega ,  --OmegaFile , and  --OmegakBlochFile,  \nbut used for codes ( scuff-cas3d  and scuff-caspol ) that perform calculations\nat pure imaginary frequencies,  \\omega=i\\xi .\nValues specified for  --Xi  should be positive real numbers.    Options specifying evaluation points  --EPFile MyEPFile   For codes that compute spatially-resolved output quantities,\nthis option specifies a file describing a list of spatial \nevaluation points. ( Which  output quantity depends\non the code you are running; for example, scuff-scatter \nwill report components of the scattered and total fields at the \nevaluation points, while scuff-neq \nwill report values of the thermally-averaged fluxes of\nenergy and momentum at the evaluation points.)  The argument to  --EPFile  should be a file containing one or more\nlines, each of which contains three space-separated numbers\n(the Cartesian coordinates of the evaluation point). \nBlank lines and comments (lines beginning with  # ) are ignored.\nFor example,\nto ask  scuff-scatter  for the scattered field components\nat points on the  z  axis, the file might look like this:  # evaluation points\n0.0 0.0 -2.0\n0.0 0.0 -1.9\n...\n0.0 0.0  1.9\n0.0 0.0  2.0   Options controlling frequency integrations  --OmegaQuadrature [adaptive | cliff]\n--OmegaMin 0.01\n--XiQuadrature [adaptive | cliff]\n--XiMin 0.01\n--AbsTol\n--RelTol   These arguments affect the behavior of application codes\nthat compute output quantities by performing numerical\nintegrations over angular frequencies---either real\nangular frequencies  \\omega  or imaginary angular\nfrequencies  \\xi . (More specifically,  scuff-neq \nperforms  \\omega  integrations, while  scuff-cas3d  and scuff-caspol  perform  \\xi  integrations.)  --OmegaQuadrature  or  --XiQuadrature  specify the\nnumerical quadrature algorithm. If these\noptions are left unspecified, an appropriate algorithm \nis chosen automatically.  --OmegaMin  or  --XiMin  specify the minimum angular\nfrequency at which numerical  scuff-em  calculations \nare performed. For cases in which the lower limit of the  \\omega  or  \\xi  integration is 0, the integrand is \nassumed to be constant between 0 and the value specified here.\nThese options are interpreted in the usual  scuff-em \nfrequency units of  3\\times 10^{14}  rad/sec, so typical\nvalues will be something like  0.001.  --AbsTol  and  --RelTol  may be used to specify\nabsolute and relative error tolerances for adaptive\nquadrature algorithms. If an adaptive cubature method\nseems be spending too much time attempting to achieve\nhigh accuracy in a frequency quadrature, try increasing --RelTol  to something like  0.1  or even  0.5.   Options controlling Brillouin-zone integrations  --BZQuadrature [adaptive | cliff]\n--BZSymmetry [adaptive | cliff]\n--MaxBZSamples 1000;   These arguments affect the behavior of application codes\nthat compute output quantities for periodic geometries\nby performing numerical integrations over the Brillouin\nzone. Such codes include  scuff-ldos ,  scuff-neq , scuff-cas3d , and  scuff-caspol .  --BZSymmetry  may be used for 2D periodic geometries to\ndeclare that the Brillouin-zone integrand  f(k_x, k_y) \nis symmetric under the interchange  k_x \\leftrightarrow k_y .  --MaxBZSamples 1000  may be used to restrict adaptive\nintegration algorithms to a maximum of 1,000 evaluations\nof the Brillouin-zone integrand.   Miscellaneous options  --FileBase MyFileBase   Specifies the base file name for output files (so that, for example,\nthe frequency-resolved output file written by  scuff-cas3d \nwill be  MyFileBase.byXi , while the frequency-integrated \noutput file will be  MyFileBase.out ). If this option is not \nspecified, the file base is taken to be the base filename of the  .scuffgeo  file.", 
            "title": "1. Common command-line arguments"
        }, 
        {
            "location": "/applications/GeneralReference/#2-passing-command-line-options-via-text-file", 
            "text": "All of the standalone applications in the  scuff-em  suite allow \ntheir command-line options to be passed via a text file fed into \nstandard input.  Each line of this text file should consist of a single \ncommand-line option (minus the -- at the beginning) followed by any \narguments the option might take.  For example, running  scuff-scatter  with the command-line options  % scuff-scatter --geometry Spheres.scuffgeo --omega 1.0 --pwPolarization 1 0 0 --pwDirection 0 0 1 --EPFile MyEPFile   is equivalent to running  % scuff-scatter   MyOptionsFile  where the file  MyOptionsFile  looks like this:  # options for scuff-scatter \ngeometry Spheres.scuffgeo\nomega 1.0\n\npwPolarization 1 0 0 \npwDirection 0 0 1\n\nEPFile MyEPFile  Note that blank lines and comments (lines starting with #) are ignored.  You may also combine the two methods of specifying options by passing \nsome options via text file and others on the command line. If there are \nany conflicts, the values specified on the command line take precedence. \nFor instance, to re-run the example above at a new frequency with \neverything else unchanged, you could say   % scuff-scatter --Omega 2.0   MyOptionsFile", 
            "title": "2. Passing command-line options via text file"
        }, 
        {
            "location": "/applications/GeneralReference/#3-complex-numbers", 
            "text": "Many of the standalone programs in the  scuff-em  suite have \noptions for which you may specify complex numbers. (An example \nis the --omega option accepted by  scuff-scatter  and other \ncodes, for which you may specify complex or even pure imaginary \nnumbers to do calculations at complex frequencies.)  To specify a complex number as a parameter value, write both the \nreal and imaginary parts together as a single string (no spaces), \nseparated by  +  or  - , with the imaginary part terminated by  i  or  I  (you may also use  j  or  J ). For example, all \nof the following are valid frequency specifications:   --omega 2.3+4.5i\n --omega 2.3\n --omega 4.5j\n --omega 12.3e2+45.4e2I", 
            "title": "3. Complex numbers"
        }, 
        {
            "location": "/applications/GeneralReference/#4-log-files", 
            "text": "All command-line codes in the  scuff-em  suite\nwrite logging information to text-based logfiles\nwith extension  .log.  You can monitor these\nfiles to follow the progress of your calculations.  For example, after launching  this sample  scuff-cas3d  run ,\ntype the following at a terminal window:  % tail -f SiliconSlabs_L2_40.log  This produces a running list of log messages, something like this:  06/15/15::10:13:40: scuff-cas3D running on superhr1\n06/15/15::10:13:40: Added /home/homer/work/scuff-em-sandbox/mshFiles to mesh search path.\n06/15/15::10:13:40: Adding lattice basis vector (2,0).\n06/15/15::10:13:40: Adding lattice basis vector (0,2).\n06/15/15::10:13:40: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.19635,0.19635)\n06/15/15::10:13:49: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.217586,0.172518)\n06/15/15::10:13:51: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.256543,0.106264)\n06/15/15::10:13:52: Computing Casimir integrand at (Xi,kx,ky)=(0.5,0.275845,0.0318681)", 
            "title": "4. Log files"
        }, 
        {
            "location": "/applications/GeneralReference/#5-output-files", 
            "text": "The  scuff-em  application codes generally produce\noutput in the form of human-readable text-based\ndata files. The typical naming convention for \nthese files is  Geometry.Extension , where  Geometry.scuffgeo \nis the name of the  scuff-em  geometry file \non which the calculation was run, and where  Extension \nis an application-specific file extension that attempts \nto describe the content of the file; for example,  scuff-scatter  produces files named  Geometry.PFT \nto report the power, force, and torque on bodies \nirradiated by external fields. You can use the  --filebase  command-line option to  scuff-em \ncodes to select a base filename other than  Geometry.  All text-based data files produced by  scuff-em \ncodes should contain a human-readable  header  at the \ntop of the file explaining how to interpret its content.\nFor example, the first few lines of the  .PFT  output file produced by  scuff-scatter \nlook like this:  # scuff-scatter running on hikari 08/03/15::23:15:45\n# data file columns: \n# 1 omega \n# 2 surface label \n# 3 absorbed power (watts)\n# 4 scattered power (watts)\n# 5 x-force (nanoNewtons)\n# 6 y-force (nanoNewtons)\n# 7 z-force (nanoNewtons)\n# 8 x-torque (nanoNewtons*microns)\n# 9 y-torque (nanoNewtons*microns)\n# 10 z-torque (nanoNewtons*microns)\n0.05 Particle 6.994160e-04 1.562608e-03 -1.120907e-04 7.169210e-03 7.128598e-03 -3.622586e-03 1.005173e-03 9.428114e-02   If you encounter a situation in which a  scuff-em \napplication code fails to write an appropriate file\nheader to an output file, please file an issue\non the  scuff-em  GitHub page .  Other types of output files produced by  scuff-em \napplication codes include  .hdf5  binary data\nfiles and  .pp  files containing visualization data\nthat may be viewed in  gmsh .", 
            "title": "5. Output Files"
        }, 
        {
            "location": "/applications/GeneralReference/#6-environment-variables", 
            "text": "Here are some environment-variable settings that \naffect the behavior of  scuff-em .  % export SCUFF_MESH_PATH=/path/to/msh/files   Specifies a directory in which to look for mesh files\n(such as  .msh  files produced by  gmsh ) \nreferred to by  .scuffgeo  files.   % export SCUFF_LOGLEVEL= NONE \n% export SCUFF_LOGLEVEL= TERSE \n% export SCUFF_LOGLEVEL= VERBOSE \n% export SCUFF_LOGLEVEL= VERBOSE2    Sets the verbosity of messages written to the  .log  file.   % export SCUFF_INTERPOLATION_TOLERANCE=1.0e-3   This option, which is only relevant for extended geometries ,\nset an internal tolerance parameter that controls\nthe accuracy with which BEM matrix elements and\nscattered fields are computed. Its default value\nis  1.0e-6 , but this is probably overly stringent,\nand may generally be relaxed to  1e-3  or so\nto reduce memory usage and CPU time without \nsignificant accuracy penalties. If your calculation\nis running out of memory or taking too long to run,\ntry setting it to  1.0e-4  or  1.0e-3. \nPlease tell us about your experiences \nwith this parameter!  (More specifically:  scuff-em  uses Ewald summation\nto accelerate the calculation of the periodic Green's\nfunction, but even this accelerated calculation is \nnot fast enough to handle the many millions of \nevaluations needed to assemble the full BEM matrix.\nFor this reason, when assembling the BEM matrix at\na given frequency and Bloch vector,  scuff-em  first\nprecomputes Ewald-summed values of the periodic DGF \nat grid points of an interpolation grid, after which\nvalues are obtained by interpolation (bypassing \nEwald summation). The spacing of the grid points is \nchosen automatically to ensure that the maximum relative \nerror between the interpolated and exact values at any \npoint within the grid boundaries is less than  SCUFF_INTERPOLATION_TOLERANCE.   % export OMP_NUM_THREADS= 8 \n% export GOMP_CPU_AFFINITY= 0-7    These options  should not  be necessary, but  may  be\nneeded to ensure that  scuff-em  takes advantage\nof all available CPU cores on your system. The former \noption says that you want to use 8 cores, and the latter \noption says that you want these 8 cores to be the first\n8 available (as opposed to, say, the second set of 8\navailable cores on a 16-core machine).", 
            "title": "6. Environment variables"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/", 
            "text": "Solving electromagnetic scattering problems with \n     \nscuff-scatter\n\n\n\n\n\nscuff-scatter\n is a tool within the \nscuff-em\n code suite\nfor solving classical scattering problems involving\nuser-specified incident fields impinging on a material\ngeometry.\n\n\nTo run a scattering calculation using \nscuff-scatter\n, you will\n\n\n\n\n\n\nCreate a \nscuff-em\n geometry file\n\ndescribing the shapes and material properties of the scattering objects in your geometry\n\n\n\n\n\n\nChoose the \nincident field\n that will scatter off your objects: a plane wave, a gaussian beam, a point dipole source, or some combination thereof\n\n\n\n\n\n\nRun \nscuff-scatter\n with command-line options specifying the geometry, the frequencies, the incident field, and the type of output you wish to get back.\n\n\n\n\n\n\nThe various output quantities that you can ask \nscuff-scatter\n to generate include the following:\n\n\n\n\n\n\nThe components of the scattered and total electric and magnetic fields at arbitrary user-specified points away from scattering surfaces. (The points may lie inside or outside the scattering objects).\n\n\n\n\n\n\nThe components of the total electric and magnetic fields on the scattering surfaces. (These quantities may alternatively be interpreted as effective surface currents and charges that give rise to the scattered fields.)\n\n\n\n\n\n\nThe electric and magnetic dipole moments induced by the incident field on the scattering objects. (These are obtained from the interpretation of the tangential fields as effective sources that radiate the scattered fields.)\n\n\n\n\n\n\nThe total power scattered by, and the total power absorbed by, the scattering objects from the incident field.\n\n\n\n\n\n\nThe total force and/or torque exerted on the scattering objects by the incident fields (radiation pressure).\n\n\n\n\n\n\nVisualization files plotting the electric and magnetic surface currents, and the associated charge densities, \n  induced by the incident fields on the scattering objects.\n\n\n\n\n\n\nVisualization files plotting field components and Poynting fluxes on arbitrary user-specified surface meshes.\n\n\n\n\n\n\nFor more sophisticated users, \nscuff-scatter\n also offers\nan \nadvanced mode\n of operation that exposes---at the\ncommand-line level---some of the key efficiencies of the\n\nsurface-integral-equation formulation\n\nimplemented by the\n\nscuff-em\n core library\n.\nThis offers significant speedup for certain types of computations,\nat the expense of a slightly more effort required to set\nup your calculation.\n\n\nTable of Contents\n\n\n1. \nscuff-scatter\n command-line options\n\n\nCommon options\n\n\nOptions defining the scattering problem\n\n\nOptions defining the incident field\n\n\nOptions requesting scattered and total fields\n\n\nOptions requesting power, force, and torque data\n\n\n\n\n\n\n2. \nscuff-scatter\n advanced mode\n\n\n3. \nscuff-scatter\n examples\n\n\n\n\n\n\n\n\n1. \nscuff-scatter\n command-line options\n\n\nCommon options\n\n\nscuff-scatter\n recognizes the following subset of the \n\nlist of commonly accepted options to \nscuff-em\n command-line codes\n.\n\n\n--geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache\n\n\n\n\nOptions defining the scattering problem\n\n\n--geometry MyGeometry.scuffgeo\n\n\n\n\nSpecifies the geometry input file.\n\n\n--Omega      3.1415\n--OmegaFile  MyOmegaFile\n--Lambda     0.5\n--LambdaFile MyLambdaFile\n\n\n\n\nSpecifies the angular frequencies at which to\nrun calculations. (Angular frequencies are interpreted\nin units of \nc/1\\,\\mu\\text{m}=3\\cdot 10^{14}\n rad/sec.)\nThe \n--Omega\n option may be used more than once \nto specify multiple frequencies. Alternatively,\nthe \n--OmegaFile\n option may be used to specify the\nname of a file containing a list of frequencies (one per\nline) at which to run calculations.\n\n\nThe options \n--Lambda\n and \n--LambdaFile\n may alternatively\nbe used to define the frequencies at which to run calculations\nin terms of the corresponding free-space wavelength\n\n\\lambda=\\frac{2\\pi}{\\omega}\n, interpreted in units\nof microns. Thus \n--Omega 3.1415\n and \n--Lambda 0.5\n\nare equivalent; both specify an angular frequency\n\n\\omega=\\pi \\cdot 3\\cdot 10^{14}\nrad/sec, \ncorresponding\nto a free-space wavelength of \n\\lambda=0.5\\,\\mu\nm.\n\n\nNote: Even if you use \n--Lambda / --LambdaFile\n\ninstead of \n--Omega / --OmegaFile\n to specify the\ncomputational frequencies, the output files\nwill still report data in terms of the frequency\n(the equivalent \n--Omega\n values), not the \nwavelength. To plot your data versus wavelength\ninstead of frequency, just plot versus the\nquantity \n\\frac{2\\pi}{\\omega}\n.\n\n\nOptions defining the incident field\n\n\nThe options for specifying incident fields in\n\nscuff-em\n are described in detail on the page\n\nIncident fields in \nscuff-em\n;\nhere we just list the\navailable options without commentary.\n\n\n--pwDirection    nx ny nz\n--pwPolarization Ex Ey Ez\n\n\n\n\n--psStrength Px Py Pz\n--psLocation xx yy zz\n\n\n\n\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbCenter Cx Cy Cz\n--gbWaist W\n\n\n\n\n(As in \nscuff-scatter\n, these options may occur multiple times \nto define superpositions of multiple types of incident field.)\n\n\nOptions requesting scattered and total fields\n\n\n --EPFile MyEPFile\n\n\n\n\nSpecifies a list of evaluation points at which to\ncompute and report components of the scattered and total\nfields. This option may be specified more than once to \ndefine multiple sets of field evaluation points. \n\n\nOptions requesting power, force, and torque data\n\n\n --PFTFile     MyGeometry.PFT\n --EMTPFTFile  MyGeometry.EMTPFT\n --OPFTFile    MyGeometry.OPFT\n --DSIPFTFile  MyGeometry.DSIPFT\n\n\n\n\nEach of these options requests that power, force, and torque (PFT)\ndata be written to a file of the specified name. The resulting\nfiles all have the same file format---reporting absorbed and\nscattered power, force (radiation pressure), and torque\nfor all objects in the geometry at all frequencies you\nrequested (see the file header for details)---but differ \nin the algorithm used to compute the force:\n\n\n\n\n\n\nThe \"energy-momentum-transfer\" PFT (EMTPFT) method\ncomputes powers, forces and torques by considering the\nJoule heating of, and Lorentz force on, the\nsurface currents in the presence of the total \nfields. (This is the default, so the \n--PFTFile\n \noption is synonymous with \n--EMTPFTFile\n.)\n\n\n\n\n\n\nThe \"displaced-surface-integral\" PFT (DSIPFT) method\ncomputes PFTs by integrating the Poynting vector\nand Maxwell stress tensor over a bounding surface \nsurrounding the body.\n\n\n\n\n\n\nThe \"overlap\" PFT (OPFT) method computes PFTs\ndirectly from the surface currents by exploiting\nthe relationship between the surface currents\nand the total electric and magnetic fields at \nbody surfaces.\n\n\n\n\n\n\n\n\n2. \nscuff-scatter\n advanced mode\n\n\nFor some types of calculation it is possible to achieve\nsignificant computational accelerations by taking advantage\nof certain efficiencies inherent in the particular \nmathematical strategy used by the \n\nscuff-em\n core library\n\nto solve Maxwell's equations---namely, the\ndiscretized surface-integral-equation (SIE) formulation.\n\n\nYou can read about all the gory details of SIE solvers \n\nhere\n, but for the purposes of \nthis discussion all you really need to know is this: For a\ngiven material geometry irradiated by a given incident field \nat a given frequency, \nscuff-em\n assembles and solves a \nlinear system of the form\n\n \\mathbf{M}(\\omega) \\mathbf{c} = \\mathbf{f}^{\\text{inc}}\n\nwhere \n\n\n\n\n\n\nc\n represents the unknown surface currents for which we are solving,\n\n\n\n\n\n\nthe RHS vector \nf\n depends on the geometry, the frequency, and the incident field,\n\n\n\n\n\n\nthe matrix \nM\n depends on the scattering geometry and the frequency but not on the incident field.\nMore specifically, for a scattering geometry consisting of \nN\n objects\n(or \nN\n surfaces in a \n\nregions-and-surfaces geometry specification\n),\nthe matrix \nM\n has an \nN\nN\n block structure in which the \n(m,n)\n block\ndescribes the interactions of object \nm\n with object \nn\n.\n\n\n\n\n\n\nArmed with just this much knowledge, we can understand the\ntwo key efficiencies possible in SIE scattering calculations:\n\n\n\n\n\n\n(1)\n First, suppose that, in a geometry consisting of 2 or more bodies,\nwe would like to perform calculations for various different\nrelative geometric configurations of the bodies---for example,\ndifferent separation distances or rotation angles between bodies---at\nthe same frequency.\nThe diagonal blocks of the \nM\n matrix, which represent \nthe self-interactions of objects and are the most costly\nblocks to compute, are \nindependent\n of the relative \nconfiguration of the various objects in the geometry,\nand thus need only be computed \nonce\n for a given\ngeometry at a given frequency, after which they may be\nreused for any number of calculations involving \nrearrangements of the relative positions and orientations\nof the bodies.    \n\n\nThus, if we are interested in running calculations\nfor a sphere-cube geometry at (say) 7 different\nvalues of the surface-surface separation, it greatly\nbehooves us to assemble the diagonal (self-interaction)\nblocks just \nonce\n per frequency, then reuse \nthese blocks for each of the 7 separation distances.\nThe sphere-cube interaction block of the matrix\nmust be recomputed at each separation distance, but \nthis is relatively cheap compared to the cost of \ncomputing the sphere-sphere and cube-cube \nself-interaction blocks.   \n\n\n\n\n\n\n\n\n\n\n\n\n(2)\n In the equation above, the LHS is \nindependent\n of\nthe incident field. This means that, once we have \nassembled and LU-factorized the \nM\n matrix \nfor given geometry at a given frequency (a procedure\nwhich scales asymptotically like \n\\sim T^3\n with \nT\n \nthe total number of triangles in our surface meshes) \nwe can solve scattering problems for any number of\nincident fields with cost \n\\sim T^2\n per incident\nfield---that is, essentially \nfor free\n compared\nto the cost of assembling and factorizing the matrix.\n\n\nThus, if we are interested in observing the \nscattering properties of our geometry under irradiation\nby 7 different types of incident field (say,\nplane waves originating from 7 different angles)\nit greatly behooves us to form and LU-factorize\nthe \nM\n matrix just \nonce\n for this frequency,\nthen reuse the factorized matrix to solve the linear\nsystem above for the 7 different types of incident field.\n\n\n\n\n\n\nTo take advantage of efficiency \n(a)\n, \nscuff-scatter\n\nsupports the command-line option\n\n\n  --transfile MyTransFile\n\n\n\n\nwhere \nMyTransFile\n is a \n\nlist of geometrical transformations\n.\n\n\nTo take advantage of efficiency \n(b)\n, \nscuff-scatter\n\nsupports the command-line option\n\n\n  --IFFile    MyIFFile\n\n\n\n\nwhere \nMyIFFile\n is a \nlist of incident fields\n.\n\n\n\n\n3. \nscuff-scatter\n examples\n\n\n\n\nMie scattering\n\n\nElectrostatics of a spherical dielectric shell\n\n\nSpatially-resolved study of plane-wave transmission through a infinite-area thin dielectric film\n\n\nDiffraction of a plane wave by a discs, disc arrays, and hole arrays", 
            "title": "scuff-scatter"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-defining-the-scattering-problem", 
            "text": "--geometry MyGeometry.scuffgeo  Specifies the geometry input file.  --Omega      3.1415\n--OmegaFile  MyOmegaFile\n--Lambda     0.5\n--LambdaFile MyLambdaFile  Specifies the angular frequencies at which to\nrun calculations. (Angular frequencies are interpreted\nin units of  c/1\\,\\mu\\text{m}=3\\cdot 10^{14}  rad/sec.)\nThe  --Omega  option may be used more than once \nto specify multiple frequencies. Alternatively,\nthe  --OmegaFile  option may be used to specify the\nname of a file containing a list of frequencies (one per\nline) at which to run calculations.  The options  --Lambda  and  --LambdaFile  may alternatively\nbe used to define the frequencies at which to run calculations\nin terms of the corresponding free-space wavelength \\lambda=\\frac{2\\pi}{\\omega} , interpreted in units\nof microns. Thus  --Omega 3.1415  and  --Lambda 0.5 \nare equivalent; both specify an angular frequency \\omega=\\pi \\cdot 3\\cdot 10^{14} rad/sec, \ncorresponding\nto a free-space wavelength of  \\lambda=0.5\\,\\mu m.  Note: Even if you use  --Lambda / --LambdaFile \ninstead of  --Omega / --OmegaFile  to specify the\ncomputational frequencies, the output files\nwill still report data in terms of the frequency\n(the equivalent  --Omega  values), not the \nwavelength. To plot your data versus wavelength\ninstead of frequency, just plot versus the\nquantity  \\frac{2\\pi}{\\omega} .", 
            "title": "Options defining the scattering problem"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-defining-the-incident-field", 
            "text": "The options for specifying incident fields in scuff-em  are described in detail on the page Incident fields in  scuff-em ;\nhere we just list the\navailable options without commentary.  --pwDirection    nx ny nz\n--pwPolarization Ex Ey Ez  --psStrength Px Py Pz\n--psLocation xx yy zz  --gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbCenter Cx Cy Cz\n--gbWaist W  (As in  scuff-scatter , these options may occur multiple times \nto define superpositions of multiple types of incident field.)", 
            "title": "Options defining the incident field"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-requesting-scattered-and-total-fields", 
            "text": "--EPFile MyEPFile  Specifies a list of evaluation points at which to\ncompute and report components of the scattered and total\nfields. This option may be specified more than once to \ndefine multiple sets of field evaluation points.", 
            "title": "Options requesting scattered and total fields"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#options-requesting-power-force-and-torque-data", 
            "text": "--PFTFile     MyGeometry.PFT\n --EMTPFTFile  MyGeometry.EMTPFT\n --OPFTFile    MyGeometry.OPFT\n --DSIPFTFile  MyGeometry.DSIPFT  Each of these options requests that power, force, and torque (PFT)\ndata be written to a file of the specified name. The resulting\nfiles all have the same file format---reporting absorbed and\nscattered power, force (radiation pressure), and torque\nfor all objects in the geometry at all frequencies you\nrequested (see the file header for details)---but differ \nin the algorithm used to compute the force:    The \"energy-momentum-transfer\" PFT (EMTPFT) method\ncomputes powers, forces and torques by considering the\nJoule heating of, and Lorentz force on, the\nsurface currents in the presence of the total \nfields. (This is the default, so the  --PFTFile  \noption is synonymous with  --EMTPFTFile .)    The \"displaced-surface-integral\" PFT (DSIPFT) method\ncomputes PFTs by integrating the Poynting vector\nand Maxwell stress tensor over a bounding surface \nsurrounding the body.    The \"overlap\" PFT (OPFT) method computes PFTs\ndirectly from the surface currents by exploiting\nthe relationship between the surface currents\nand the total electric and magnetic fields at \nbody surfaces.", 
            "title": "Options requesting power, force, and torque data"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#2-scuff-scatter-advanced-mode", 
            "text": "For some types of calculation it is possible to achieve\nsignificant computational accelerations by taking advantage\nof certain efficiencies inherent in the particular \nmathematical strategy used by the  scuff-em  core library \nto solve Maxwell's equations---namely, the\ndiscretized surface-integral-equation (SIE) formulation.  You can read about all the gory details of SIE solvers  here , but for the purposes of \nthis discussion all you really need to know is this: For a\ngiven material geometry irradiated by a given incident field \nat a given frequency,  scuff-em  assembles and solves a \nlinear system of the form  \\mathbf{M}(\\omega) \\mathbf{c} = \\mathbf{f}^{\\text{inc}} \nwhere     c  represents the unknown surface currents for which we are solving,    the RHS vector  f  depends on the geometry, the frequency, and the incident field,    the matrix  M  depends on the scattering geometry and the frequency but not on the incident field.\nMore specifically, for a scattering geometry consisting of  N  objects\n(or  N  surfaces in a  regions-and-surfaces geometry specification ),\nthe matrix  M  has an  N N  block structure in which the  (m,n)  block\ndescribes the interactions of object  m  with object  n .    Armed with just this much knowledge, we can understand the\ntwo key efficiencies possible in SIE scattering calculations:    (1)  First, suppose that, in a geometry consisting of 2 or more bodies,\nwe would like to perform calculations for various different\nrelative geometric configurations of the bodies---for example,\ndifferent separation distances or rotation angles between bodies---at\nthe same frequency.\nThe diagonal blocks of the  M  matrix, which represent \nthe self-interactions of objects and are the most costly\nblocks to compute, are  independent  of the relative \nconfiguration of the various objects in the geometry,\nand thus need only be computed  once  for a given\ngeometry at a given frequency, after which they may be\nreused for any number of calculations involving \nrearrangements of the relative positions and orientations\nof the bodies.      Thus, if we are interested in running calculations\nfor a sphere-cube geometry at (say) 7 different\nvalues of the surface-surface separation, it greatly\nbehooves us to assemble the diagonal (self-interaction)\nblocks just  once  per frequency, then reuse \nthese blocks for each of the 7 separation distances.\nThe sphere-cube interaction block of the matrix\nmust be recomputed at each separation distance, but \nthis is relatively cheap compared to the cost of \ncomputing the sphere-sphere and cube-cube \nself-interaction blocks.          (2)  In the equation above, the LHS is  independent  of\nthe incident field. This means that, once we have \nassembled and LU-factorized the  M  matrix \nfor given geometry at a given frequency (a procedure\nwhich scales asymptotically like  \\sim T^3  with  T  \nthe total number of triangles in our surface meshes) \nwe can solve scattering problems for any number of\nincident fields with cost  \\sim T^2  per incident\nfield---that is, essentially  for free  compared\nto the cost of assembling and factorizing the matrix.  Thus, if we are interested in observing the \nscattering properties of our geometry under irradiation\nby 7 different types of incident field (say,\nplane waves originating from 7 different angles)\nit greatly behooves us to form and LU-factorize\nthe  M  matrix just  once  for this frequency,\nthen reuse the factorized matrix to solve the linear\nsystem above for the 7 different types of incident field.    To take advantage of efficiency  (a) ,  scuff-scatter \nsupports the command-line option    --transfile MyTransFile  where  MyTransFile  is a  list of geometrical transformations .  To take advantage of efficiency  (b) ,  scuff-scatter \nsupports the command-line option    --IFFile    MyIFFile  where  MyIFFile  is a  list of incident fields .", 
            "title": "2. scuff-scatter advanced mode"
        }, 
        {
            "location": "/applications/scuff-scatter/scuff-scatter/#3-scuff-scatter-examples", 
            "text": "Mie scattering  Electrostatics of a spherical dielectric shell  Spatially-resolved study of plane-wave transmission through a infinite-area thin dielectric film  Diffraction of a plane wave by a discs, disc arrays, and hole arrays", 
            "title": "3. scuff-scatter examples"
        }, 
        {
            "location": "/applications/scuff-transmission/scuff-transmission/", 
            "text": "scuff-transmission\n\n\nThe documentation for \nscuff-transmission\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-transmission"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/", 
            "text": "Computing the photonic local density of states with\n    \nscuff-ldos\n\n\n\n\n\n\n\nscuff-ldos\n\nis a tool for computing the electromagnetic local density \nof states (LDOS) at points inside or outside compact or \nextended material bodies.\n\n\nThe inputs you supply to \nscuff-ldos\n calculation are\n\n\n\n\n\n\nA \n.scuffgeo\n file describing your geometry.\n\n\n\n\n\n\nA list of evaluation points \n\\mathbf x\n at which you want to know\n  the LDOS.\n\n\n\n\n\n\nOne or more angular frequencies \n\\omega\n at which to perform\n  calculations.\n\n\n\n\n\n\nOptionally, for periodic geometries, you may additionally specify\n  a list of Bloch wavevectors at which to evaluate wavevector-resolved\n  contributions to the LDOS. If you do not specify such a list,\n  \nscuff-ldos\n will evaluate an integral over the Brillouin zone\n  to compute the total LDOS at each \n(\\omega, \\mathbf x)\n point.\n\n\n\n\n\n\nThe outputs you get back from a \nscuff-ldos\n calculation may\ninclude\n\n\n\n\n\n\nThe LDOS at each \n(\\omega, \\mathbf x)\n point.\n\n\n\n\n\n\nFor periodic geometries, the contributions of individual\n  Bloch wavevectors \n\\mathbf k_{\\text{Bloch}}\n to the LDOS.\n  If you supplied a list of Bloch vectors as an input,\n  you will get wavevector-resolved information for each point\n  in your list; otherwise, you will get wavevector-resolved \n  information for each point chosen automatically by \n  \nscuff-ldos\n in its numerical-cubature evaluation of \n  the Brillouin-zone integral.\n\n\n\n\n\n\nOptionally, the full Cartesian components of the scattering\n  parts of the dyadic Green's functions (DGFs) [the \n  electric / magnetic LDOS is proportional to the imaginary part \n  of the trace of the electric / magnetic DGFs].\n\n\n\n\n\n\nFor testing purposes, \nscuff-ldos\n also includes built-in\nfunctionality to compute the LDOS for some geometries that\nmay be handled analytically (specifically, infinite-area PEC\nground planes and infinite-area dielectric half-spaces).\n\n\nTable of Contents\n\n\n1. What \nscuff-ldos\n actually computes\n\n\n2. \nscuff-ldos\n command-line options\n\n\nCommon options\n\n\nOptions requesting analytical LDOS calculations\n\n\n\n\n\n\n3. \nscuff-ldos\n output files\n\n\nThe .log file\n\n\nThe .LDOS file\n\n\nThe .byOmegakBloch file\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-ldos\n\n\n\n\n\n\n\n\n1. What \nscuff-ldos\n actually computes\n\n\nSome technical details on the calculation performed by\n\nscuff-ldos\n may be found in \nthis memo\n.\nThe long story short is as follows:\n\n\nWhat \nscuff-ldos\n actually computes is the scattering\npart of the dyadic Green's functions (DGFs) of the geometry \nin question. For a given (angular frequency, evaluation point)\npair \n(\\omega, \\mathbf x)\n, these are \n3\\times 3\n matrices\ngiving the scattered fields at \n\\mathbf x\n due to point sources\nat \n\\mathbf x\n, with all fields and sources having time\ndependence \ne^{-i\\omega t}\n. (The full definition may be\nfound in the memo above). The LDOS is obtained from the \nimaginary part of the traces of the DGFs.\n\n\nFor non-periodic geometries, \nscuff-ldos\n does 6 scattering\ncalculations for each \n(\\omega, \\mathbf x)\n point---specifically,\nscattering calculations in which the incident field is the\nfield of an electric or magnetic point source oriented in \neach of the 3 cartesian directions. (Because these calculations\ninvolve the same scattering geometry at the same frequency,\njust with different incident fields, they are fast in a \nBEM solver like \nscuff-em\n because the BEM matrix need\nnot be recomputed anew for each new incident field.) The\nresults for the LDOS at each \n(\\omega,\\mathbf x)\n point are\nreported in the \n.LDOS\n output file.\n\n\nFor periodic geometries, \nscuff-ldos\n does many scattering\ncalculations for each \n(\\omega, \\mathbf x)\n point.\nIndeed, the DGFs at \n\\mathbf x\n are defined as the response of \nthe system to a single point source at \n\\mathbf x\n; however, in\nin \nscuff-em\n calculations for periodic geometries,\n\nall\n currents and fields, including incident fields, \nmust be Bloch-periodic, a condition which is not satisfied\nby the fields of a single point source at \n\\mathbf x\n. Instead,\nwhat \nscuff-em\n can compute is the response of the system\nto a phased \narray\n of point sources---that is, an infinite\ncollection of point sources located at points \n\\mathbf x+\\mathbf L\n\nwith phases \ne^{ik_BL}\n; here \n\\mathbf L\n ranges over all \nlattice vectors in a 1D or 2D lattice, and \nk_B\n is \na 1D or 2D Bloch wavevector that ranges over the\nBrillouin zone (BZ) of the reciprocal lattice. By performing\nthese calculations at \nall\n possible Bloch vectors\n\nk_B\n and adding up the results---that is, by\nperforming an integration over the BZ, effectively an \ninverse Fourier transform---we recover \nthe fields of just the single point source at \n\\mathbf x\n.\nFor periodic geometries, \nscuff-ldos\n performs this \nBZ integration by numerical cubature for\neach \n(\\omega,\\mathbf x)\n point. This involves sampling\nthe integrand (that is, computing Bloch-periodic DGFs) \nat large numbers of \nk_B\n points; these samples, \nwhich provide Bloch-vector-resolved information on the \nLDOS and DGFs of the system, are reported by \nscuff-ldos\n \nin the\n.byOmegakBloch\n output file, while results \nfor the full (BZ-integrated) LDOS are written to the \n\n.LDOS\n output file.\n\n\n\n\n\n\n2. \nscuff-ldos\n command-line options\n\n\nCommon options\n\n\nscuff-ldos\n recognizes the following subset of the \n[list of commonly accepted options to \nscuff-em\n command-line codes][CommonOptions].\n\n\n--geometry\n--EPFile\n--Omega\n--OmegaFile\n--OmegakBlochFile\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache\n\n\nOf these options, \n--geometry\n and \n--EPFile\n are\nalways mandatory, while one of \n\n--Omega\n, \n--OmegaFile\n, or \n--OmegakBlochFile\n \nmust also be specified. All\nother command-line arguments are optional.\n\n\nIf you specify \n--Omega\n or \n--OmegaFile\n in\na calculation involving a periodic geometry,\nthen \nscuff-ldos\n will perform a numerical\ncubature over the Brillouin zone for each\n\n\\omega\n value. (The options \n--BZSymmetry\n,\n\n--AbsTol\n, and \n--RelTol\n control the \nparameters of this cubature.) Samples\nof the integrand at the cubature points \nwill be written to the \n.byOmegakBloch\n \nfile, while the full integrated resuts\nwill be written to the \n.LDOS\n file.\n\n\nAlternatively, if you use \n--OmegakBlochFile\n\nto specify a list of (\n\\omega, \\mathbf k_B\n)\npoints, then \nscuff-ldos\n will skip the\nnumerical BZ cubature and instead perform\ncomputations at just the points you \nspecified. In this case you wil get back a\n\n.byOmegakBloch\n file, but not an\n\n.LDOS\n file.\n\n\nOptions requesting analytical LDOS calculations\n\n\n````\n--GroundPlane\n\n\n--HalfSpace PEC\n--HalfSpace Aluminum\n\n\n--SkipBZIntegration\n  ````\n\n\nAs noted above, for testing purposes \nscuff-ldos\n incorporates\n\n\nThe first option here instructs \nscuff-ldos\n to \nbypass the usual LDOS calculation it would otherwise \nperform and instead to compute the LDOS of an\nauxiliary geometry in which the half-space \nregion lying below the \nxy\n plane (the region\n\nz<0\n) is filled with a homogeneous material\ndescribed by the given \n\nscuff-em\n material designation\n.\nIf this material is \nPEC\n, then the calculation\nis performed using the image-source method.\nOtherwise, the calculation is performed using the \nanalytical plane-wave decomposition \noutlined in the \n\nscuff-ldos\n memo\n.\n\n\nAs illustrated by \nthis example\n,\nthe \n--HalfSpace\n option is intended to be\ntacked on to an otherwise complete \nscuff-ldos\n\ncommand-line containing options such as \n\n--geometry\n and \n--EPFile.\n With \n--HalfSpace\n,\n\nscuff-ldos\n performs the same calculation that \nit would do without that option---using the same\nevaluation points and the same frequency options---but\njust does the calculation a different way. (Although\nthe surface meshes specified in the \n.scuffgeo\n\nfile are not referenced in this case, a \nvalid \n.scuffgeo\n file must still be supplied;\nthe \nLATTICE...ENDLATTICE\n section of this \nfile is used to define the lattice used \nfor the analytical calculation.)\n\n\n\n\n3. \nscuff-ldos\n output files\n\n\nThe \n.log\n file\n\n\nLike all command-line codes in the \nscuff-em\n suite,\n\nscuff-ldos\n produces a text output file named\n\nFileBase.log\n that you can follow to monitor the\nstatus of your calculation.\n\n\nThe \n.LDOS\n file\n\n\nThis file reports values of the electric and magnetic\nLDOS for each angular frequency and each evaluation\npoint you requested. This file is always produced\nfor calculations on non-periodic geometries. For\ncalculation on periodic geometries, this file is \nproduced only if you specified the \n\n--Omega\n and/or \n--OmegaFile\n command-line options.\n\n\nThe \n.byOmegakBloch\n file\n\n\nThis file reports Bloch-vector resolved versions\nof the information reported by the \n.LDOS\n file.\nThis file is only produced for calculations on\nperiodic geometries.\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-ldos\n\n\n\n\nLDOS above a dielectric half-space", 
            "title": "scuff-ldos"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#2-scuff-ldos-command-line-options", 
            "text": "Common options  scuff-ldos  recognizes the following subset of the \n[list of commonly accepted options to  scuff-em  command-line codes][CommonOptions].  --geometry\n--EPFile\n--Omega\n--OmegaFile\n--OmegakBlochFile\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache  Of these options,  --geometry  and  --EPFile  are\nalways mandatory, while one of  --Omega ,  --OmegaFile , or  --OmegakBlochFile  \nmust also be specified. All\nother command-line arguments are optional.  If you specify  --Omega  or  --OmegaFile  in\na calculation involving a periodic geometry,\nthen  scuff-ldos  will perform a numerical\ncubature over the Brillouin zone for each \\omega  value. (The options  --BZSymmetry , --AbsTol , and  --RelTol  control the \nparameters of this cubature.) Samples\nof the integrand at the cubature points \nwill be written to the  .byOmegakBloch  \nfile, while the full integrated resuts\nwill be written to the  .LDOS  file.  Alternatively, if you use  --OmegakBlochFile \nto specify a list of ( \\omega, \\mathbf k_B )\npoints, then  scuff-ldos  will skip the\nnumerical BZ cubature and instead perform\ncomputations at just the points you \nspecified. In this case you wil get back a .byOmegakBloch  file, but not an .LDOS  file.  Options requesting analytical LDOS calculations  ````\n--GroundPlane  --HalfSpace PEC\n--HalfSpace Aluminum  --SkipBZIntegration\n  ````  As noted above, for testing purposes  scuff-ldos  incorporates  The first option here instructs  scuff-ldos  to \nbypass the usual LDOS calculation it would otherwise \nperform and instead to compute the LDOS of an\nauxiliary geometry in which the half-space \nregion lying below the  xy  plane (the region z<0 ) is filled with a homogeneous material\ndescribed by the given  scuff-em  material designation .\nIf this material is  PEC , then the calculation\nis performed using the image-source method.\nOtherwise, the calculation is performed using the \nanalytical plane-wave decomposition \noutlined in the  scuff-ldos  memo .  As illustrated by  this example ,\nthe  --HalfSpace  option is intended to be\ntacked on to an otherwise complete  scuff-ldos \ncommand-line containing options such as  --geometry  and  --EPFile.  With  --HalfSpace , scuff-ldos  performs the same calculation that \nit would do without that option---using the same\nevaluation points and the same frequency options---but\njust does the calculation a different way. (Although\nthe surface meshes specified in the  .scuffgeo \nfile are not referenced in this case, a \nvalid  .scuffgeo  file must still be supplied;\nthe  LATTICE...ENDLATTICE  section of this \nfile is used to define the lattice used \nfor the analytical calculation.)", 
            "title": "2. scuff-ldos command-line options"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#3-scuff-ldos-output-files", 
            "text": "The  .log  file  Like all command-line codes in the  scuff-em  suite, scuff-ldos  produces a text output file named FileBase.log  that you can follow to monitor the\nstatus of your calculation.  The  .LDOS  file  This file reports values of the electric and magnetic\nLDOS for each angular frequency and each evaluation\npoint you requested. This file is always produced\nfor calculations on non-periodic geometries. For\ncalculation on periodic geometries, this file is \nproduced only if you specified the  --Omega  and/or  --OmegaFile  command-line options.  The  .byOmegakBloch  file  This file reports Bloch-vector resolved versions\nof the information reported by the  .LDOS  file.\nThis file is only produced for calculations on\nperiodic geometries.", 
            "title": "3. scuff-ldos output files"
        }, 
        {
            "location": "/applications/scuff-ldos/scuff-ldos/#4-examples-of-calculations-using-scuff-ldos", 
            "text": "LDOS above a dielectric half-space", 
            "title": "4. Examples of calculations using scuff-ldos"
        }, 
        {
            "location": "/applications/scuff-tmatrix/scuff-tmatrix/", 
            "text": "scuff-tmatrix\n\n\nThe documentation for \nscuff-tmatrix\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-tmatrix"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/", 
            "text": "Computing thermal-equilibrium Casimir energies, forces, \n    and torques with \nscuff-cas3d\n\n\n\n\n\nscuff-cas3d\n is a command-line application within the \nscuff-em\n suite\nfor modeling Casimir interactions between compact or extended homogeneous\nbodies of arbitary shape and arbitrary (linear, isotropic, piecewise homogeneous)\nfrequency-dependent permittivity and permeability. \nscuff-cas3d\n implements the \n\nfluctuating-surface current (FSC)\n approach\n\nto numerical Casimir modeling.]\n\n\nscuff-cas3d\n handles \nequilibrium\n Casimir interactions, in which\nall interacting bodies and the external medium in which they are embedded \nexist at the same temperature (which may be absolute zero). If you\nneed to model Casimir interactions between bodies at \ndifferent\n \ntemperatures, the tool you want is \n\nscuff-neq\n.\n(However: if your exterior embedding medium is not at zero \ntemperature, then the \ntotal\n Casimir forces will involve\nboth non-equilibrium contributions computed with \nscuff-neq\n \nand equilibrium contributions (at the temperature of the \nexterior medium) computed with \nscuff-cas3d\n.\n\n\nThe basic flow of a typical \nscuff-cas3d\n run goes something like this:\n\n\n\n\n\n\nYou create a \nscuff-em\n geometry file\n\ndescribing the interacting objects or surfaces in your geometry.\n\n\n\n\n\n\nOptionally, you define a \n\nlist of geometric transformations\n \nto be applied to the geometry for Casimir computations.\nFor example, if your geometry consists of two nanoparticles, you\nmight ask for the Casimir force between the particles at 10 different\nvalues of the surface--surface separation.\n\n\n\n\n\n\nYou run \nscuff-cas3d\n with various\n\ncommand-line options\n specifying the\ndesired output quantities (energy, \ny\n-force, etc.), whether\nyou want frequency-resolved or frequency-summed data, and\nother options. This produces various text-based \n\noutput files\n, which you will typically\nplot using \ngnuplot\n or other \nplotting or post-processing tools.\n\n\n\n\n\n\nTable of Contents\n\n\n1. What scuff-cas3d actually computes\n\n\n1a. Compact objects\n\n\n1b. Extended objects\n\n\n\n\n\n\n2. \nscuff-cas3d\n command-line options\n\n\nCommon options\n\n\nOptions requesting Casimir output quantities\n\n\nOptions specifying temperature\n\n\n\n\n\n\n3. \nscuff-cas3d\n output files\n\n\nThe .log file\n\n\nThe .out file\n\n\nThe .byXi file\n\n\nThe .byXikBloch file\n\n\n\n\n\n\n4. Examples of Casimir calculations using \nscuff-cas3d\n\n\n\n\n\n\n1. What \nscuff-cas3d\n actually computes\n\n\n1a. Compact objects\n\n\nThe Casimir energy \n\\mathcal{E}\n of a collection of compact bodies,\nand the \ni\n-directed Casimir force \n\\mathcal{F}_i\n and \ntorque \n\\mathcal{T}_i\n on one of \nthose bodies, are computed in the FSC approach as integrals \nover the positive imaginary frequency axis\n(\n\\omega=i\\xi\n) of the form\n\n\n\n\n \\begin{array}{ccc}\n   \\mathcal{E}   &=& \\int_0^\\infty E(\\xi) \\, d\\xi \\\\\n   \\mathcal{F}_i &=& \\int_0^\\infty F_i(\\xi) \\, d\\xi \\\\\n   \\mathcal{T}_i &=& \\int_0^\\infty T_i(\\xi) \\, d\\xi \\\\\n   \\end{array}\n\n\n\n\n\n(This is for the zero-temperature case; at a finite temperature\n\nT\n the imaginary-frequency integration is replaced by a \nMatsubara sum according to the prescription\n\n \\int_0^\\infty F(\\xi) \\, d\\xi \n   \\qquad \\Longrightarrow \\qquad\n   (\\Delta \\xi) \\sideset{}{'}{\\sum}_{n=0}^\\infty F(n\\Delta\\xi),\n   \\qquad \\Delta\\xi =\\frac{2\\pi k T}{\\hbar}\n\n\nwhere the primed sum indicates that the \nn=0\n term is \nto be weighted by \n1/2.\n)\n\n\nThe heart of the FSC algorithm implemented by \nscuff-cas3d\n\nis an efficient technique for computing the quantities\n\n\\{E,F_i,T_i\\}(\\xi)\n---that is, the contributions of \nindividual imaginary frequencies to the total Casimir \nquantities---at arbitrary frequencies \n\\xi\n.\nThe question of \nwhich\n frequencies \n\\xi\n are sampled\ndepends on the command-line options you specify:\n\n\n\n\n\n\nIf you use the \n--Xi\n or \n--XiFile\n command-line options to \nspecify one or more particular values of \n\\xi\n, then \nscuff-cas3d\n\nwill compute and report just the integrand \nF(\\xi)\n at those\nvalues. In this case, the code will produce a \n.byXi\n file,\nbut no \n.out\n file.\n\n\n\n\n\n\nIf, instead, you use the \n--temperature\n command-line option to specify \na temperature at which to calculate, then \nscuff-cas3d\n\nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get both a \n.byXi\n and a \n.out\n file; \nthe \n.byXi\n file will report data on the Casimir\nintegrands at the Matsubara frequencies\n\n\\xi_n\\equiv n\\Delta \\xi\n for \nn=0,1,\\cdots\n\n\n\n\n\n\n\n\nIf you don't specify any of the above, then \nscuff-cas3d\n\ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In \nthis case, you will get both a \n.byXi\n and a \n.out\n\nfile; the \n.byXi\n file reports data on the Casimir\nintegrands at the frequencies \n\\{\\xi\\}\n chosen by \nthe built-in integrator.\n\n\n\n\n\n\n1b. Extended objects\n\n\nFor an extended material configuration described by a\n\nperiodic geometry\n\nwith Bloch-periodic boundary conditions, the Casimir force \n\ndensity\n (that is, the force \nper unit length\n for a 1D \nextended geometry, or \nper unit area\n for a 2D extended \ngeometry) is computed in the FSC approach as multi-dimensional \nintegrals over both imaginary frequencies \n\\xi\n and Bloch \nvectors \n\\mathbf{k}\n:\n\n\n\n\n \\mathcal{F}\n   = \n   \\int_0^\\infty d\\xi \\,\n    \\underbrace{\\int_{\\text{BZ}} \n     f(\\xi, \\mathbf{k}) \n     \\, d\\mathbf{k}}_{\\equiv F(\\xi)}\n\n\n\n\n\n(Expressions for the Casimir energy and torque are similar).\nThe Bloch vector \n\\mathbf k\n is a one-component vector\nfor 1D-extended geometries (such as \n\ninfinite-length cylinders or beams\n,\nand a two-component vector\nfor 2D-extended geometries (such as \n\ninfinite-area slabs\n).\nThe \n\\mathbf k\n integral here ranges over the \nBrillouin\nzone\n (BZ)\n\n\nscuff-cas3d\n uses the FSC algorithm to compute\nvalues of the integrand \nf(\\xi, \\mathbf k)\n at \nindividual \n(\\xi, \\mathbf k)\n points.\n\n\nThe FSC algorithm implemented by \nscuff-cas3d\n\nis an efficient technique for computing the quantity\n\n f(\\xi, \\mathbf k)\n---that is, the contributions of\nindividual (imaginary frequency, wavevector) pairs\n\n(\\xi,\\mathbf k)\n---to the total Casimir quantities.\nThe question of \nwhich\n (\n\\xi, \\mathbf k)\n points are \nsampled depends on the command-line options you specify:\n\n\n\n\n\n\nIf you use the \n--XikBlochFile\n command-line option\nto specify a list of \n(\\xi, \\mathbf k)\n points, then \n\nscuff-cas3d\n will compute and report just the \nintegrand \nf(\\xi, \\mathbf k)\n at those values. \nIn this case, the code will produce a \n.byXikBloch\n file,\nbut no other output files.\n\n\n\n\n\n\nIf you use the \n--Xi\n or \n--XiFile\n command-line options to\nspecify one or more particular values of \n\\xi\n (but not\nspecific values of \n\\mathbf k\n), then \nscuff-cas3d\n will\nnumerically evaluate the Brillouin-zone integral over \n\n\\mathbf k\n and will report the resulting value of the \nquantity \nF(\\xi)\n at each \n\\xi\n value. \nIn this case, the code will produce two output files\n\n(1)\n a \n.byXi\n file reporting values of \nF(\\xi)\n at the \n\n\\xi\n points you specified, and \n(2)\n a \n.byXikBloch\n\nfile reporting values of the \n\\mathbf k\n integrand \nf(\\xi, \\mathbf k)\n\nat each of the \n\\mathbf k\n points sampled by the \nbuilt-in integrator.\n\n\n\n\n\n\nIf you use the \n--temperature\n command-line option to specify\na temperature at which to calculate, then \nscuff-cas3d\n\nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get three output files: \n\n(1)\n a \n.out\n file reporting the full Matsubara-summed\nCasimir quantities,\n\n(2)\n a \n.byXi\n file reporting values of the function\n\nF(\\xi)\n at each Matsubara frequency; and \n\n(3)\n a \n.byXikBloch\n\nfile reporting values of the \n\\mathbf k\n integrand \nf(\\xi, \\mathbf k)\n\nat each point sampled by the built-in integrator.\n\n\n\n\n\n\nIf you don't specify any of the above, then \nscuff-cas3d\n\ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In\nthis case, you will get the same three output files\nas in the case of the previous item (\n.out\n, \n.byXi\n, \n.byXikBloch\n);\nthe only difference is that the \n\\xi\n points reported\nin the \n.byXi\n and \n.byXikBloch\n files are the quadrature \npoints chosen by the built-in integrator instead of the \nMatsubara frequencies.\n\n\n\n\n\n\n\n\n2. \nscuff-cas3d\n command-line options\n\n\nCommon options\n\n\nscuff-cas3d\n recognizes the following subset of the \n[list of commonly accepted options to \nscuff-em\n command-line codes][CommonOptions].\n\n\n--geometry\n--TransFile\n--Xi\n--XiFile\n--XikBlochFile\n--XiQuadrature\n--XiMin\n--BZQuadrature\n--BZSymmetry\n--MaxBZSamples\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache\n\n\nOptions requesting Casimir output quantities\n\n\n--Energy\n--XForce\n--YForce\n--ZForce\n--Torque ax ay az\n\n\nSpecifies the Casimir quantities in which you are\ninterested: the energy, the Cartesian components\nof the force, or the torque about an axis\npassing through the origin and the point with \nCartesian coordinates \n(ax,ay,az).\n (Thus, for\n\n\nYou may specify more than one of these options,\nbut you must specify at least one.\n\n\nNote\n: \nscuff-cas3d\n always computes the force and torque\non just \none\n of the objects or surfaces in your geometry---namely,\nthe one described by the first \nOBJECT\n or \nSURFACE\n \nspecification in your \n.scuffgeo\n file. For geometries\nconsisting of just two objects or surfaces, the force/torque\non the second object/surface is just the negative of the \nforce/torque on the first. \n\n\nOptions specifying temperature\n\n\n--Temperature 300\n\n\nSets the simulation temperature \nin units of Kelvin,\n\nso that \n--temperature 300\n requests room-temperature calculations.\nThis option implies that you are asking \nscuff-cas3d\n\nto compute full Matsubara-summed Casimir quantities, so it is\nincompatible with options such as \n--Xi\n or \n--XiFile\n that\nspecify particular frequencies at which to compute.\n\n\n\n\n3. \nscuff-cas3d\n output files\n\n\nThe base file name of all output files produced by\n\nscuff-cas3d\n may be specified using the \n--FileBase\n\ncommand-line option; if this option is not specified\nthen the file base is taken to be the base file\nname of the \n.scuffgeo\n file you specified using\nthe \n--geometry\n option.\n\n\nFor all data output files (\n.out\n, \n.byXi\n,\n\n.byXikBloch\n), the output file contains a\n\nheader\n (a sequence of text lines starting with\n#\n)\nexplaining how to interpret the contents of the file.\n\n\nThe \n.log\n file\n\n\nLike all command-line codes in the \nscuff-em\n suite,\n\nscuff-cas3d\n writes a \n.log\n file\n that you \ncan monitor to keep track of your calculation's progress.\n\n\nThe \n.out\n file\n\n\nIf you requested the calculation of\nfull frequency-integrated or Matsubara-summed\nCasimir quantities, these will be written to \nthe \n.out\n file.\n\n\nThe \n.byXi\n file\n\n\nFor any problem involving compact geometries,\nand for any problem involving extended geometries\nin which you requested Brillouin-zone integrations,\nthe contributions of individual imaginary frequencies \n\n\\xi\n will be written to a file named \n.byXi\n.\n\n\nThe \n.byXikBloch\n file\n\n\nFor any problem involving extended geometries,\nthe contributions of individual (frequency, Bloch vector)\npoints \n(\\xi,\\mathbf k)\n will be written to a file\nnamed \nFILEBASE.byXikBloch\n.\n\n\n\n\n4. Examples of Casimir calculations using \nscuff-cas3d\n\n\n\n\n\n\nCasimir forces in a compact geometry:\n  \nA cube and a torus immersed in ethanol\n\n\n\n\n\n\nCasimir forces in a 1D extended geometry: \n  \ninfinite-length silicon beams\n\n\n\n\n\n\nCasimir forces in a 2D extended geometry: \n  \ninfinite-area silicon slabs", 
            "title": "scuff-cas3D"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#1a-compact-objects", 
            "text": "The Casimir energy  \\mathcal{E}  of a collection of compact bodies,\nand the  i -directed Casimir force  \\mathcal{F}_i  and \ntorque  \\mathcal{T}_i  on one of \nthose bodies, are computed in the FSC approach as integrals \nover the positive imaginary frequency axis\n( \\omega=i\\xi ) of the form    \\begin{array}{ccc}\n   \\mathcal{E}   &=& \\int_0^\\infty E(\\xi) \\, d\\xi \\\\\n   \\mathcal{F}_i &=& \\int_0^\\infty F_i(\\xi) \\, d\\xi \\\\\n   \\mathcal{T}_i &=& \\int_0^\\infty T_i(\\xi) \\, d\\xi \\\\\n   \\end{array}   (This is for the zero-temperature case; at a finite temperature T  the imaginary-frequency integration is replaced by a \nMatsubara sum according to the prescription  \\int_0^\\infty F(\\xi) \\, d\\xi \n   \\qquad \\Longrightarrow \\qquad\n   (\\Delta \\xi) \\sideset{}{'}{\\sum}_{n=0}^\\infty F(n\\Delta\\xi),\n   \\qquad \\Delta\\xi =\\frac{2\\pi k T}{\\hbar} \nwhere the primed sum indicates that the  n=0  term is \nto be weighted by  1/2. )  The heart of the FSC algorithm implemented by  scuff-cas3d \nis an efficient technique for computing the quantities \\{E,F_i,T_i\\}(\\xi) ---that is, the contributions of \nindividual imaginary frequencies to the total Casimir \nquantities---at arbitrary frequencies  \\xi .\nThe question of  which  frequencies  \\xi  are sampled\ndepends on the command-line options you specify:    If you use the  --Xi  or  --XiFile  command-line options to \nspecify one or more particular values of  \\xi , then  scuff-cas3d \nwill compute and report just the integrand  F(\\xi)  at those\nvalues. In this case, the code will produce a  .byXi  file,\nbut no  .out  file.    If, instead, you use the  --temperature  command-line option to specify \na temperature at which to calculate, then  scuff-cas3d \nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get both a  .byXi  and a  .out  file; \nthe  .byXi  file will report data on the Casimir\nintegrands at the Matsubara frequencies \\xi_n\\equiv n\\Delta \\xi  for  n=0,1,\\cdots     If you don't specify any of the above, then  scuff-cas3d \ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In \nthis case, you will get both a  .byXi  and a  .out \nfile; the  .byXi  file reports data on the Casimir\nintegrands at the frequencies  \\{\\xi\\}  chosen by \nthe built-in integrator.", 
            "title": "1a. Compact objects"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#1b-extended-objects", 
            "text": "For an extended material configuration described by a periodic geometry \nwith Bloch-periodic boundary conditions, the Casimir force  density  (that is, the force  per unit length  for a 1D \nextended geometry, or  per unit area  for a 2D extended \ngeometry) is computed in the FSC approach as multi-dimensional \nintegrals over both imaginary frequencies  \\xi  and Bloch \nvectors  \\mathbf{k} :    \\mathcal{F}\n   = \n   \\int_0^\\infty d\\xi \\,\n    \\underbrace{\\int_{\\text{BZ}} \n     f(\\xi, \\mathbf{k}) \n     \\, d\\mathbf{k}}_{\\equiv F(\\xi)}   (Expressions for the Casimir energy and torque are similar).\nThe Bloch vector  \\mathbf k  is a one-component vector\nfor 1D-extended geometries (such as  infinite-length cylinders or beams ,\nand a two-component vector\nfor 2D-extended geometries (such as  infinite-area slabs ).\nThe  \\mathbf k  integral here ranges over the  Brillouin\nzone  (BZ)  scuff-cas3d  uses the FSC algorithm to compute\nvalues of the integrand  f(\\xi, \\mathbf k)  at \nindividual  (\\xi, \\mathbf k)  points.  The FSC algorithm implemented by  scuff-cas3d \nis an efficient technique for computing the quantity  f(\\xi, \\mathbf k) ---that is, the contributions of\nindividual (imaginary frequency, wavevector) pairs (\\xi,\\mathbf k) ---to the total Casimir quantities.\nThe question of  which  ( \\xi, \\mathbf k)  points are \nsampled depends on the command-line options you specify:    If you use the  --XikBlochFile  command-line option\nto specify a list of  (\\xi, \\mathbf k)  points, then  scuff-cas3d  will compute and report just the \nintegrand  f(\\xi, \\mathbf k)  at those values. \nIn this case, the code will produce a  .byXikBloch  file,\nbut no other output files.    If you use the  --Xi  or  --XiFile  command-line options to\nspecify one or more particular values of  \\xi  (but not\nspecific values of  \\mathbf k ), then  scuff-cas3d  will\nnumerically evaluate the Brillouin-zone integral over  \\mathbf k  and will report the resulting value of the \nquantity  F(\\xi)  at each  \\xi  value. \nIn this case, the code will produce two output files (1)  a  .byXi  file reporting values of  F(\\xi)  at the  \\xi  points you specified, and  (2)  a  .byXikBloch \nfile reporting values of the  \\mathbf k  integrand  f(\\xi, \\mathbf k) \nat each of the  \\mathbf k  points sampled by the \nbuilt-in integrator.    If you use the  --temperature  command-line option to specify\na temperature at which to calculate, then  scuff-cas3d \nwill evaluate the Matsubara sums to compute the full \nCasimir quantities at the given temperature. In this \ncase you will get three output files:  (1)  a  .out  file reporting the full Matsubara-summed\nCasimir quantities, (2)  a  .byXi  file reporting values of the function F(\\xi)  at each Matsubara frequency; and  (3)  a  .byXikBloch \nfile reporting values of the  \\mathbf k  integrand  f(\\xi, \\mathbf k) \nat each point sampled by the built-in integrator.    If you don't specify any of the above, then  scuff-cas3d \ndefaults to performing a full numerical frequency integration\nto compute zero-temperature Casimir quantities. In\nthis case, you will get the same three output files\nas in the case of the previous item ( .out ,  .byXi ,  .byXikBloch );\nthe only difference is that the  \\xi  points reported\nin the  .byXi  and  .byXikBloch  files are the quadrature \npoints chosen by the built-in integrator instead of the \nMatsubara frequencies.", 
            "title": "1b. Extended objects"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#2-scuff-cas3d-command-line-options", 
            "text": "Common options  scuff-cas3d  recognizes the following subset of the \n[list of commonly accepted options to  scuff-em  command-line codes][CommonOptions].  --geometry\n--TransFile\n--Xi\n--XiFile\n--XikBlochFile\n--XiQuadrature\n--XiMin\n--BZQuadrature\n--BZSymmetry\n--MaxBZSamples\n--AbsTol\n--RelTol\n--FileBase\n--Cache\n--ReadCache\n--WriteCache  Options requesting Casimir output quantities  --Energy\n--XForce\n--YForce\n--ZForce\n--Torque ax ay az  Specifies the Casimir quantities in which you are\ninterested: the energy, the Cartesian components\nof the force, or the torque about an axis\npassing through the origin and the point with \nCartesian coordinates  (ax,ay,az).  (Thus, for  You may specify more than one of these options,\nbut you must specify at least one.  Note :  scuff-cas3d  always computes the force and torque\non just  one  of the objects or surfaces in your geometry---namely,\nthe one described by the first  OBJECT  or  SURFACE  \nspecification in your  .scuffgeo  file. For geometries\nconsisting of just two objects or surfaces, the force/torque\non the second object/surface is just the negative of the \nforce/torque on the first.   Options specifying temperature  --Temperature 300  Sets the simulation temperature  in units of Kelvin, \nso that  --temperature 300  requests room-temperature calculations.\nThis option implies that you are asking  scuff-cas3d \nto compute full Matsubara-summed Casimir quantities, so it is\nincompatible with options such as  --Xi  or  --XiFile  that\nspecify particular frequencies at which to compute.", 
            "title": "2. scuff-cas3d command-line options"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#3-scuff-cas3d-output-files", 
            "text": "The base file name of all output files produced by scuff-cas3d  may be specified using the  --FileBase \ncommand-line option; if this option is not specified\nthen the file base is taken to be the base file\nname of the  .scuffgeo  file you specified using\nthe  --geometry  option.  For all data output files ( .out ,  .byXi , .byXikBloch ), the output file contains a header  (a sequence of text lines starting with # )\nexplaining how to interpret the contents of the file.  The  .log  file  Like all command-line codes in the  scuff-em  suite, scuff-cas3d  writes a  .log  file  that you \ncan monitor to keep track of your calculation's progress.  The  .out  file  If you requested the calculation of\nfull frequency-integrated or Matsubara-summed\nCasimir quantities, these will be written to \nthe  .out  file.  The  .byXi  file  For any problem involving compact geometries,\nand for any problem involving extended geometries\nin which you requested Brillouin-zone integrations,\nthe contributions of individual imaginary frequencies  \\xi  will be written to a file named  .byXi .  The  .byXikBloch  file  For any problem involving extended geometries,\nthe contributions of individual (frequency, Bloch vector)\npoints  (\\xi,\\mathbf k)  will be written to a file\nnamed  FILEBASE.byXikBloch .", 
            "title": "3. scuff-cas3d output files"
        }, 
        {
            "location": "/applications/scuff-cas3D/scuff-cas3D/#4-examples-of-casimir-calculations-using-scuff-cas3d", 
            "text": "Casimir forces in a compact geometry:\n   A cube and a torus immersed in ethanol    Casimir forces in a 1D extended geometry: \n   infinite-length silicon beams    Casimir forces in a 2D extended geometry: \n   infinite-area silicon slabs", 
            "title": "4. Examples of Casimir calculations using scuff-cas3d"
        }, 
        {
            "location": "/applications/scuff-caspol/scuff-caspol/", 
            "text": "scuff-caspol\n\n\nThe documentation for \nscuff-caspol\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-caspol"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/", 
            "text": "Modeling non-equilibrium electromagnetic fluctuations with\n     \nscuff-neq\n\n\n\n\n\nscuff-neq\n is an application code in the \nscuff-em\n suite for \nstudying non-equilibrium (NEQ) electromagnetic-fluctuation-induced \nphenomena--specifically, for computing \nradiative heat-transfer rates\n \nand \nnon-equilibrium Casimir forces and torques\n for bodies of \narbitrary shapes and arbitrary (linear, isotropic, piecewise \nhomogeneous) frequency-dependent permittivity and permeability.\n\nscuff-neq\n implements the \n\nfluctuating-surface current (FSC)\n approach\n \nto numerical modeling of non-equilibrium fluctuation phenomena.\n\n\nMechanically, working with \nscuff-neq\n is similar in many ways to \nworking with the equilibrium Casimir code \nscuff-cas3d\n. \nIn particular,\n\n\n\n\n\n\nAs in \nscuff-cas3d\n, you can request either \n(a)\n frequency-resolved \ninformation on heat-transfer rates and NEQ Casimir forces (in which case \nyou will specify a list of frequencies and will get back a list of \nfrequency-specific values of energy and momentum fluxes) or \n\n(b)\n frequency-integrated information, in which case you will assign \ntemperatures to each body in your geometry and \nscuff-neq\n will \nnumerically integrate the fluxes, weighted by appropriate Bose-Einstein \nfactors, to obtain the total heat-transfer rate or NEQ Casimir force. \n(For more details, see \n\nWhat \nscuff-neq\n actually computes\n.)\n\n\n\n\n\n\nAs in \nscuff-cas3d\n, you can specify an optional list of \n\ngeometrical transformations\n \ndescribing various displacements and rotations of the bodies \nin your geometry; in this case you will get back values of the \nfrequency-resolved or frequency-integrated quantities for each \ntransformation you specify.\n\n\n\n\n\n\nA bonus feature of \nscuff-neq\n that is \nnot\n present in \n\nscuff-cas3d\n is the ability to obtain spatially-resolved \ninformation on energy and momentum fluxes. More specifically, \nyou can specify to \nscuff-neq\n a \n\nlist of evaluation points\n\nand you will get back values of the (thermally and \ntemporally averaged) Poynting flux and Maxwell stress tensor \nat each point you requested.\n\n\nIn addition to numerical output on heat-transfer rates and\nCasimir quantities, you can also request visualization outputs\nthat plot the spatial distribution of the heat or momentum flux.\n\n\nFor Casimir forces and torques, the quantities computed by \n\nscuff-neq\n are only the \nnon-equilibrium\n contributions to \nthe total force and torque---that\nis, the contributions arising from the temperature \ndifferences between individual bodies and the surrounding environment.\nTo get the total force, these must be added to the \nequilibrium\n\ncontributions, which are the Casimir forces and torques for the \ncase in which all bodies are at the temperature of the environment.\nThese contributions must be computed by doing a separate \n\nscuff-cas3d\n calculation, on the same geometry, at the \ntemperature of the external medium. \n(For heat-transfer rates there is of course no equilibrium \ncontribution, as there is no net power transfer between \nbodies at thermal equilibrium.)\n\n\nOne difference between \nscuff-cas3d\n and \nscuff-neq\n is that,\nwhereas \nscuff-cas3d\n reports only the Casimir force on one body in \na geometry (namely, the first body listed in the \n.scuffgeo\n file), \n\nscuff-neq\n reports forces and heat-transfer rates for \nall\n bodies\nin the geometry. \n[\nThe extra information would typically \nbe redundant in an equilibrium Casimir calculation, since the equilibrium \nCasimir force on the second body (in a two-body geometry) is just equal\nand opposite to the force on the first body; but in general no such \nrelation holds in the non-equilibrium case.\n]\n\n\nIn fact, the output from \nscuff-neq\n is even more detailed\nthan that: in addition to the total power/force/torque on\neach body, you also get the contributions of each individual\nsource body to those quantities. All of this means that the\noutput from \nscuff-neq\n requires some effort to interpret,\nas discussed in more detail below.\n\n\nTable of Contents\n\n\n1. What \nscuff-neq\n actually computes\n\n\n2. \nscuff-neq\n command-line options\n\n\nCommon options\n\n\nOptions specifying input fields\n\n\nOptions requesting output quantities\n\n\nOption requesting visualization output\n\n\nOptions specifying object temperatures\n\n\nOptions controlling the computation of power, force, and torque\n\n\nOther options\n\n\n\n\n\n\n3. \nscuff-neq\n output files\n\n\nThe .log file\n\n\nOutput files for spatially-integrated PFTs: The .SIFlux, .SIIntegrand, and .NEQPFT files\n\n\nOutput files for spatially-resolved PFTs: The .SRFlux, .SRIntegrand, and .PVMST files\n\n\nUnits of output quantities\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-neq\n\n\n\n\n\n\n1. What \nscuff-neq\n actually computes\n\n\nscuff-neq\n implements the\n\nFSC approach to non-equilibrium fluctuation phenomena\n,\nan algorithm for computing the thermal averages of power,\nforce, and torque (PFT) quantities in geometries consisting\nof homogeneous material bodies at various temperatures embedded\nin an finite-temperature or zero-temperature environment.\n\nscuff-neq\n can compute both\nspatially-\nresolved\n and spatially-\nintegrated\n PFT quantities.\n(Examples of spatially-resolved quantities include components\nof the average Poynting flux or Maxwell stress tensor at individual\npoints in space. Examples of spatially-integrated quantities \ninclude the total power absorbed by, or the total force or torque \non, a compact homogeneous body. Spatially-integrated quantities \nare generally obtained by integrating spatially-resolved quantities\nover closed bounding surfaces, although this is not necessarily\nthe way they are computed by \nscuff-neq\n.)\n\n\nIn general, for a geometry consisting of multiple homogeneous\nmaterial regions, PFT quantities receive contributions from source\nfluctuations in all regions and at all frequencies, and the\nthe thermal average of a PFT quantity \nQ\n may be\nwritten in the form\n\n\n\n\n \\big\\langle Q\\big\\rangle\n    = \\int_0^\\infty \\, \\sum_r \\, \\Theta(T_r,\\omega) \\Phi_r(\\omega)\\,d\\omega\n\n\nwhere \nT_r\n is the temperature of region \nr\n, \n\\Phi_r(\\omega)\n is\na temperature-independent \ngeneralized flux\n describing the \ncontribution of frequency-\n\\omega\n source fluctuations in region \nr\n,\nand \n\n\\Theta(T_r,\\omega) = \\frac{\\hbar\\omega}{e^{\\hbar \\omega/kT_r} - 1}\n\nis the Bose-Einstein factor.\n\n\nThe sum over regions \nr\n in this equation includes the\ncontributions of the external environment. To isolate these\ncontributions it is convenient to decompose \n\\langle Q \\rangle\n\ninto a sum of two terms:\n\n \\begin{array}{rcl}\n \\big\\langle Q\\big\\rangle\n&=&\n \\big\\langle Q\\big\\rangle^{\\small EQ} + \n   \\big\\langle Q\\big\\rangle^{\\small NEQ}\n\\\\[8pt]\n \\big\\langle Q\\big\\rangle^{\\small EQ}\n&\\equiv&\n  \\displaystyle{\\int_0^\\infty} \\Theta(T_{\\small env},\\omega) \n                \\sum_r \\, \\Phi_r(\\omega)\\,d\\omega \n\\\\[8pt]\n \\qquad \\big\\langle Q\\big\\rangle^{\\small NEQ} \n&\\equiv& \n  \\displaystyle{\\int_0^\\infty \\sum_s }\n  \\Big[ \\Theta(T_s, \\omega) - \\Theta(T_{\\small env},\\omega)\\Big]\n        \\Phi_s(\\omega)\\,d\\omega \n\\\\[4pt]\n&=&\n  \\displaystyle{\\int_0^\\infty \\sum_s}\n  \\Delta \\Theta(T_s, \\omega) \\Phi_s(\\omega)\\,d\\omega \n\\end{array}\n\n\n\n\n\nwhere \n\n\n\n\n \\Delta \\Theta(T_s, \\omega) \\equiv \n   \\Theta(T_s, \\omega) - \\Theta(T_{\\small env},\\omega).\n\n\n\n\n\nThe quantity \n\\langle Q\\rangle^{\\small EQ}\n\nis the average value of \nQ\n that would obtain if \nthe temperature in all material regions were equal\nto the environment temperature \nT_{\\small env}\n---that is,\nit is the \nequilibrium\n value of \n\\langle Q\\rangle\n\nat temperature \nT_{\\small env}\n. The equilibrium value\nof PFT quantities may be computed by methods that are \nless costly than \nscuff-neq\n. (For example,\nif \nQ\n is a spatially-integrated force or torque, then \n\n\\langle Q\\rangle^{\\small EQ}\n is just the equilibrium\nCasimir force, which is computed efficiently by \n\nscuff-cas3d\n.\nOn the other hand, if \nQ\n is a spatially-integrated\npower transfer quantity, then \n\n\\langle Q\\rangle^{\\small EQ}=0\n identically.)\nThus this contribution is not computed by \nscuff-neq\n.\n\n\nThe quantity \n\\langle Q\\rangle^{\\small NEQ}\n\nis the extent to which \n\\langle Q\\rangle\n\n\ndeviates\n from its equilibrium value, and\nthe sum in its definition ranges only over \nthe source bodies in the geometry, not including\nthe environment contribution.\n\n\\langle Q \\rangle^{\\small NEQ}\n is the\nquantity that is computed by \nscuff-neq\n.\n\n\n\n\n2. \nscuff-neq\n command-line options\n\n\nCommon options\n\n\nscuff-neq\n recognizes the following subset of the \n\nlist of commonly accepted options to \nscuff-em\n command-line codes\n.\n\n\n--geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache\n\n\nOptions specifying input fields\n\n\nscuff-scatter\n recognizes the following options specifying\nvarious types of incident fields. You may specify more than\none type of incident field, in which case your geometry will\nbe illuminated by the simultaneous superposition of all the \nfields you specify.\n\n\nFor more details on how to use the following options \nand the precise mathematical expressions for the fields\nthey describe,\nsee [Incident fields in \nscuff-em\n][IncidentFields].\n\n\nThese options are \n\n\nOptions requesting output quantities\n\n\n--PAbs  \n--PRad  \n--XForce  \n--YForce  \n--ZForce\n--XTorque  \n--YTorque\n--ZTorque\n\n\nSpecifies the quantities in which you are interested:\nabsorbed power (\n--PAbs\n), radiated power (\n--PRad\n),\nCartesian force components, or Cartesian torque components.\nYou may specify none, all, or any subset of these options,\nbut each option you specify will generally increase\nthe computation time (you can scrutinize the\n\n.log\n file\n to see how \nmuch\n additional time each\nextra output quantity takes to compute).\n\n\nOption requesting visualization output\n\n\n--PlotFlux\n\n\nThis option directs \nscuff-neq\n to produce visualization\nfiles (in addition to its usual output files) which may be \nopened in \ngmsh\n to visualize,\nfor each spatially-integrated PFT quantity you requested,\nthe spatial distribution of the Poynting flux or \nMaxwell stress on the surfaces of objects or \nthe displaced bounding surfaces over which those quantities\nare integrated to compute the total PFT quantity.\n\n\nOptions specifying object temperatures\n\n\n--Temperature UpperSphere 300\n--Temperature LowerSphere 100\n--Temperature ENVIRONMENT 100\n\n\n\n\nThe first two options here set the temperatures\nof the objects labeled \nUpperSphere\n and\n\nLowerSphere\n in the \n.scuffgeo\n file.\n\nTemperature specifications are interpreted in \nunits of Kelvin\n, so \n300\n corresponds to \nroom temperature.\n\n\nThe third option here sets the temperature of\nthe environment in which the objects are embedded.\n(The keywords \nMEDIUM\n and \nEXTERIOR\n may be used\nhere interchangeably with \nENVIRONMENT\n).\n\n\nNote that the temperatures of all objects, and of\nthe environment, are zero by default. This means that,\nif you request a full frequency-integrated calculation\n(which you do by omitting the \n--omega\n or \n--omegaFile\n\noption) and you do not specify any \n--temperature\n \noptions, the code will chug for a while (computing \ntemperature-independent fluxes at various frequencies)\nbefore reporting strictly zero values for all\nquantities! This is probably not what you want.\n\n\n\n\nOptions controlling the computation of power, force, and torque\n\n\n--ForceDSI\n\n\n--DSIPoints 302\n--DSIRadius 5.0\n--DSIMesh BoundingMesh.msh\n--DSIFarField\n\n\nAs detailed in \nthis paper\n, there are several\nways to compute PFTs in surface-integral formulations,\nincluding the \"displaced-surface-integral\" (DSIPFT),\n\"equivalence principle\" (EPPFT), and \"overlap\" (OPFT) \nmethods.\n\n\nBy default, \nscuff-neq\n uses different algorithms for \ndifferent cases of the PFT computation:\n\n\n\n\nPower computation (self term): EPPFT\n\n\nPower computation (non-self terms): EPPFT\n\n\nForce/Torque computation (self term): DSIPFT\n\n\nForce/Torque computation (non-self term): OPFT\n\n\n\n\nHowever, you can override this default behavior \nby specifying \n--ForceDSI\n, in which case DSIPFT\nwill be used in all cases.\n\n\nThe other options here set specific parameters \nthat are only used for DSIPFT calculations.\n\n\n--DSIMesh\n specifies the name of a mesh file\n(such as a \nGMSH\n-produced \n.msh\n file) that \ndefines the bounding surface over which the \nsurface integrals are computed. (This surface is\nautomatically displaced and rotated appropriately\nfor each object in accordance with any\ngeometrical transformations that may be \nspecified in the \n.scuffgeo\n file and/or the\n\n.trans\n file.) The surface integral is evaluated\nvia a one-point cubature over the surface of \neach panel in the bounding mesh; thus, the\nfiner the bounding mesh, the more accurate and\nthe more expensive the computation).\n\n\nIf you do not specify a \n--DSIMesh\n, then the\nsurface integral for each object is computed \nusing Lebedev cubature over a bounding sphere \ncentered at the origin of coordinates of the \nobject mesh (appropriately displaced if the \nobject has been displaced via statements in \nthe \n.scuffgeo\n or \n.trans\n files.) In this case,\nyou may use \n--DSIRadius\n and \n--DSIPoints\n to\nset the radius of this sphere (in microns) and \nthe number of Lebedev cubature points (the more \npoints, the more accurate and expensive the calculation).\nTo see the possible values that may be specified \nfor \n--DSIPoints,\n type \nscuff-neq --help.\n\n\nFinally, you may use \n--DSIFarField\n to request\nthat the Poynting vector and Maxwell tensor\non the bounding surface be computed using only\nthe far-field (radiation-zone) contributions \nof the surface currents to the fields.\n\n\nOther options\n\n\n--OmitSelfTerms\n\n\nOmit the contributions of sources in individual bodies\nto the total PFTs on those bodies themselves.\n\n\n\n\n3. \nscuff-neq\n output files\n\n\n\n\nThe \n.log\n file\n\n\nLike all command-line codes in the \nscuff-em\n suite,\n\nscuff-cas3d\n writes a \n.log\n file\n that you\ncan monitor to keep track of your calculation's progress.\n\n\nOutput files for spatially-integrated PFTs: The \n.SIFlux\n, \n.SIIntegrand\n, and \n.NEQPFT\n files\n\n\nIf you requested the computation of any spatially-integrated\nPFTs (by setting command-line options such as \n--PAbs\n or \n--YForce\n),\nyou will get back files reporting various contributions to \nthese quantities.\nTo understand what is written to these files, let \nQ_d\n be\nthe spatially-integrated PFT on a destination body \nd\n,\nand write the FSC decomposition of the thermal average\nof \nQ_d\n in the form\n\n\n\n\n \\big\\langle Q_d\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to d}(u)}_{\\texttt{.SIFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SIIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.NEQPFT}}\n\n\n\n\n\nIn this equation,\n\n\n\n\n\n\n\n\nu\n is a dimensionless frequency variable: \nu=\\omega/\\omega_0\n, \nwhere \n\\omega_0=3\\cdot 10^{14}\n rad/sec. (Thus \nu\n agrees numerically\nwith the arguments to the \n--omega\n option.)\n\n\n\n\n\n\n\n\n\\widehat\\Theta(u)\n is a dimensionless version of the usual\nBose-Einstein factor, defined by \n\\Theta(\\omega)=\\hbar \\omega_0 \\widehat\\Theta(u)\n.\n\n\n\n\n\n\n\n\n\\Delta \\widehat \\Theta_s(u)=\\widehat \\Theta_s(u) - \\widehat \\Theta_{\\small env}(u)\n \nis the difference between the dimensionless Bose-Einstein factors of source body \ns\n \nand the environment.\n\n\n\n\n\n\n\n\n\\Phi_{s\\to d}\n is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body \ns\n\nto the power, force, or torque on destination body \nd\n.\nValues of this quantity are written to the \n.SIFlux\n output\nfile.\n\n\n\n\n\n\n\n\n\\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to d}(u)\n is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body \ns\n to the PFT on destination\nbody \nd\n. \nValues of this quantity are written to the \n.SIIntegrand\n output\nfile.\n\n\n\n\n\n\nFinally, \n\\langle Q_d \\rangle\n is the total thermally-averaged\nPFT on body \nd\n. Values of this quantity are written to the \n\n.NEQPFT\n output file.\n\n\n\n\n\n\nIn all of these files, each single line corresponds to\na single frequency, a single geometric transformation,\nand a single pair of (source,destination) objects.\n\n\nAt the top of each output file you will find a file header\nexplaining the significance of each of the various\ncolumns in the file. One of the columns will be\ndescribed in the header as \n# (source object, dest object),\n\nand will take values like \n12\n, \n22\n, or \n02.\n\nThe first case (\n12\n) indicates that the data on that\nline correspond to the contributions of object 1 to the \nPFT on object 2. (The ordering of objects corresponds\nwith the order of their appearance in the \n.scuffgeo\n\nfile).  The second case (\n22\n) indicate that the data\non that line correspond to the self-contributions of \nobject 2 to its own PFT. The third case (\n02\n) \nindicates that the data on that line correspond to \nthe \ntotal\n PFT on object 2---that is, the sum of \ncontributions from all source objects.\n\n\nOutput files for spatially-resolved PFTs: The \n.SRFlux\n, \n.SRIntegrand\n, and \n.PVMST\n files\n\n\nIf you requested the computation of spatially-resolved\npower and momentum flux (by specifying the \n--EPFile\n \ncommand-line option), you will get back files reporting \nvarious contributions to these quantities. The breakdown\nhere is similar to that described above for spatially-integrated\nquantities. To understand this, let \nQ(\\mathbf{x})\n be\na spatially-resolved PFT quantity (a component \nof the Poynting vector or Maxwell stress tensor)\nat a point \n\\mathbf{x}\n. Then the thermal average of \nQ\n \nmay be written in the form\n\n\n\n\n \\big\\langle Q(\\mathbf{x})\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to\\mathbf x}(u)}_{\\texttt{.SRFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SRIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.PVMST}}\n\n\n\n\n\nIn this equation,\n\n\n\n\n\n\n\n\n\\Phi_{s\\to \\mathbf{x}}\n is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body \ns\n\nto the Poynting flux or Maxwell stress at \n\\mathbf{x}\n.\nValues of this quantity are written to the \n.SRFlux\n output\nfile.\n\n\n\n\n\n\n\n\n\\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to \\mathbf{x}}(u)\n is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body \ns\n to the Poynting flux or \nMaxwell stress at \n\\mathbf{x}\n. Values of this quantity are \nwritten to the \n.SRIntegrand\n output\nfile.\n\n\n\n\n\n\nFinally, \n\\langle Q(\\mathbf{x})\\rangle\n is the total thermally-averaged\nPoynting vector or Maxwell stress tensor at \n\\mathbf{x}\n.\nValues of this quantity are written to the \n.PVMST\n output file.\n\n\n\n\n\n\nIn all of these files, each line corresponds to\na single frequency, a single geometric transformation,\nand a single source object.\nAt the top of each output file you will find a file header\nexplaining how to interpret the various data columns\non each line.\n\n\nUnits of output quantities\n\n\n\n\n\n\nThe units of the total (frequency-integrated)\nspatially-integrated output quantities reported in\nthe \n.NEQPFT\n file are \nwatts\n for power, \nnanoNewtons\n\nfor force, and \nnanoNewtons \n\\times\n microns\n for torque.\n\n\n\n\n\n\nThe quantities in the \n.SIIntegrand\n output file\nare the PFT quantities per unit \ndimensionless\n frequency,\nso have the same units as the corresponding quantities\nin the \n.NEQPFT\n file.\n\n\n\n\n\n\nThe quantities in the \n.SIFlux\n output file are\nthe quantities per unit dimensionless frequency\nper watt of thermal energy, so these quantities\nhave the same units as the quantities in \nthe \n.NEQPFT\n and \n.SIIntegrand\n file, but divided\nby watts: thus the power flux is \ndimensionless\n,\nthe force flux has units of \nnanoNewtons / watts\n,\nand the torque flux has units of \nnanoNewtons microns/watts.\n\n\n\n\n\n\n\n\n4. Examples of calculations using \nscuff-neq\n\n\n\n\n\n\nHeat radiation from a warm sphere in a cold environment\n\n\n\n\n\n\nHeat transfer and non-equilibrium Casimir forces between warm and cold spheres\n\n\n\n\n\n\nSpatial distribution of poynting flux from a warm tip above a cold substrate", 
            "title": "scuff-neq"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#2-scuff-neq-command-line-options", 
            "text": "Common options  scuff-neq  recognizes the following subset of the  list of commonly accepted options to  scuff-em  command-line codes .  --geometry\n--EPFile\n--Omega\n--OmegaFile\n--Cache\n--ReadCache\n--WriteCache  Options specifying input fields  scuff-scatter  recognizes the following options specifying\nvarious types of incident fields. You may specify more than\none type of incident field, in which case your geometry will\nbe illuminated by the simultaneous superposition of all the \nfields you specify.  For more details on how to use the following options \nand the precise mathematical expressions for the fields\nthey describe,\nsee [Incident fields in  scuff-em ][IncidentFields].  These options are   Options requesting output quantities  --PAbs  \n--PRad  \n--XForce  \n--YForce  \n--ZForce\n--XTorque  \n--YTorque\n--ZTorque  Specifies the quantities in which you are interested:\nabsorbed power ( --PAbs ), radiated power ( --PRad ),\nCartesian force components, or Cartesian torque components.\nYou may specify none, all, or any subset of these options,\nbut each option you specify will generally increase\nthe computation time (you can scrutinize the .log  file  to see how  much  additional time each\nextra output quantity takes to compute).  Option requesting visualization output  --PlotFlux  This option directs  scuff-neq  to produce visualization\nfiles (in addition to its usual output files) which may be \nopened in  gmsh  to visualize,\nfor each spatially-integrated PFT quantity you requested,\nthe spatial distribution of the Poynting flux or \nMaxwell stress on the surfaces of objects or \nthe displaced bounding surfaces over which those quantities\nare integrated to compute the total PFT quantity.  Options specifying object temperatures  --Temperature UpperSphere 300\n--Temperature LowerSphere 100\n--Temperature ENVIRONMENT 100   The first two options here set the temperatures\nof the objects labeled  UpperSphere  and LowerSphere  in the  .scuffgeo  file. Temperature specifications are interpreted in \nunits of Kelvin , so  300  corresponds to \nroom temperature.  The third option here sets the temperature of\nthe environment in which the objects are embedded.\n(The keywords  MEDIUM  and  EXTERIOR  may be used\nhere interchangeably with  ENVIRONMENT ).  Note that the temperatures of all objects, and of\nthe environment, are zero by default. This means that,\nif you request a full frequency-integrated calculation\n(which you do by omitting the  --omega  or  --omegaFile \noption) and you do not specify any  --temperature  \noptions, the code will chug for a while (computing \ntemperature-independent fluxes at various frequencies)\nbefore reporting strictly zero values for all\nquantities! This is probably not what you want.   Options controlling the computation of power, force, and torque  --ForceDSI  --DSIPoints 302\n--DSIRadius 5.0\n--DSIMesh BoundingMesh.msh\n--DSIFarField  As detailed in  this paper , there are several\nways to compute PFTs in surface-integral formulations,\nincluding the \"displaced-surface-integral\" (DSIPFT),\n\"equivalence principle\" (EPPFT), and \"overlap\" (OPFT) \nmethods.  By default,  scuff-neq  uses different algorithms for \ndifferent cases of the PFT computation:   Power computation (self term): EPPFT  Power computation (non-self terms): EPPFT  Force/Torque computation (self term): DSIPFT  Force/Torque computation (non-self term): OPFT   However, you can override this default behavior \nby specifying  --ForceDSI , in which case DSIPFT\nwill be used in all cases.  The other options here set specific parameters \nthat are only used for DSIPFT calculations.  --DSIMesh  specifies the name of a mesh file\n(such as a  GMSH -produced  .msh  file) that \ndefines the bounding surface over which the \nsurface integrals are computed. (This surface is\nautomatically displaced and rotated appropriately\nfor each object in accordance with any\ngeometrical transformations that may be \nspecified in the  .scuffgeo  file and/or the .trans  file.) The surface integral is evaluated\nvia a one-point cubature over the surface of \neach panel in the bounding mesh; thus, the\nfiner the bounding mesh, the more accurate and\nthe more expensive the computation).  If you do not specify a  --DSIMesh , then the\nsurface integral for each object is computed \nusing Lebedev cubature over a bounding sphere \ncentered at the origin of coordinates of the \nobject mesh (appropriately displaced if the \nobject has been displaced via statements in \nthe  .scuffgeo  or  .trans  files.) In this case,\nyou may use  --DSIRadius  and  --DSIPoints  to\nset the radius of this sphere (in microns) and \nthe number of Lebedev cubature points (the more \npoints, the more accurate and expensive the calculation).\nTo see the possible values that may be specified \nfor  --DSIPoints,  type  scuff-neq --help.  Finally, you may use  --DSIFarField  to request\nthat the Poynting vector and Maxwell tensor\non the bounding surface be computed using only\nthe far-field (radiation-zone) contributions \nof the surface currents to the fields.  Other options  --OmitSelfTerms  Omit the contributions of sources in individual bodies\nto the total PFTs on those bodies themselves.", 
            "title": "2. scuff-neq command-line options"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#3-scuff-neq-output-files", 
            "text": "The  .log  file  Like all command-line codes in the  scuff-em  suite, scuff-cas3d  writes a  .log  file  that you\ncan monitor to keep track of your calculation's progress.  Output files for spatially-integrated PFTs: The  .SIFlux ,  .SIIntegrand , and  .NEQPFT  files  If you requested the computation of any spatially-integrated\nPFTs (by setting command-line options such as  --PAbs  or  --YForce ),\nyou will get back files reporting various contributions to \nthese quantities.\nTo understand what is written to these files, let  Q_d  be\nthe spatially-integrated PFT on a destination body  d ,\nand write the FSC decomposition of the thermal average\nof  Q_d  in the form    \\big\\langle Q_d\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to d}(u)}_{\\texttt{.SIFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SIIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.NEQPFT}}   In this equation,     u  is a dimensionless frequency variable:  u=\\omega/\\omega_0 , \nwhere  \\omega_0=3\\cdot 10^{14}  rad/sec. (Thus  u  agrees numerically\nwith the arguments to the  --omega  option.)     \\widehat\\Theta(u)  is a dimensionless version of the usual\nBose-Einstein factor, defined by  \\Theta(\\omega)=\\hbar \\omega_0 \\widehat\\Theta(u) .     \\Delta \\widehat \\Theta_s(u)=\\widehat \\Theta_s(u) - \\widehat \\Theta_{\\small env}(u)  \nis the difference between the dimensionless Bose-Einstein factors of source body  s  \nand the environment.     \\Phi_{s\\to d}  is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body  s \nto the power, force, or torque on destination body  d .\nValues of this quantity are written to the  .SIFlux  output\nfile.     \\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to d}(u)  is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body  s  to the PFT on destination\nbody  d . \nValues of this quantity are written to the  .SIIntegrand  output\nfile.    Finally,  \\langle Q_d \\rangle  is the total thermally-averaged\nPFT on body  d . Values of this quantity are written to the  .NEQPFT  output file.    In all of these files, each single line corresponds to\na single frequency, a single geometric transformation,\nand a single pair of (source,destination) objects.  At the top of each output file you will find a file header\nexplaining the significance of each of the various\ncolumns in the file. One of the columns will be\ndescribed in the header as  # (source object, dest object), \nand will take values like  12 ,  22 , or  02. \nThe first case ( 12 ) indicates that the data on that\nline correspond to the contributions of object 1 to the \nPFT on object 2. (The ordering of objects corresponds\nwith the order of their appearance in the  .scuffgeo \nfile).  The second case ( 22 ) indicate that the data\non that line correspond to the self-contributions of \nobject 2 to its own PFT. The third case ( 02 ) \nindicates that the data on that line correspond to \nthe  total  PFT on object 2---that is, the sum of \ncontributions from all source objects.  Output files for spatially-resolved PFTs: The  .SRFlux ,  .SRIntegrand , and  .PVMST  files  If you requested the computation of spatially-resolved\npower and momentum flux (by specifying the  --EPFile  \ncommand-line option), you will get back files reporting \nvarious contributions to these quantities. The breakdown\nhere is similar to that described above for spatially-integrated\nquantities. To understand this, let  Q(\\mathbf{x})  be\na spatially-resolved PFT quantity (a component \nof the Poynting vector or Maxwell stress tensor)\nat a point  \\mathbf{x} . Then the thermal average of  Q  \nmay be written in the form    \\big\\langle Q(\\mathbf{x})\\big\\rangle\n   = \n   \\underbrace{ \n    \\Bigg[ \\int_0^\\infty\n     \\underbrace{ \n      \\bigg\\{ \\hbar\\omega_0^2 \\sum_s \\, \\Delta \\widehat \\Theta_s(u)\n       \\underbrace{ \\Phi_{s\\to\\mathbf x}(u)}_{\\texttt{.SRFlux}}\n      \\bigg\\}\n                }_{\\texttt{.SRIntegrand}}\n    \\,\\,du \\Bigg]\n              }_{\\texttt{.PVMST}}   In this equation,     \\Phi_{s\\to \\mathbf{x}}  is the temperature-independent generalized flux\ndescribing the contributions of fluctuations in source body  s \nto the Poynting flux or Maxwell stress at  \\mathbf{x} .\nValues of this quantity are written to the  .SRFlux  output\nfile.     \\hbar\\omega_0^2 \\Delta \\widehat \\Theta_s(u) \\Phi_{s\\to \\mathbf{x}}(u)  is\nthe spectral density of temperature-weighted contributions\nfrom fluctuations in source body  s  to the Poynting flux or \nMaxwell stress at  \\mathbf{x} . Values of this quantity are \nwritten to the  .SRIntegrand  output\nfile.    Finally,  \\langle Q(\\mathbf{x})\\rangle  is the total thermally-averaged\nPoynting vector or Maxwell stress tensor at  \\mathbf{x} .\nValues of this quantity are written to the  .PVMST  output file.    In all of these files, each line corresponds to\na single frequency, a single geometric transformation,\nand a single source object.\nAt the top of each output file you will find a file header\nexplaining how to interpret the various data columns\non each line.  Units of output quantities    The units of the total (frequency-integrated)\nspatially-integrated output quantities reported in\nthe  .NEQPFT  file are  watts  for power,  nanoNewtons \nfor force, and  nanoNewtons  \\times  microns  for torque.    The quantities in the  .SIIntegrand  output file\nare the PFT quantities per unit  dimensionless  frequency,\nso have the same units as the corresponding quantities\nin the  .NEQPFT  file.    The quantities in the  .SIFlux  output file are\nthe quantities per unit dimensionless frequency\nper watt of thermal energy, so these quantities\nhave the same units as the quantities in \nthe  .NEQPFT  and  .SIIntegrand  file, but divided\nby watts: thus the power flux is  dimensionless ,\nthe force flux has units of  nanoNewtons / watts ,\nand the torque flux has units of  nanoNewtons microns/watts.", 
            "title": "3. scuff-neq output files"
        }, 
        {
            "location": "/applications/scuff-neq/scuff-neq/#4-examples-of-calculations-using-scuff-neq", 
            "text": "Heat radiation from a warm sphere in a cold environment    Heat transfer and non-equilibrium Casimir forces between warm and cold spheres    Spatial distribution of poynting flux from a warm tip above a cold substrate", 
            "title": "4. Examples of calculations using scuff-neq"
        }, 
        {
            "location": "/applications/scuff-RF/scuff-RF/", 
            "text": "scuff-RF\n\n\nThe documentation for \nscuff-RF\n has not yet been\nported from its earlier version. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "scuff-RF"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/", 
            "text": "Solving electrostatics problems with\n     \nscuff-static\n\n\n\n\n\nscuff-static\n is a tool within the\n\nscuff-em\n code suite for solving\na broad class of electrostatics problems.\n\n\nThe calculations that \nscuff-static\n can\nperform include the following:\n\n\n\n\n\n\nCompute the capacitance matrix (i.e. the self- and mutual-\ncapacitances) of a collection of conductors.\n\n\n\n\n\n\nCompute the DC polarizability of a conducting or\ndielectric body.\n\n\n\n\n\n\nCompute the electrostatic potential and field\nat arbitrary user-specified points in the vicinity\nof conducting or dielectric bodies, with the\nconductors maintained at arbitrary user-specified\npotentials and (optionally) an arbitrary user-specified\nexternal forcing field.\n\n\n\n\n\n\nCompute the \nC-matrix\n, a sort of electrostatic\nversion of the\n\n\"T-matrix\"\n\nused to characterize the scattering properties\nof bodies at nonzero frequencies. The C-matrix\nwas shown in\n\nthis paper\n\nto be related to quantum-mechanical entanglement\nentropy.\n\n\n\n\n\n\nAs a technical detail, we note that the implementation of\n\nscuff-static\n actually differs in some significant ways\nfrom the other codes in the \nscuff-em\n suite; in particular,\nas compared to the \nscuff-em\n core library,\n\nscuff-static\n uses different basis functions and a\ndifferent formulation of the boundary-element method, as\nappropriate for zero-frequency problems. (More specifically,\n\nscuff-static\n expands\nsurface electric charge densities on PEC and dielectric\nsurfaces using ``pulse'' basis functions, which are\nconstant on individual triangles and vanishing everywhere\nelse.) However, from the implementation standpoint, it\nturns out that the calculations needed to implement the\nelectrostatics calculations in \nscuff-static\n are a\nproper \nsubset\n of the calculations already implemented\nin \nscuff-em\n. Moreover, from the user's standpoint,\nthe work needed to set up a \nscuff-static\n problem\n(create surface meshes, write geometry files, etc.)\nis similar to the setup needed for the nonzero-frequency\ncodes in the \nscuff-em\n suite.\nThis is why it makes sense to package these codes together.\n\n\nHere is a brief \ntechnical memo\n\ndiscussing the implementation of \nscuff-static\n,\nincluding both the underlying BEM electrostatics formulation\nand the execution of the various types of calculation\n(capacitance, polarizability, etc.) that the code can do.\n\n\nTable of Contents\n\n\n1. \nscuff-static\n command-line options\n\n\nCommon options\n\n\nOptions requesting capacitance-matrix output\n\n\nOptions requesting polarizability output\n\n\nOptions requesting computation of electrostatic fields\n\n\n\n\n\n\n2. Examples of calculations using \nscuff-static\n\n\n\n\n\n\n\n\n\n\n1. \nscuff-static\n command-line options\n\n\nCommon options\n\n\nscuff-static\n recognizes the following subset of the\n\nlist of commonly accepted options to\n \nscuff-em\n command-line codes\n.\n\n\n--geometry\n--TransFile\n--EPFile\n--Cache\n--ReadCache\n--WriteCache\n\n\nOptions requesting capacitance-matrix output\n\n\n--CapFile    MyCapacitanceMatrix.dat\n--TransFile  MyTransFile.trans\n\n\nIf you specify a file name using \n--CapFile\n, \nscuff-static\n\nwill compute the full capacitance matrix for your geometry\nand write the data to the specified file. (The file will be\noverwritten if it already exists.)\n\n\nThe optional \n--TransFile\n option may be used to specify a\nlist of\n\ngeometrical transformations\n\nto be applied to your geometry. In this case, the full capacitance\nmatrix will be computed for each specified transformation.\n\n\nOptions requesting polarizability output\n\n\n--PolFile    MyPolFile.dat\n\n\nIf you specify a file name using \n--PolFile\n, \nscuff-static\n\nwill compute the DC polarizability of each object in your\ngeometry and write the data to the specified file. (The file\nwill be overwritten if it already exists.)\n\n\nOptions requesting computation of electrostatic fields\n\n\n--EPFile     MyEPFile\n--PlotFile   MyPlotFile.pp\n--PotFile    MyPotFile\n--ConstField [X|Y|Z]\n--PhiExt     PhiFile\n\n\nIf you specify a list of field evaluation points using\n\n--EPFile MyEPFile\n, then \nscuff-static\n will compute\nthe electrostatic potential and field at each evaluation\npoint and write the results to a file named \nMyEPFile.out\n.\n(The file will be overwritten if it already exists.)\nThe file will contain a header explaining how to interpret\nits contents.\n\n\nThe \n--PlotFile\n option may be used to request\ncreation of a \ngmsh\n visualization file plotting\nthe induced charge density on all conducting and\ndielectric surfaces in the geometry.\nIf you say \n--PlotFile MyPlotFile.pp\n, then you\nwill get a file named \nMyPlotFile.pp\n which\nmay be opened in \ngmsh\n for visualization purposes.\n\n\nBy default, all conductor surfaces will be held\nat zero potential. If you wish to set one or more\nconductor surfaces to non-zero potential, you may do this\nby saying \n--PotFile MyPotFile\n (here \"pot\" is short\nfor \"potential). \nMyPotFile\n should be simply a\nlist of (surface label, potential value) pairs,\nlike this:\n\n\nUpperSurface  1.2\n LowerSurface -3.4\n\n\nwhere \nUpperSurface\n and \nLowerSurface\n are the\nlabels you assigned to the surfaces in question\nin the \n.scuffgeo\n file. (The label is the string\nfollowing the \nOBJECT\n or \nSURFACE\n keyword\nin the \n.scuffgeo\n file.) This would set the\nconductor surface \nUpperSurface\n to a potential of\n1.2 volts and the conductor surface \nLowerSurface\n\nto a potential of -3.4 volts.\n\n\nBy default, the calculation will be performed with\nno external electrostatic field. You can say e.g.\n\n--ConstField X\n to request that the calculation\nbe performed in the presence of a constant unit-strength\nelectrostatic field pointing in the positive \nx\n\ndirection.\n\n\nAlternatively, you may use the \n--PhiExt\n option\nto specify the name of a file describing a more\ncomplicated (non-constant) external field.\n\n\n\n\n\n\n2. Examples of calculations using \nscuff-static\n\n\n\n\n\n\nPolarizability of platonic solids\n\n\n\n\n\n\nSelf- and mutual-capacitance of irregularly shaped conductors\n\n\n\n\n\n\nElectrostatic fields in the vicinity of a complicated gate array", 
            "title": "scuff-static"
        }, 
        {
            "location": "/applications/scuff-static/scuff-static/#2-examples-of-calculations-using-scuff-static", 
            "text": "Polarizability of platonic solids    Self- and mutual-capacitance of irregularly shaped conductors    Electrostatic fields in the vicinity of a complicated gate array", 
            "title": "2. Examples of calculations using scuff-static"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/", 
            "text": "Analyzing objects and geometries with \nscuff-analyze\n\n\n\nThe \nscuff-em\n suite comes with a simple standalone utility named \n\nscuff-analyze\n that you can use to gather some quick statistics on\nmeshed objects and scattering geometries described by mesh files and \ngeometry files.\n\n\nThere are several situations in which this can be useful:\n\n\n\n\nYou want to know how much memory will be occupied by the BEM matrix \n    for a geometry described by a \n.scuffgeo\n file.\n\n\nYour \n.scuffgeo\n file contains multiple \nOBJECTs\n or \nSURFACEs\n, each \n    described by a separate surface mesh and possibly displaced, rotated, \n    or periodically replicated via \nLATTICE\n statements, and you want to \n    visualize the full geometry to make sure the file you wrote actually \n    describes what you want.\n\n\nYou have created a \n.trans\n file describing a list of \n    \ngeometrical transformations\n \n    to be applied to your geometry, and before running a full calculation \n    you want to do a quick sanity check by visualizing the geometry under\n    each of your transformations to make sure they are what you intended.\n\n\nYou want to delve into the innards of \nlibscuff\n by playing around \n    with the simultaneous linear BEM system it constructs. In this case \n    you will need to know how the RWG basis functions in your surface mesh \n    are ordered within the BEM matrices and vectors, i.e. you need the \n    correspondence between rows of the BEM matrix and interior edges in your \n    surface-mesh geometry.\n\n\n\n\nTable of Contents\n\n\nscuff-analyze Command-Line Options\n\n\nOptions specifying the file to analyze\n\n\nOption specifying a list of geometrical transformations\n\n\nOptions controlling the generation of visualization files\n\n\n\n\n\n\nscuff-analyze console output\n\n\nRunning scuff-analyze on a geometry file\n\n\nRunning scuff-analyze on a mesh file\n\n\n\n\n\n\nViewing gmsh visualization files\n\n\ngmsh Visualization of Full Geometries\n\n\ngmsh Visualization of Extended Geometries: The --neighbors Option\n\n\ngmsh Visualization of Individual Meshes\n\n\n\n\n\n\nViewing gnuplot visualization files\n\n\ngnuplot Visualization of Full Geometries\n\n\ngnuplot Visualization of Individual Meshes\n\n\n\n\n\n\n\n\n\n\n\n\nscuff-analyze Command-Line Options\n\n\nOptions specifying the file to analyze\n\n\n    --geometry MyGeometry.scuffgeo\n\n\n\n\nAnalyze a full geometry described by a\n\nscuff-em\n geometry file\n.\n\n\n    --mesh     MyObject.msh\n    --meshFile MyObject.mesh\n\n\n\n\nAnalyze a single object described by a surface mesh. (The\ntwo options are synonymous.)\n\n\nOption specifying a list of geometrical transformations\n\n\n    --TransFile MyTransFile.trans\n\n\n\n\nSpecify a list of \n\ngeometrical transformations\n \nto be applied to a geometry. This is useful for \n(a)\n checking\nthat your transformation file can be properly parsed by \n\nscuff-em\n, and \n(b)\n producing a visualization output file to \nconfirm that the transformations you got are the ones you wanted.\n\n\nOptions controlling the generation of visualization files\n\n\n    --WriteGMSHFiles \n\n\n\n\nWrite visualization files suitable for viewing with \n\ngmsh\n.\n\n\n    --WriteGMSHLabels \n\n\n\n\nAppend visualization data to \ngmsh\n visualization files that \nprovides information on how the geometry is represented internally \nwithin \nscuff-em\n. This option is automatically enabled when the \n\n--mesh\n option is used.\n\n\n    --Neighbors nn\n\n\n\n\n(For periodically repeated geometries only). If this option is specified, \nthe \ngmsh\n visualization files will include the first \nnn\n neighboring \ncells in all directions. (For example, \n--Neighbors 1\n will produce a \nplot showing the innermost 3x3 grid of unit cells, while \n--Neighbors 2\n \nwill show the innermost 5x5 grid of cells.) This is useful for visualizing \nhow your unit-cell meshes fit together with their images across unit-cell \nboundaries to comprise a periodically replicated lattice.\n\n\n    --EPFile MyEPFile\n\n\n\n\nThis option allows you to specify a list of individual points\nto be plotted in the visualization file together with the\nmeshed surfaces in your geometry. This is useful for double-checking\nthat the points at which you are requesting spatially-resolved\ninformation from a \nscuff-em\n code (for example, scattered\nand total field components in \n\nscuff-scatter\n,\nor Casimir-Polder potentials in\n\nscuff-caspol\n\nspatially-resolved Poynting flux in\n\nscuff-neq\n) are \nactually the points you wanted. The file \nMyEPFile\n\nis the same file you specify for the \n--EPFile\n option\nto any other \nscuff-em\n code: it\nshould contain 3 numbers per line (the cartesian \ncoordinates of the points).\n\n\n    --WriteGnuplotFiles \n\n\n\n\nWrite visualization files suitable for viewing with \n\ngnuplot\n.\n\n\n\n\nscuff-analyze\n console output\n\n\nRunning \nscuff-analyze\n on a geometry file\n\n\nRunning \nscuff-analyze\n on a typical \nscuff-em\n geometry file \nyields console output that looks like this:\n\n\n      % scuff-analyze --geometry CylinderRing.scuffgeo\n\n         ***********************************************\n         *  GEOMETRY CylinderRing.scuffgeo \n         ***********************************************\n               2 objects\n           22548 total basis functions\n          Size of BEM matrix: 3.84 GB\n\n         ***********************************************\n         *  OBJECT 0: Label = Ring\n         ***********************************************\n          Meshfile: Ring.msh \n          7360 panels\n          11040 total edges\n          22080 total basis functions\n          11040 interior edges\n          3680 total vertices (after eliminating 0 redundant vertices)\n          3680 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                       3680 -          11040 +   7360 = 0\n\n          Total area: 6.1547934e+00 \n          Avg area: 8.3624910e-04 // sqrt(Avg Area)=2.8917972e-02\n\n         ***********************************************\n         *  OBJECT 1: Label = Cylinder\n         ***********************************************\n          Meshfile: Cylinder.msh \n          156 panels\n          234 total edges\n          468 total basis functions\n          234 interior edges\n          80 total vertices (after eliminating 0 redundant vertices)\n          80 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                         80 -            234 +    156 = 2\n\n          Total area: 6.6885562e-01 \n          Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n         Thank you for your support.\n\n\n\n\nRunning \nscuff-analyze\n on a mesh file\n\n\nYou can also run \nscuff-analyze\n on a mesh file describing just a \nsingle object:\n\n\n      % scuff-analyze --mesh Cylinder.msh\n\n         Meshfile: Cylinder.msh \n         156 panels\n         234 total edges\n         234 total basis functions\n         234 interior edges\n         80 total vertices (after eliminating 0 redundant vertices)\n         80 interior vertices\n         0 boundary contours\n\n         interior vertices - interior edges + panels = euler characteristic\n                        80 -            234 +    156 = 2\n\n         Total area: 6.6885562e-01 \n         Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n        Thank you for your support.\n\n\n\n\nOne use of \nscuff-analyze\n is to generate visualization files that \nmay be opened in \ngnuplot\n \nor \ngmsh.\n In addition to showing you what \nyour geometry looks like, these files will also indicate the internal \nnumbering that \nscuff-em\n uses for the vertices, panels, and edges \nin the surface discretization. This information can be useful, for \nexample, in interpreting the BEM matrices exported by passing the \n\n--ExportBEMMatrix\n option to various \nscuff-em\n programs.\n\n\n\n\nViewing \ngmsh\n visualization files\n\n\nThe \ngmsh\n visualization files generated by \nscuff-analyze\n \ncontain different information depending on whether you use the \n\n--geometry\n option to specify a full \nscuff-em\n geometry \n(a \n.scuffgeo\n file) or the \n\n--mesh\n option to specify a single surface mesh for an \nindividual object (as described by a \ngmsh\n \n.msh\n file or \nother mesh file format).\n\n\ngmsh\n Visualization of Full Geometries\n\n\nIf you specify the \n--geometry\n option, the resulting \n.pp\n file \nwill contain only a single \"view\" giving you a graphical \nrepresentation of the various objects in the geometry. This is \nconvenient for confirming that objects are positioned relative \nto one another in the way that you intended. For instance, \nconsider the following geometry file (called \nSphereCube.scuffgeo\n), \nwhich describes a geometry involving a sphere and a cube, with the \ncube displaced and rotated vis-a-vis the base position and orientation \ndescribed by its \n.msh\n file:\n\n\n OBJECT TheSphere\n    MESHFILE  Sphere.msh\n    MATERIAL  Silicon\n ENDOBJECT\n\n OBJECT TheCube\n    MESHFILE  Cube.msh\n    MATERIAL  Teflon\n    ROTATED   45 ABOUT 0 0 1\n    DISPLACED 0.9 1.1 2.3\n ENDOBJECT\n\n\n\n\nTo visualize this configuration of objects, from the command line we can say\n\n\n    % scuff-analyze --geometry SphereCube.scuffgeo --WriteGMSHFiles\n    % gmsh SphereCube.pp\n\n\n\n\nThe first command here creates a file called \nSphereCube.pp\n (as well \nas a bunch of console output, which we omit), while the second line \nopens this file in \ngmsh\n, yielding this:\n\n\n\n\ngmsh\n Visualization of Extended Geometries: The \n--neighbors\n Option\n\n\nHere's an example in which we have a periodically extended geometry \nand we'd like to visualize how the unit cell described by our \n\n.scuffgeo\n file fits together with its images across the unit-cell \nboundaries. This geometry describes an array of nanospheres atop a \nsilicon substrate.\n\n\nThe \n.scuffgeo\n file:\n\n\nLATTICE \n    VECTOR 2.4 0.0 0.0 \n    VECTOR 0.0 2.4 0.0\nENDLATTICE \n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION LowerHalfSpace MATERIAL Silicon\nREGION SphereInterior MATERIAL Gold\n\nSURFACE Sphere\n    MESHFILE Sphere.msh\n    DISPLACED 1.2 1.2 1.85\n    REGIONS UpperHalfSpace SphereInterior\nENDOBJECT\n\n\nSURFACE Substrate\n    MESHFILE Square.msh\n    REGIONS UpperHalfSpace LowerHalfSpace\nENDOBJECT\n\n\n\n\nTo visualize the unit cell together with a few surrounding lattice \ncells, we use the \n--Neighbors\n option to \nscuff-analyze\n:\n\n\n    % scuff-analyze --geometry SphereSubstrateArray.scuffgeo --WriteGMSHFiles --Neigbors 2\n    % gmsh SphereSubstrateArray.pp\n\n\n\n\n\n\nNotice that the visualization plot here includes extra panels hanging off \ntwo of the four edges of each lattice cell. These are called \nstraddlers;\n \nthey are not present in the actual \n.msh\n file specified in your \n.scuffgeo\n \nfile, but are automatically added internally by \nscuff-em\n for contiguous \nsurfaces extending beyond the confines of the unit cell.\n\n\ngmsh Visualization of Individual Meshes\n\n\nOn the other hand, if you specify the \n--mesh\n option to \nscuff-analyze\n, \nthen the \n.pp\n files generated by the \n--WriteGMSHFiles\n option will contain \nvarious additional information. For example, suppose we wanted to get some \nmore information on the sphere mesh from the previous example:\n\n\n    % scuff-analyze --mesh Sphere.msh --WriteGMSHFiles\n    % gmsh Sphere.pp\n\n\n\n\nThe first command here creates a \ngmsh\n post-processing file called \n\nSphere.pp\n which contains several \"views,\" each providing a different \nset of information on how \nscuff-em\n internally processes the surface \nmesh. Within the gmsh GUI, you can zoom in and out, rotate and translate \nthe object, and click the little yellow squares in the menu window to \nturn on and off the display of individual views. (For clarity, the \nscreenshot below was generated using a more coarsely-meshed sphere than \nin the screenshot above.)\n\n\n\n\nThe first view here (the one named \"Sphere\") just plots the triangular \npanels that define the surface mesh. This is the same information that \nyou would get from running \nscuff-analyze\n with the \n--geometry\n option.\n\n\nThe remaining views contain the following additional information. (This \ninformation is probably only of interest to people who want to hack about \nin the internals of \nlibscuff\n and need to know the details of the internal \nrepresentation of objects and BEM quantities.)\n\n\n\n\nThe direction of the surface normal to each panel as read in from the \n.msh\n file.\nAt present this information is not used for anything inside \nlibscuff\n, because \nscuff-em\n\nmakes its own overriding decision about how to orient the surface normal.\n\n\nThe (zero-based) indices of the panels.\n\n\nThe (zero-based) indices of the internal edges. The internal edge whose \n    index is \nn\n corresponds to the \nn\nth RWG basis function for this object \n    and hence to the \nn\nth surface-current expansion coefficient (for PEC \n    objects) or the \n2n\nth and \n2n+1\nth surface-current expansion coefficients \n    (for non-PEC objects) in the portion of the BEM solution vector \n    corresponding to the object in question.\n\n\nThe (zero-based) indices of the exterior edges.\n\n\nThe (zero-based) indices of the vertices.\n\n\n\n\n\n\nViewing \ngnuplot\n visualization files\n\n\ngnuplot\n Visualization of Full Geometries\n\n\nRunning \nscuff-analyze\n with the \n--WriteGNUPLOTFiles\n option will \ncreate a file called \nMyGeometry.gp\n (where \nMyGeometry.scuffgeo\n was \nthe geometry file specified using the \n--geometry\n option) which you \ncan visualize in \ngnuplot\n using the command \nsplot 'MyGeometry.gp' w lp.\n\n\n    % scuff-analyze --geometry SphereCube.scuffgeo --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot\n splot 'SphereCube.gp' w lp\n\n\n\n\n\n\ngnuplot\n Visualization of Individual Meshes\n\n\nRunning \nscuff-analyze\n with the \n--WriteGNUPLOTFiles\n option will \ncreate a file called \nMyObject.gp\n (where \nMyObject.msh\n was the mesh \nfile specified using the \n--mesh\n option), together with a bunch of \nauxiliary files named, for instance, \nMyObject.gp.edgelabels\n. \nThese auxiliary files contain \ngnuplot\n commands to superpose \nvarious types of additional information atop the basic plots, and \nshould be used with the \nload\n command, like this:\n\n\nbash\n    % scuff-analyze --mesh Sphere.msh --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot\n load 'Sphere.gp.edgelabels'\n    gnuplot\n splot 'Sphere.gp' w lp\nbash", 
            "title": "scuff-analyze"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#options-specifying-the-file-to-analyze", 
            "text": "--geometry MyGeometry.scuffgeo  Analyze a full geometry described by a scuff-em  geometry file .      --mesh     MyObject.msh\n    --meshFile MyObject.mesh  Analyze a single object described by a surface mesh. (The\ntwo options are synonymous.)", 
            "title": "Options specifying the file to analyze"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#option-specifying-a-list-of-geometrical-transformations", 
            "text": "--TransFile MyTransFile.trans  Specify a list of  geometrical transformations  \nto be applied to a geometry. This is useful for  (a)  checking\nthat your transformation file can be properly parsed by  scuff-em , and  (b)  producing a visualization output file to \nconfirm that the transformations you got are the ones you wanted.", 
            "title": "Option specifying a list of geometrical transformations"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#options-controlling-the-generation-of-visualization-files", 
            "text": "--WriteGMSHFiles   Write visualization files suitable for viewing with  gmsh .      --WriteGMSHLabels   Append visualization data to  gmsh  visualization files that \nprovides information on how the geometry is represented internally \nwithin  scuff-em . This option is automatically enabled when the  --mesh  option is used.      --Neighbors nn  (For periodically repeated geometries only). If this option is specified, \nthe  gmsh  visualization files will include the first  nn  neighboring \ncells in all directions. (For example,  --Neighbors 1  will produce a \nplot showing the innermost 3x3 grid of unit cells, while  --Neighbors 2  \nwill show the innermost 5x5 grid of cells.) This is useful for visualizing \nhow your unit-cell meshes fit together with their images across unit-cell \nboundaries to comprise a periodically replicated lattice.      --EPFile MyEPFile  This option allows you to specify a list of individual points\nto be plotted in the visualization file together with the\nmeshed surfaces in your geometry. This is useful for double-checking\nthat the points at which you are requesting spatially-resolved\ninformation from a  scuff-em  code (for example, scattered\nand total field components in  scuff-scatter ,\nor Casimir-Polder potentials in scuff-caspol \nspatially-resolved Poynting flux in scuff-neq ) are \nactually the points you wanted. The file  MyEPFile \nis the same file you specify for the  --EPFile  option\nto any other  scuff-em  code: it\nshould contain 3 numbers per line (the cartesian \ncoordinates of the points).      --WriteGnuplotFiles   Write visualization files suitable for viewing with  gnuplot .", 
            "title": "Options controlling the generation of visualization files"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#scuff-analyze-console-output", 
            "text": "Running  scuff-analyze  on a geometry file  Running  scuff-analyze  on a typical  scuff-em  geometry file \nyields console output that looks like this:        % scuff-analyze --geometry CylinderRing.scuffgeo\n\n         ***********************************************\n         *  GEOMETRY CylinderRing.scuffgeo \n         ***********************************************\n               2 objects\n           22548 total basis functions\n          Size of BEM matrix: 3.84 GB\n\n         ***********************************************\n         *  OBJECT 0: Label = Ring\n         ***********************************************\n          Meshfile: Ring.msh \n          7360 panels\n          11040 total edges\n          22080 total basis functions\n          11040 interior edges\n          3680 total vertices (after eliminating 0 redundant vertices)\n          3680 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                       3680 -          11040 +   7360 = 0\n\n          Total area: 6.1547934e+00 \n          Avg area: 8.3624910e-04 // sqrt(Avg Area)=2.8917972e-02\n\n         ***********************************************\n         *  OBJECT 1: Label = Cylinder\n         ***********************************************\n          Meshfile: Cylinder.msh \n          156 panels\n          234 total edges\n          468 total basis functions\n          234 interior edges\n          80 total vertices (after eliminating 0 redundant vertices)\n          80 interior vertices\n          0 boundary contours\n\n          interior vertices - interior edges + panels = euler characteristic\n                         80 -            234 +    156 = 2\n\n          Total area: 6.6885562e-01 \n          Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n         Thank you for your support.  Running  scuff-analyze  on a mesh file  You can also run  scuff-analyze  on a mesh file describing just a \nsingle object:        % scuff-analyze --mesh Cylinder.msh\n\n         Meshfile: Cylinder.msh \n         156 panels\n         234 total edges\n         234 total basis functions\n         234 interior edges\n         80 total vertices (after eliminating 0 redundant vertices)\n         80 interior vertices\n         0 boundary contours\n\n         interior vertices - interior edges + panels = euler characteristic\n                        80 -            234 +    156 = 2\n\n         Total area: 6.6885562e-01 \n         Avg area: 4.2875360e-03 // sqrt(Avg Area)=6.5479279e-02\n\n        Thank you for your support.  One use of  scuff-analyze  is to generate visualization files that \nmay be opened in  gnuplot  \nor  gmsh.  In addition to showing you what \nyour geometry looks like, these files will also indicate the internal \nnumbering that  scuff-em  uses for the vertices, panels, and edges \nin the surface discretization. This information can be useful, for \nexample, in interpreting the BEM matrices exported by passing the  --ExportBEMMatrix  option to various  scuff-em  programs.", 
            "title": "scuff-analyze console output"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#viewing-gmsh-visualization-files", 
            "text": "The  gmsh  visualization files generated by  scuff-analyze  \ncontain different information depending on whether you use the  --geometry  option to specify a full  scuff-em  geometry \n(a  .scuffgeo  file) or the  --mesh  option to specify a single surface mesh for an \nindividual object (as described by a  gmsh   .msh  file or \nother mesh file format).  gmsh  Visualization of Full Geometries  If you specify the  --geometry  option, the resulting  .pp  file \nwill contain only a single \"view\" giving you a graphical \nrepresentation of the various objects in the geometry. This is \nconvenient for confirming that objects are positioned relative \nto one another in the way that you intended. For instance, \nconsider the following geometry file (called  SphereCube.scuffgeo ), \nwhich describes a geometry involving a sphere and a cube, with the \ncube displaced and rotated vis-a-vis the base position and orientation \ndescribed by its  .msh  file:   OBJECT TheSphere\n    MESHFILE  Sphere.msh\n    MATERIAL  Silicon\n ENDOBJECT\n\n OBJECT TheCube\n    MESHFILE  Cube.msh\n    MATERIAL  Teflon\n    ROTATED   45 ABOUT 0 0 1\n    DISPLACED 0.9 1.1 2.3\n ENDOBJECT  To visualize this configuration of objects, from the command line we can say      % scuff-analyze --geometry SphereCube.scuffgeo --WriteGMSHFiles\n    % gmsh SphereCube.pp  The first command here creates a file called  SphereCube.pp  (as well \nas a bunch of console output, which we omit), while the second line \nopens this file in  gmsh , yielding this:   gmsh  Visualization of Extended Geometries: The  --neighbors  Option  Here's an example in which we have a periodically extended geometry \nand we'd like to visualize how the unit cell described by our  .scuffgeo  file fits together with its images across the unit-cell \nboundaries. This geometry describes an array of nanospheres atop a \nsilicon substrate.  The  .scuffgeo  file:  LATTICE \n    VECTOR 2.4 0.0 0.0 \n    VECTOR 0.0 2.4 0.0\nENDLATTICE \n\nREGION UpperHalfSpace MATERIAL Vacuum\nREGION LowerHalfSpace MATERIAL Silicon\nREGION SphereInterior MATERIAL Gold\n\nSURFACE Sphere\n    MESHFILE Sphere.msh\n    DISPLACED 1.2 1.2 1.85\n    REGIONS UpperHalfSpace SphereInterior\nENDOBJECT\n\n\nSURFACE Substrate\n    MESHFILE Square.msh\n    REGIONS UpperHalfSpace LowerHalfSpace\nENDOBJECT  To visualize the unit cell together with a few surrounding lattice \ncells, we use the  --Neighbors  option to  scuff-analyze :      % scuff-analyze --geometry SphereSubstrateArray.scuffgeo --WriteGMSHFiles --Neigbors 2\n    % gmsh SphereSubstrateArray.pp   Notice that the visualization plot here includes extra panels hanging off \ntwo of the four edges of each lattice cell. These are called  straddlers;  \nthey are not present in the actual  .msh  file specified in your  .scuffgeo  \nfile, but are automatically added internally by  scuff-em  for contiguous \nsurfaces extending beyond the confines of the unit cell.  gmsh Visualization of Individual Meshes  On the other hand, if you specify the  --mesh  option to  scuff-analyze , \nthen the  .pp  files generated by the  --WriteGMSHFiles  option will contain \nvarious additional information. For example, suppose we wanted to get some \nmore information on the sphere mesh from the previous example:      % scuff-analyze --mesh Sphere.msh --WriteGMSHFiles\n    % gmsh Sphere.pp  The first command here creates a  gmsh  post-processing file called  Sphere.pp  which contains several \"views,\" each providing a different \nset of information on how  scuff-em  internally processes the surface \nmesh. Within the gmsh GUI, you can zoom in and out, rotate and translate \nthe object, and click the little yellow squares in the menu window to \nturn on and off the display of individual views. (For clarity, the \nscreenshot below was generated using a more coarsely-meshed sphere than \nin the screenshot above.)   The first view here (the one named \"Sphere\") just plots the triangular \npanels that define the surface mesh. This is the same information that \nyou would get from running  scuff-analyze  with the  --geometry  option.  The remaining views contain the following additional information. (This \ninformation is probably only of interest to people who want to hack about \nin the internals of  libscuff  and need to know the details of the internal \nrepresentation of objects and BEM quantities.)   The direction of the surface normal to each panel as read in from the  .msh  file.\nAt present this information is not used for anything inside  libscuff , because  scuff-em \nmakes its own overriding decision about how to orient the surface normal.  The (zero-based) indices of the panels.  The (zero-based) indices of the internal edges. The internal edge whose \n    index is  n  corresponds to the  n th RWG basis function for this object \n    and hence to the  n th surface-current expansion coefficient (for PEC \n    objects) or the  2n th and  2n+1 th surface-current expansion coefficients \n    (for non-PEC objects) in the portion of the BEM solution vector \n    corresponding to the object in question.  The (zero-based) indices of the exterior edges.  The (zero-based) indices of the vertices.", 
            "title": "Viewing gmsh visualization files"
        }, 
        {
            "location": "/applications/scuff-analyze/scuff-analyze/#viewing-gnuplot-visualization-files", 
            "text": "gnuplot  Visualization of Full Geometries  Running  scuff-analyze  with the  --WriteGNUPLOTFiles  option will \ncreate a file called  MyGeometry.gp  (where  MyGeometry.scuffgeo  was \nthe geometry file specified using the  --geometry  option) which you \ncan visualize in  gnuplot  using the command  splot 'MyGeometry.gp' w lp.      % scuff-analyze --geometry SphereCube.scuffgeo --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot  splot 'SphereCube.gp' w lp   gnuplot  Visualization of Individual Meshes  Running  scuff-analyze  with the  --WriteGNUPLOTFiles  option will \ncreate a file called  MyObject.gp  (where  MyObject.msh  was the mesh \nfile specified using the  --mesh  option), together with a bunch of \nauxiliary files named, for instance,  MyObject.gp.edgelabels . \nThese auxiliary files contain  gnuplot  commands to superpose \nvarious types of additional information atop the basic plots, and \nshould be used with the  load  command, like this:  bash\n    % scuff-analyze --mesh Sphere.msh --WriteGNUPLOTFiles\n    % gnuplot\n    gnuplot  load 'Sphere.gp.edgelabels'\n    gnuplot  splot 'Sphere.gp' w lp bash", 
            "title": "Viewing gnuplot visualization files"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/", 
            "text": "Integrating frequency-dependent data with \nscuff-integrate\n\n\n\nMany application codes in the \nscuff-em\n suite compute\nphysical quantities defined by definite integrals over real\nor imaginary frequencies, with the numerical value of the\nintegrand at each point obtained by solving individual\n\nscuff-em\n scattering problems at that frequency. For example,\n\n\n\n\n \nscuff-cas3d\n \n and \n\n \nscuff-caspol\n \n\ncompute zero-temperature Casimir quantities by integrating \ncontributions from imaginary frequencies \n\\xi\n:\n\n\n\n\n\n\n\n\n\n Q = \\int_0^\\infty I(\\xi) \\, d\\xi \n\n\n\n\nHere \nQ\n is a zero-temperature Casimir energy/force/torque (\nscuff-cas3d\n)\nor Casimir-Polder potential (\nscuff-caspol\n) and \nI(\\xi)\n is the \nspectral density of contributions to \nQ\n from fluctuations at \nimaginary frequency \n\\xi\n, which may be obtained by solving\n\nscuff-em\n scattering calculations at imaginary frequency \n\\xi\n.\n\n\n\n\n \nscuff-neq\n \n computes\nthe total rate of energy or momentum transfer\nfrom a source body \ns\n to a destination body \nd\n \nby integrating contributions from real frequencies \n\\omega\n:\n\n\n\n\n\n\n\n\n\n Q^{s\\rightarrow d}\n   = \\int_0^\\infty\n     \\Big[ \\Theta(T_s,\\omega) - \\Theta(T_\\text{env},\\omega) \\Big]\n     \\Phi^{s\\rightarrow d}(\\omega) \\, d\\omega\n   \\qquad (1)\n\n\n\n\nHere \nQ^{s\\rightarrow d}\n is the contribution of body \ns\n to\nquantity \nQ\n (a heat-transfer rate, force, or torque) for body \nd\n,\n\n\\Theta(T,\\omega)=\\frac{\\hbar\\omega}{e^{\\hbar\\omega/kT}-1}\n\nis the Bose-Einstein statistical factor, \nT_s\n and \nT_\\text{env}\n\nare the temperatures of the source body and the environment,\nand \n\\Phi(\\omega)\n is a \"generalized flux\" quantity that may be \ncomputed by solving \nscuff-em\n scattering calculations\nat frequency \n\\omega\n.\n\n\nThe integrals over \n\\xi\n and \n\\omega\n are evaluated by\nnumerical cubature---that is, as weighted sums of integrand\nsamples. In a perfect world, it would be possible for \n\nscuff-em\n application codes to choose appropriate \nintegration strategies automatically, hiding these details\nfrom the user and reporting just the frequency-integrated\nquantities \nQ\n. This is in fact the strategy that was\nadopted in early incarnations of the \nscuff-em\n codes.\n\n\nIn the real world, however, the behavior of integrand \nfunctions like \nI(\\xi)\n and \n\\Phi(\\omega)\n varies widely\nfrom problem to problem, depending on factors such\nas the shapes and materials of bodies in the scattering\ngeometry and the quantity being computed. For this reason,\nit's hard for \nscuff-em\n to make intelligent automatic\nchoices of integration strategies, and attempts to do so \nwithout user input may result in misleading or even\nflat-out incorrect data.\n\n\nFor this reason, the modern approach to frequency integration\nin \nscuff-em\n is to ask users to define a\nlist of frequencies at which to sample the integrand; this\nlist is passed to \nscuff-em\n application codes using the \n\n--XiFile\n or \n--OmegaFile\n command-line options, and in \nresponse the code produces an output file reporting values\nof the integrand at the specified points. The frequency \nintegral may then be calculated as as post-processing step\nusing the information reported in the frequency-resolved\ndata files, and this is the task for which \nscuff-integrate\n\nexists.\n\n\nTable of Contents\n\n\nscuff-integrate\n tutorial walkthrough\n\n\nIntegrating a single function of frequency\n\n\nIntegrating multiple functions of frequency\n\n\nGiving names to data columns\n\n\nIntegrating functions of frequency and other parameters\n\n\nIntegrating scuff-neq data\n\n\n\n\n\n\nscuff-integrate\n Command-Line Reference\n\n\nOnly numerical data columns are counted as columns\n\n\n\n\n\n\nscuff-integrate\n tutorial walkthrough\n\n\nIntegrating a single function of frequency\n\n\nThe simplest usage of \nscuff-integrate\n is to integrate\na single function of frequency \nf(x)\n\n[where \nx\n denotes either real or imaginary frequency].\nSuppose we have a file called \nfData\n in which\nare tabulated numerical pairs \n(x_n, f_n)\n, \nn=1,2,\\cdots,N\n, \nwhere \nf_n=f(x_n)\n:\n\n\nx1 f1 \nx2 f2 \n...\nxN fN \n\n\n\n\nThen to compute \n\\int_{x_1}^{x_N} f(x) \\, dx\n we can just \ngo like this:\n\n\n% scuff-integrate --datafile fData --freqColumn 1 --dataColumn 2\n\n\n\n\nThis will produce a file named \nfData.Integrated\n containing\na single line of data: the integrated value of \nf\n.\n\n\nIf the frequency and/or integrand values are printed in\ndifferent columns of the data file, just adjust the \n\n--freqColumn\n and \n--dataColumn\n options accordingly. For\nexample, if the data file looks like this: \n\n\nstuff\n \nstuff\n x1 \nstuff\n \nstuff\n f1 \nstuff\n ...\n\nstuff\n \nstuff\n x2 \nstuff\n \nstuff\n f2 \nstuff\n ...\n...\n\nstuff\n \nstuff\n xN \nstuff\n \nstuff\n fN \nstuff\n ...\n\n\n\n\nyou would use \n--freqcolumn 3 --datacolumn 6.\n \nIn this case, the content of the other columns (the \nstuff\n\nin the above snippet) is ignored.\n\n\nIntegrating multiple functions of frequency\n\n\nMore generally, frequency-resolved data files produced by\n\nscuff-em\n codes will contain data on multiple functions\n\nf_1, \\cdots, f_p(x)\n. (For example, in \nscuff-cas3d\n \neach line of the data file may contain data on both\nCasimir energy and Casimir force.)\n\n\nYou can integrate all of these\nat once simply by specifying multiple \n--dataColumn\n\noptions. For example, if you have functions \nf\n and \ng\n\nand you have a file named \nfgData\n with the format\n\n\nx1 f1 g1 \nx2 f2 g2 \n...\nxN fN gN \n\n\n\n\nthen you can say\n\n\n% scuff-integrate --datafile fgData --freqColumn 1 --dataColumn 2 --datacolumn 3\n\n\n\n\nand the resulting output file \nfgData.Integrated\n\nwill report values for both \n\\int f(x)\\,dx\n and \n\\int g(x)\\,dx\n.\n\n\nGiving names to data columns\n\n\nIn the legend at the top of the \n.Integrated\n output file,\nthe values of the various integrated functions will by default\nbe labeled \ndata 0\n, \ndata 1\n, etc. If you want to give more\ndescriptive names, just follow each \n--dataColumn\n option\nwith a \n--dataName\n option. \n\n\nFor example, if your force and torque\nintegrands are respectively reported on columns 8 and 11\nof your data file, say \n\n--dataColumn 8 --dataName Force --dataColumn 11 --dataName Torque\n.\n\n\nIntegrating functions of frequency and other parameters\n\n\nIn many cases we will have functions that depend on various\nparameters beside frequency. (In \nscuff-cas3d\n, for example,\nwe might compute Casimir forces between particles separated\nby various distances \nd\n, so the integrand function may \nbe thought of as a function \nf(d,x)\n of both distance and frequency.)\n\n\nFor example, suppose your data file is called \npxfgData\n and \nlooks something like\n\n\np1 x1 f11 g11\np1 x2 f12 g12\n....\np1 xN f1N g1N\np2 x1 f21 g21\np2 x2 f22 g22\n....\np2 xN f2N g2N\n....\npM xN fMN gMN\n\n\n\n\nwhere \np1,\n \np2,\n ..., \npM\n denote \nM\n distinct values\nof some parameter \np\n and \nfmn,gmn\n are the numerical\nintegrand values \nf(p_m, x_n), g(p_m,x_n)\n. \nIn this case you can't simply say\n\n--freqColumn2 --dataColumn 3 --dataColumn 4,\n because then\ndata for all parameter values will be mashed all together and \nintegrated as a single function of frequency, yielding nonsense.\n\n\nInstead, you handle this situation by specifying the additional\ncommand-line parameter \n--tagColumn 1\n to tell \nscuff-integrate\n\nto interpret data lines with different values in column 1 \nas samples of different functions:\n\n\n% scuff-integrate --datafile pxfgData --tagcolumn 1 --freqColumn 2 --dataColumn 3 --dataColumn 4\n\n\n\n\nIn this case, the output file \npxfgData.Integrated\n will report\n\nx\n-integrated values of \nf\n and \ng\n separately for each value of\n\np\n.\n\n\nIf your integrands depend on multiple parameters \n(p,q,\\cdots)\n,\nyou may specify multiple \n--tagColumn\n options to specify\nthe columns in which values of the various parameters live.\nThen each line of the \n.Integrated\n output file will report\n\nx\n-integrated values of all functions for a single tuple of \nparameter values \n(p,q,\\cdots).\n\n\n\n\nIntegrating \nscuff-neq\n data\n\n\nscuff-integrate\n incorporates special functionality\nfor handling the particular frequency-resolved data files\nproduced by \nscuff-neq\n.\nIn this case, for a geometry containing \nN\n bodies,\neach line of the \n.SIFlux\n output file is tagged with\na data field of the form \nsd\n (where \ns\n and \nd\n are\nintegers between 1 and \nN\n) to label the contributions\nof sources in body \ns\n to the power, force, and/or torque\n(PFT) on body \nd\n. (For example, lines for which this field reads\n\n13\n give contributions of body 1 to the PFT for body 3).\nThe actual data quantities reported in the\n\n.SIFlux\n file are the generalized fluxes \n\\Phi^{s\\rightarrow d}\n\nin equation (1) above, and to evaluate the \n\\omega\n integral\nhere we need to know the temperatures of the environment\nand of all bodies in the geometry, which enter through \nthe Bose-Einstein factors in (1).\n\n\nTo handle these complications, \nscuff-integrate\n\nsupports the following additional command-line options:\n\n\n\n\n\n\n--sdColumn xx\n \n\n\nSpecifies that the \nsd\n indicator field appears on\ncolumn \nxx\n of the data file. (The default is \n--sdColumn 3\n,\nmatching the default file format of the \n.SIFlux\n files\nproduced by \nscuff-neq\n, so for those files this option\nmay be omitted.)\n\n\n\n\n\n\n\n\n\n\n\n\n--Temperature TEnv T1 ... TN\n\n\nSpecifies the temperatures of the environment and of all\nbodies in the geometry. Temperature values are interpreted\nin units of Kelvin; for a geometry consisting of bodies\nof temperatures 150 and 300 Kelvin in a cold environment,\nsay \n--Temperature 0 150 300\n.\n\n\n\n\n\n\n\n\n\n\n\n\n--TemperatureFile TFile\n\n\nSpecifies a file containing multiple temperature configurations\nat which to compute total PFTs. For an \nN\n-body geometry,\neach line of \nTFile\n should contain \nN+1\n space-separated\nnumbers in the same format as the arguments to the \n--Temperature\n\noption, i.e. \nTEnv T1 ... TN.\n\n\nFor example, to compute PFTs in a two-body geometry with the\ntemperature of body 1 scanned from 10 to 300 Kelvin, the\ntemperature of body 2 held fixed at room temperature, and the\nenvironment temperature fixed at 0, \nTFile\n would look like\n\n\n\n\n\n\n0 10  300\n0 20  300\n...\n0 300 300\n\n\n\n\nscuff-integrate\n Command-Line Reference\n\n\nOnly numerical data columns are counted as columns\n\n\nThere is one potentially confusing aspect of the way\n\nscuff-integrate\n interprets column indices as specified\nby command-line arguments such as \n--FreqColumn\n or \nDataColumn\n.\nThis is that \nscuff-integrate\n treats non-numerical data columns\nas white space\n, and in particular does not include data columns\ncontaining text strings when counting column indices.\n\n\nThus, for example, if your data file contains frequency and\nintegrand data in the second and third columns, with the first\ncolumn containing a character string, like this:\n\n\nDEFAULT 0.1 3.45e-5\nDEFAULT 0.2 7.82e-5\nDEFAULT 0.3 1.10e-4\n...\n\n\n\n\nthen \nscuff-integrate\n ignores the \nDEFAULT\n column and considers\nthe first column with numerical data to be column 1, so here\nyou would say \n--freqColumn 1 --dataColumn 2.\n\n\nIn contrast, if your data file looks instead like this: \n\n\n4.00000 0.1 3.45e-5\n4.00000 0.2 7.82e-5\n4.00000 0.3 1.10e-4\n...\n\n\n\n\nyou would want to say \n--freqColumn 2 --dataColumn 3.", 
            "title": "scuff-integrate"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#scuff-integrate-command-line-reference", 
            "text": "", 
            "title": "scuff-integrate Command-Line Reference"
        }, 
        {
            "location": "/applications/scuff-integrate/scuff-integrate/#only-numerical-data-columns-are-counted-as-columns", 
            "text": "There is one potentially confusing aspect of the way scuff-integrate  interprets column indices as specified\nby command-line arguments such as  --FreqColumn  or  DataColumn .\nThis is that  scuff-integrate  treats non-numerical data columns\nas white space , and in particular does not include data columns\ncontaining text strings when counting column indices.  Thus, for example, if your data file contains frequency and\nintegrand data in the second and third columns, with the first\ncolumn containing a character string, like this:  DEFAULT 0.1 3.45e-5\nDEFAULT 0.2 7.82e-5\nDEFAULT 0.3 1.10e-4\n...  then  scuff-integrate  ignores the  DEFAULT  column and considers\nthe first column with numerical data to be column 1, so here\nyou would say  --freqColumn 1 --dataColumn 2.  In contrast, if your data file looks instead like this:   4.00000 0.1 3.45e-5\n4.00000 0.2 7.82e-5\n4.00000 0.3 1.10e-4\n...  you would want to say  --freqColumn 2 --dataColumn 3.", 
            "title": "Only numerical data columns are counted as columns"
        }, 
        {
            "location": "/tests/Overview/", 
            "text": "Overview of the \nscuff-em\n Validation Test Suite\n\n\nThe \nscuff-em\n distribution includes a number of validation tests\nthat use the various dedicated\n\napplication modules\n\nto solve physics problems with known analytical solutions.\n\n\nIn addition to demonstrating the core functionality of\nthe application modules in simple cases,\nthese to \nthese are used as unit tests to catch bugs and regressions\nin the \nscuff-em\n development process; you can\nalso use them to verify the correct performance of your \n\nscuff-em\n installation.\n\n\nDescriptions of the individual tests in the validation suite\n\n\nThe various tests in the test suite are described in detail\non the following pages, which also present comparisons\nof \nscuff-em\n results to known analytical solutions.\n\n\n\n\nMie scattering\n\n\nFresnel scattering\n\n\n\n\nEquilibrium Casimir forces between spheres\n\n\n\n\n\n\nEquilibrium Casimir forces between plates\n\n\n\n\nEquilibrium Casimir-Polder potential near a sphere\n\n\nEquilibrium Casimir-Polder potential near a plate\n\n\nHeat transfer and non-equilibrium Casimir forces between spheres\n\n\nLow-level tests of the \nscuff-em\n core library\n\n\n\n\nRunning the \nscuff-em\n tests\n\n\nThe \nscuff-em\n distribution includes a command-line test harness\napplication that you may use to run individual tests, or the entire\ntest suite, to verify correct performance of your \nscuff-em\n\ninstallation.\n\n\nThe test harness is named \nscuff-test-harness,\n and it lives\nin the \ntests\n subdirectory of the \nscuff-em\n repository.\nThe \ntests\n folder also contains\n\n\n\n\n\n\na collection of text files with file extension \n.scuffTest\n,\n  each of which describes a single validation test in a format\n  understood by \nscuff-test-harness\n\n\n\n\n\n\nvarious input files (geometry files, surface meshes, etc.) \n  needed to run the tests\n\n\n\n\n\n\na collection of data files with file extension \n.ref\n,\n  which contain the correct results of the validation tests\n  and are used by \nscuff-test-harness\n to determine whether \n  or not the test succeeded.\n\n\n\n\n\n\nRunning individual tests\n\n\nTo run an individual validation test, use the \n--test\n option\nto \nscuff-test-harness:\n\n\n % scuff-test-harness --test MieScattering\n\n\n\n\nThe argument passed to \n--test\n should be the base\nfile name of one of the \n.scuffTest\n files.\n\n\nRunning the full test suite or a subset\n\n\nTo run the entire suite of validation tests, use the \n--allTests\n\noption:\n\n\n % scuff-test-harness --allTests\n\n\n\n\nChecking the results of validation tests", 
            "title": "Overview of the test suite"
        }, 
        {
            "location": "/tests/Overview/#descriptions-of-the-individual-tests-in-the-validation-suite", 
            "text": "The various tests in the test suite are described in detail\non the following pages, which also present comparisons\nof  scuff-em  results to known analytical solutions.   Mie scattering  Fresnel scattering   Equilibrium Casimir forces between spheres    Equilibrium Casimir forces between plates   Equilibrium Casimir-Polder potential near a sphere  Equilibrium Casimir-Polder potential near a plate  Heat transfer and non-equilibrium Casimir forces between spheres  Low-level tests of the  scuff-em  core library", 
            "title": "Descriptions of the individual tests in the validation suite"
        }, 
        {
            "location": "/tests/Overview/#running-the-scuff-em-tests", 
            "text": "The  scuff-em  distribution includes a command-line test harness\napplication that you may use to run individual tests, or the entire\ntest suite, to verify correct performance of your  scuff-em \ninstallation.  The test harness is named  scuff-test-harness,  and it lives\nin the  tests  subdirectory of the  scuff-em  repository.\nThe  tests  folder also contains    a collection of text files with file extension  .scuffTest ,\n  each of which describes a single validation test in a format\n  understood by  scuff-test-harness    various input files (geometry files, surface meshes, etc.) \n  needed to run the tests    a collection of data files with file extension  .ref ,\n  which contain the correct results of the validation tests\n  and are used by  scuff-test-harness  to determine whether \n  or not the test succeeded.    Running individual tests  To run an individual validation test, use the  --test  option\nto  scuff-test-harness:   % scuff-test-harness --test MieScattering  The argument passed to  --test  should be the base\nfile name of one of the  .scuffTest  files.  Running the full test suite or a subset  To run the entire suite of validation tests, use the  --allTests \noption:   % scuff-test-harness --allTests", 
            "title": "Running the scuff-em tests"
        }, 
        {
            "location": "/tests/Overview/#checking-the-results-of-validation-tests", 
            "text": "", 
            "title": "Checking the results of validation tests"
        }, 
        {
            "location": "/tests/MieScattering/MieScattering/", 
            "text": "Power, force, and torque in Mie scattering\n\n\nThis test validates the algorithms implemented in\n\nscuff-em\n for computing the power, force, and torque (PFT)\non bodies irradiated by external fields. The test \nuses the \n[\nscuff-scatter\n][scuff-scatter] application module\nto compute the PFT for a lossy dielectric sphere\nirradiated by a circularly-polarized plane wave\nand compares the results to the predictions of \nMie scattering theory.", 
            "title": "Mie scattering"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/", 
            "text": "Fresnel Scattering\n\n\nThis test validates the \nscuff-transmission\n application module\nof the \nscuff-em\n code suite by using it to study the textbook\ncase of \nFresnel scattering\n: the transmission and reflection of\nplane waves at a dielectric interface.\n\n\nExact solution\n\n\nThe situation considered here is that of a plane wave impinging \nfrom below on a dielectric half-space (relative permittivity \n\\epsilon=10\n)\nfilling the region \nz>0\n. (More details on the setup for\n\nscuff-transmission\n calculations may be found in the document\n\nComputation of reflection and transmission coefficients in \nscuff-em\n.)\n\n\nFor this case, the transmission and reflection coefficients\nfor the TE and TM polarizations read \n\n\n\n\n t^{\\scriptsize{\\text{TE}}}\n   =\\frac{2\\cos\\theta}{\\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TE}}}\n   =\\frac{\\cos\\theta-\\cos\\theta^\\prime}{\\cos\\theta + \\cos\\theta^\\prime},\n\n\n\n\n   t^{\\scriptsize{\\text{TM}}}\n  =\\frac{2n\\cos\\theta}{n^2 \\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TM}}}\n  =\\frac{n^2\\cos\\theta-\\cos\\theta^\\prime}{n^2\\cos\\theta + \\cos\\theta^\\prime}\n\n\n\n\n\nwhere \n\\theta\n is the incident angle (\n\\theta=0\n for normal incidence), \nn=\\sqrt{\\epsilon}\n is the index of refraction, and \n\n\n\n\n \\cos\\theta^\\prime = \\sqrt{ \\epsilon - \\sin^2\\theta}.\n\n\n\n\nscuff-em\n solution\n\n\nThe transmission and reflection coefficients for the \n\n\\epsilon=10\n dielectric\nhalf-space problem may be computed using \nscuff-transmission\n\nas follows:\n\n\n % scuff-transmission --geometry E10HalfSpace_40.scuffgeo --Omega 1.0 --ThetaMin 0.0 --ThetaMax 88.0 --ThetaPoints 20\n\n\n\n\n\nHere the file\n\nE10HalfSpace_40.scuffgeo\n\ndescribes the \nscuff-em\"\n geometry\n \n(it refers to a mesh file named\n\nSquare_40.msh\n) \nand the command-line arguments ask for a calculation at \nangular frequency \n\\omega=1\\cdot 3\\times 10^{14}\n rad/sec\nand at 20 incident angles in the range \n0\\le \\theta\\le 88\n degrees.\n\n\nComparison\n\n\nRunning the above command yields the file\n\nE10HalfSpace_40.transmission\n.\nPlotting in \ngnuplot\n yields \na comparison of \nscuff-transmission\n data (point) to \ntheoretical predictions (curves):\n\n\n\n\nHere is the \ngnuplot\n script that I use to produce this \nplot: \nPlotFresnelData.gp\n.", 
            "title": "Fresnel scattering"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/#exact-solution", 
            "text": "The situation considered here is that of a plane wave impinging \nfrom below on a dielectric half-space (relative permittivity  \\epsilon=10 )\nfilling the region  z>0 . (More details on the setup for scuff-transmission  calculations may be found in the document Computation of reflection and transmission coefficients in  scuff-em .)  For this case, the transmission and reflection coefficients\nfor the TE and TM polarizations read     t^{\\scriptsize{\\text{TE}}}\n   =\\frac{2\\cos\\theta}{\\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TE}}}\n   =\\frac{\\cos\\theta-\\cos\\theta^\\prime}{\\cos\\theta + \\cos\\theta^\\prime},  \n   t^{\\scriptsize{\\text{TM}}}\n  =\\frac{2n\\cos\\theta}{n^2 \\cos\\theta + \\cos\\theta^\\prime},\n   \\qquad\n   r^{\\scriptsize{\\text{TM}}}\n  =\\frac{n^2\\cos\\theta-\\cos\\theta^\\prime}{n^2\\cos\\theta + \\cos\\theta^\\prime}   where  \\theta  is the incident angle ( \\theta=0  for normal incidence),  n=\\sqrt{\\epsilon}  is the index of refraction, and     \\cos\\theta^\\prime = \\sqrt{ \\epsilon - \\sin^2\\theta}.", 
            "title": "Exact solution"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/#scuff-em-solution", 
            "text": "The transmission and reflection coefficients for the  \\epsilon=10  dielectric\nhalf-space problem may be computed using  scuff-transmission \nas follows:   % scuff-transmission --geometry E10HalfSpace_40.scuffgeo --Omega 1.0 --ThetaMin 0.0 --ThetaMax 88.0 --ThetaPoints 20   Here the file E10HalfSpace_40.scuffgeo \ndescribes the  scuff-em\"  geometry  \n(it refers to a mesh file named Square_40.msh ) \nand the command-line arguments ask for a calculation at \nangular frequency  \\omega=1\\cdot 3\\times 10^{14}  rad/sec\nand at 20 incident angles in the range  0\\le \\theta\\le 88  degrees.", 
            "title": "scuff-em solution"
        }, 
        {
            "location": "/tests/FresnelScattering/FresnelScattering/#comparison", 
            "text": "Running the above command yields the file E10HalfSpace_40.transmission .\nPlotting in  gnuplot  yields \na comparison of  scuff-transmission  data (point) to \ntheoretical predictions (curves):   Here is the  gnuplot  script that I use to produce this \nplot:  PlotFresnelData.gp .", 
            "title": "Comparison"
        }, 
        {
            "location": "/tests/CasimirSpheres/CasimirSpheres/", 
            "text": "Equilibrium Casimir forces between spheres\n\n\nThis test validates the \nscuff-cas3d\n application module\nof the \nscuff-em\n code suite by using it to compute\nthe equilibrium Casimir force between identical spheres\nat various separation distances. We consider both\nperfectly electrically conducting (PEC) \nand dielectric spheres.\n\n\nAnalytical solution\n\n\nAn analytical formula for the distance-dependent Casimir energy\nof two identical PEC spheres of radius \nR\n separated by a\ndistance \nd\n was obtained by T. Emig et al. in this paper:\n\n\n\n\nT. Emig, N. Graham, R. L. Jaffe, and M. Kardar, \"Casimir forces between arbitrary compact objects.\" \nPhysical Review Letters\n \n99\n 170403 (2007).\n\n\n\n\nTheir asymptotic (\nd\\gg R\n) formula for the energy, and the force\nformula obtained by differentiating it, are\n\n\n\n\n E(d) = -\\frac{\\hbar c}{\\pi R}   \\sum_{n=7}^\\infty C_n \\left(\\frac{R}{d}\\right)^n \n\n\n F(d) = -\\frac{\\hbar c}{\\pi R^2} \\sum_{n=7}^\\infty n C_n \\left(\\frac{R}{d}\\right)^{n+1}\n\n\n\n\nwhere the first few \nC\n coefficients are\n\n\n\n\n\n\nfor PEC spheres:\n  \nC_7=\\frac{143}{16}, \\quad C_9=\\frac{7947}{160}, \\quad C_{10}=\\frac{2065}{32}\n\n\n\n\n\n\n\n\nfor dielectric spheres with static \n(\\omega \\to 0)\n \n  relative permittivity \n\\epsilon\n:\n  \nC_7=\\frac{23}{4}\\left(\\frac{\\epsilon-1}{\\epsilon+2}\\right)^2\n\n\n\n\n\n\n\n\nscuff-em\n solution\n\n\nThe Casimir energy and force between two PEC spheres\nand between two dielectric spheres may be computed\nusing \nscuff-cas3d\n as follows:\n\n\n % scuff-cas3d --geometry PECSpheres_501.scuffgeo --translist Spheres.trans --energy --zforce\n % scuff-cas3d --geometry E10Spheres_501.scuffgeo --translist Spheres.trans --energy --zforce\n\n\n\n\nHere the two \n.scuffgeo\n files \n(\nPECSpheres_501.scuffgeo\n and \nE10Spheres_501.scuffgeo\n]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius \nR=1\\, \\mu\nm \nseparated by an initial center-center distance of \nd\n=3 \n\\mu\nm) while\n\nSpheres.trans\n specifies the list of center-center \nseparation distances \nd\n at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere, \nSphere_327.msh\n.\n\n\nThe above calculations produce output files named \n\nPECSpheres_327.out\n and \n\nE10Spheres_327.out\n. Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:\n\n\n.\n\n\nHere's the \ngnuplot\n script I used to produce this \nplot: \nPlotter.gp\n.", 
            "title": "Equilibrium Casimir forces between spheres"
        }, 
        {
            "location": "/tests/CasimirSpheres/CasimirSpheres/#analytical-solution", 
            "text": "An analytical formula for the distance-dependent Casimir energy\nof two identical PEC spheres of radius  R  separated by a\ndistance  d  was obtained by T. Emig et al. in this paper:   T. Emig, N. Graham, R. L. Jaffe, and M. Kardar, \"Casimir forces between arbitrary compact objects.\"  Physical Review Letters   99  170403 (2007).   Their asymptotic ( d\\gg R ) formula for the energy, and the force\nformula obtained by differentiating it, are    E(d) = -\\frac{\\hbar c}{\\pi R}   \\sum_{n=7}^\\infty C_n \\left(\\frac{R}{d}\\right)^n    F(d) = -\\frac{\\hbar c}{\\pi R^2} \\sum_{n=7}^\\infty n C_n \\left(\\frac{R}{d}\\right)^{n+1}   where the first few  C  coefficients are    for PEC spheres:\n   C_7=\\frac{143}{16}, \\quad C_9=\\frac{7947}{160}, \\quad C_{10}=\\frac{2065}{32}     for dielectric spheres with static  (\\omega \\to 0)  \n  relative permittivity  \\epsilon :\n   C_7=\\frac{23}{4}\\left(\\frac{\\epsilon-1}{\\epsilon+2}\\right)^2", 
            "title": "Analytical solution"
        }, 
        {
            "location": "/tests/CasimirSpheres/CasimirSpheres/#scuff-em-solution", 
            "text": "The Casimir energy and force between two PEC spheres\nand between two dielectric spheres may be computed\nusing  scuff-cas3d  as follows:   % scuff-cas3d --geometry PECSpheres_501.scuffgeo --translist Spheres.trans --energy --zforce\n % scuff-cas3d --geometry E10Spheres_501.scuffgeo --translist Spheres.trans --energy --zforce  Here the two  .scuffgeo  files \n( PECSpheres_501.scuffgeo  and  E10Spheres_501.scuffgeo ]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius  R=1\\, \\mu m \nseparated by an initial center-center distance of  d =3  \\mu m) while Spheres.trans  specifies the list of center-center \nseparation distances  d  at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere,  Sphere_327.msh .  The above calculations produce output files named  PECSpheres_327.out  and  E10Spheres_327.out . Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:  .  Here's the  gnuplot  script I used to produce this \nplot:  Plotter.gp .", 
            "title": "scuff-em solution"
        }, 
        {
            "location": "/tests/CasimirPlates/CasimirPlates/", 
            "text": "", 
            "title": "Equilibrium Casimir forces between plates"
        }, 
        {
            "location": "/tests/CPSphere/CPSphere/", 
            "text": "", 
            "title": "Equilibrium Casimir-Polder potential near a sphere"
        }, 
        {
            "location": "/tests/CPPlate/CPPlate/", 
            "text": "", 
            "title": "Equilibrium Casimir-Polder potential near a plate"
        }, 
        {
            "location": "/tests/NEQSpheres/NEQSpheres/", 
            "text": "Non-equilibrium fluctuation-induced interactions between spheres: heat radiation and non-equilibrium Casimir forces\n\n\nThis test validates the \nscuff-neq\n application module\nof the \nscuff-em\n code suite by using it to compute\n\n(a)\n the temperature-dependent rate of heat radiation\nfrom individual spheres,\n\n(b)\n radiative heat-transfer rates and non-equilibrium\nCasimir forces between spheres at various separation \ndistances.\n\n\nAnalytical solution\n\n\nAnalytical formulas for single-sphere heat radiation\nand sphere-sphere heat-transfer rates and non-equilibrium \nCasimir forces were obtained by M. Krueger and are\ndiscussed in this paper:\n\n\n\n\nM. Krueger, G. Bimonte, T. Emig, and M. Kardar, \"Trace formulas for nonequilibrium {C}asimir interactions, heat radiation, and heat transfer for arbitrary objects\", Physical Review B \\textbf{86} 115423 (2012)\n\n\n\n\nThe formulas are a bit complicated to reproduce here, but here\nis a simple \njulia\n\ncode that implements them:\n\n\n\n\nKruegerFormulas.jl\n\n\n\n\nThis code may be used to\n\n\nscuff-em\n solution\n\n\nValues of the flux quantity $\\phi^{\\text{\\small \nheat radiation\nand between two dielectric spheres may be computed\nusing \nscuff-cas3d\n as follows:\n\n\n % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile OmegaFile\n\n\n\n\n % scuff-neq --geometry SiO2Spheres_501.scuffgeo --OmegaFile OmegaFile\n\n\n\n\nHere the two \n.scuffgeo\n files \n(\nPECSpheres_501.scuffgeo\n and \nE10Spheres_501.scuffgeo\n]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius \nR=1\\, \\mu\nm \nseparated by an initial center-center distance of \nd\n=3 \n\\mu\nm) while\n\nSpheres.trans\n specifies the list of center-center \nseparation distances \nd\n at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere, \nSphere_327.msh\n.\n\n\nThe above calculations produce output files named \n\nPECSpheres_327.out\n and \n\nE10Spheres_327.out\n. Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:\n\n\n.\n\n\nHere's the \ngnuplot\n script I used to produce this \nplot: \nPlotter.gp\n.", 
            "title": "Heat transfer and non-equilibrium Casimir forces between spheres"
        }, 
        {
            "location": "/tests/NEQSpheres/NEQSpheres/#analytical-solution", 
            "text": "Analytical formulas for single-sphere heat radiation\nand sphere-sphere heat-transfer rates and non-equilibrium \nCasimir forces were obtained by M. Krueger and are\ndiscussed in this paper:   M. Krueger, G. Bimonte, T. Emig, and M. Kardar, \"Trace formulas for nonequilibrium {C}asimir interactions, heat radiation, and heat transfer for arbitrary objects\", Physical Review B \\textbf{86} 115423 (2012)   The formulas are a bit complicated to reproduce here, but here\nis a simple  julia \ncode that implements them:   KruegerFormulas.jl   This code may be used to", 
            "title": "Analytical solution"
        }, 
        {
            "location": "/tests/NEQSpheres/NEQSpheres/#scuff-em-solution", 
            "text": "Values of the flux quantity $\\phi^{\\text{\\small \nheat radiation\nand between two dielectric spheres may be computed\nusing  scuff-cas3d  as follows:   % scuff-neq --geometry SiO2Sphere_501.scuffgeo --OmegaFile OmegaFile   % scuff-neq --geometry SiO2Spheres_501.scuffgeo --OmegaFile OmegaFile  Here the two  .scuffgeo  files \n( PECSpheres_501.scuffgeo  and  E10Spheres_501.scuffgeo ]\ndescribe the two geometric configurations\n(two PEC spheres and two dielectric spheres of radius  R=1\\, \\mu m \nseparated by an initial center-center distance of  d =3  \\mu m) while Spheres.trans  specifies the list of center-center \nseparation distances  d  at which we compute the energy and force.\n(Both geometries refer to the same surface mesh file for the \nsphere,  Sphere_327.msh .  The above calculations produce output files named  PECSpheres_327.out  and  E10Spheres_327.out . Plotting against\nthe theoretical predictions of Emig et. al (referenced above)\nyields good agreement:  .  Here's the  gnuplot  script I used to produce this \nplot:  Plotter.gp .", 
            "title": "scuff-em solution"
        }, 
        {
            "location": "/tests/libscuff/libscuff/", 
            "text": "", 
            "title": "Low-level tests of the core library"
        }, 
        {
            "location": "/API/libscuff/", 
            "text": "libscuff\n: Access to \nscuff-em\n internals from C++ or python programs\n\n\nThis documentation has not yet been ported from its earlier \nversion. For the time being, please\n\naccess the earlier version of the documentation.", 
            "title": "libscuff"
        }, 
        {
            "location": "/forDevelopers/Implementation/", 
            "text": "Under the hood: the algorithms implemented by \nscuff-em\n\n\nThis page offers some top-level overview sketches \nof the basic algorithms implemented by the various codes in \nthe \nscuff-em\n suite.\n\n\nFor more details on the implementation of these algorithms, see\n\nData Structures and Class Methods in \nscuff-em\n.\n\n\nFor further technical details on the \nscuff-em\n core library, check out the\n\nlibscuff\n Implementation Notes and Technical Reference\n,\navailable as a PDF document.\n\n\nThe core library (\nlibscuff\n)\n\n\nAt its heart, the \n\nscuff-em\n core library\n\nis an implementation of the surface-integral-equation /\n boundary-element method (SIE / BEM) \nfor solving electromagnetic scattering problems. \n\n\nMore specifically, \n\nscuff-em\n \nimplements the EFIE and PMCHW formulations of the SIE / BEM with \nRWG basis functions used to expand tangential currents on the \nsurfaces of compact 3D objects.\n\n\nIf all of those acronyms went by a little quickly, \nhere's a sketch of the basic problem addressed by the\n\nscuff-em\n core library.\nWe have a collection of homogeneous material objects (maybe \ngold or silicon spheres or cubes) embedded in some medium \n(generally vacuum or a dielectric liquid), we irradiate the \nconfiguration with some known electromagnetic disturbance \n(such as a plane wave), and we seek to compute the electromagnetic \nfields scattered from the objects.\nIn a surface-integral-equation (SIE) method, we do this by first \ncomputing the \nsurface currents\n induced on the object \nsurfaces by the incident field. (For perfectly conducting \nscatterers we have only electric surface currents \nK\n; \nfor general scatterers we have both electric and magnetic \n(\nN\n) surface currents.) Once we have solved for the \nsurface currents, we can use them to evaluate the scattered \nfields anywhere we like.\n\n\n\n\nTo solve for the surface currents, we write down an \n\nintegral equation\n relating the surface currents to\nthe incident field. This integral equation basically says \nthat the tangential components of the scattered field (the \nfield due to the surface currents) should precisely cancel \nthe tangential components of the \nincident field at the object surfaces. \n(This statement is more of a mnemonic than a rigorous description;\nsee the \n\ntechnical memo\n\nfor a more thorough treatment.) \nSchematically, the integral\nequation looks something like this:\n\n\n\n\n \\oint \n   \\boldsymbol{\\Gamma}(\\omega; \\mathbf{x}, \\mathbf{x}^\\prime)\n   \\cdot \\left(\\begin{array}{c} \\mathbf{K}(\\mathbf{x}^\\prime) \\\\\n                                \\mathbf{N}(\\mathbf{x}^\\prime)\n         \\end{array}\\right) d\\mathbf{x}^\\prime\n       = -\\left(\\begin{array}{c} \\mathbf{E}(\\mathbf{x}) \\\\\n                                 \\mathbf{H}(\\mathbf{x})\n          \\end{array}\\right)^{\\hbox{\\scriptsize{inc}}}\n\n\n\n\n\nwhere \n\\boldsymbol{\\Gamma}\n\ninvolves the dyadic Green's function for Maxwell's \nequations. Here the surface integral extends over the surfaces of\nall scattering objects in our scattering geometry, and the equation\nis required to hold at all points \nx\n on all object\nsurfaces. (The equation is understood to apply only to the \nsurface-tangential components of the vectors on the two sides.)\n\n\nThis is the surface-integral-equation (SIE) formulation of \nour scattering problem. To solve the integral equation \nnumerically, we now proceed to \ndiscretize\n it by \nexpanding the \nK\n and \nN\n surface currents in some \nbasis of expansion functions. The particular functions used \nby \nlibscuff\n are the \"RWG\" basis \nfunctions, which were defined in this paper:\n\n\n\n\n\"Electromagnetic Scattering by Surfaces of Arbitrary Shape,\"\nby S. Rao, D. Wilton, and A. Glisson, \n\nIEEE Transactions on Antennas and Propagation\n \n30\n\n409 (1982) \n\nhttp://dx.doi.org/10.1109/TAP.1982.1142818\n\n\n\n\nThe RWG basis functions are defined by meshing the surfaces \nof compact 3D objects into flat triangular panels, and assigning \nto each internal \nedge\n in the discretization a localized \nsurface current that is sourced and sunk at the panel vertices \nopposite that edge:\n\n\n\n\nHaving introduced a discrete basis of expansion functions,\nour integral equation becomes a simultaneous system of \nlinear equations: \n\n\n\n\nThis approach to solving surface integral equations is known \nas the \nboundary-element method\n (BEM), and the linear \nsystem in the equation above is sometimes known as the BEM \nsystem. The \nscuff-em\n core library provides\nroutines for assembling the BEM matrix \nM\n, and the right-hand \nside vector of incident-field expansion coefficients, for arbitrary \nscattering geometries and arbitrary incident fields at arbitrary \nfrequencies.\n\n\nThen, using the matrix and RHS vector assembled by the core\nlibrary, you can use external linear algebra software like\n\nlapack\n\nto solve the linear system, after which you can again use\nroutines provided by the \nscuff-em\n core library to compute the \nscattered fields at arbitrary points.", 
            "title": "Implementation"
        }, 
        {
            "location": "/forDevelopers/Implementation/#the-core-library-libscuff", 
            "text": "At its heart, the  scuff-em  core library \nis an implementation of the surface-integral-equation /\n boundary-element method (SIE / BEM) \nfor solving electromagnetic scattering problems.   More specifically,  scuff-em  \nimplements the EFIE and PMCHW formulations of the SIE / BEM with \nRWG basis functions used to expand tangential currents on the \nsurfaces of compact 3D objects.  If all of those acronyms went by a little quickly, \nhere's a sketch of the basic problem addressed by the scuff-em  core library.\nWe have a collection of homogeneous material objects (maybe \ngold or silicon spheres or cubes) embedded in some medium \n(generally vacuum or a dielectric liquid), we irradiate the \nconfiguration with some known electromagnetic disturbance \n(such as a plane wave), and we seek to compute the electromagnetic \nfields scattered from the objects.\nIn a surface-integral-equation (SIE) method, we do this by first \ncomputing the  surface currents  induced on the object \nsurfaces by the incident field. (For perfectly conducting \nscatterers we have only electric surface currents  K ; \nfor general scatterers we have both electric and magnetic \n( N ) surface currents.) Once we have solved for the \nsurface currents, we can use them to evaluate the scattered \nfields anywhere we like.   To solve for the surface currents, we write down an  integral equation  relating the surface currents to\nthe incident field. This integral equation basically says \nthat the tangential components of the scattered field (the \nfield due to the surface currents) should precisely cancel \nthe tangential components of the \nincident field at the object surfaces. \n(This statement is more of a mnemonic than a rigorous description;\nsee the  technical memo \nfor a more thorough treatment.) \nSchematically, the integral\nequation looks something like this:    \\oint \n   \\boldsymbol{\\Gamma}(\\omega; \\mathbf{x}, \\mathbf{x}^\\prime)\n   \\cdot \\left(\\begin{array}{c} \\mathbf{K}(\\mathbf{x}^\\prime) \\\\\n                                \\mathbf{N}(\\mathbf{x}^\\prime)\n         \\end{array}\\right) d\\mathbf{x}^\\prime\n       = -\\left(\\begin{array}{c} \\mathbf{E}(\\mathbf{x}) \\\\\n                                 \\mathbf{H}(\\mathbf{x})\n          \\end{array}\\right)^{\\hbox{\\scriptsize{inc}}}   where  \\boldsymbol{\\Gamma} \ninvolves the dyadic Green's function for Maxwell's \nequations. Here the surface integral extends over the surfaces of\nall scattering objects in our scattering geometry, and the equation\nis required to hold at all points  x  on all object\nsurfaces. (The equation is understood to apply only to the \nsurface-tangential components of the vectors on the two sides.)  This is the surface-integral-equation (SIE) formulation of \nour scattering problem. To solve the integral equation \nnumerically, we now proceed to  discretize  it by \nexpanding the  K  and  N  surface currents in some \nbasis of expansion functions. The particular functions used \nby  libscuff  are the \"RWG\" basis \nfunctions, which were defined in this paper:   \"Electromagnetic Scattering by Surfaces of Arbitrary Shape,\"\nby S. Rao, D. Wilton, and A. Glisson,  IEEE Transactions on Antennas and Propagation   30 \n409 (1982)  http://dx.doi.org/10.1109/TAP.1982.1142818   The RWG basis functions are defined by meshing the surfaces \nof compact 3D objects into flat triangular panels, and assigning \nto each internal  edge  in the discretization a localized \nsurface current that is sourced and sunk at the panel vertices \nopposite that edge:   Having introduced a discrete basis of expansion functions,\nour integral equation becomes a simultaneous system of \nlinear equations:    This approach to solving surface integral equations is known \nas the  boundary-element method  (BEM), and the linear \nsystem in the equation above is sometimes known as the BEM \nsystem. The  scuff-em  core library provides\nroutines for assembling the BEM matrix  M , and the right-hand \nside vector of incident-field expansion coefficients, for arbitrary \nscattering geometries and arbitrary incident fields at arbitrary \nfrequencies.  Then, using the matrix and RHS vector assembled by the core\nlibrary, you can use external linear algebra software like lapack \nto solve the linear system, after which you can again use\nroutines provided by the  scuff-em  core library to compute the \nscattered fields at arbitrary points.", 
            "title": "The core library (libscuff)"
        }, 
        {
            "location": "/forDevelopers/DataStructures/", 
            "text": "Data Structures and Class Methods in \nscuff-em\n\n\nThis page is intended to serve as a starting point for hackers \nseeking to understand, or extend, the nitty-gritty implementation\ndetails of the \nscuff-em\n core library.\n\n\nMore technical details may be found in the \n\nlibscuff\n Implementation Notes and Technical Reference\n, \navailable as a PDF document.\n\n\n\n\n\n \n Data Structures and Class Methods in \nscuff-em\n\n\n\n\n \n \n  Geometries, Regions, Surfaces\n\n \n \n      Panels, Edges, Vertices\n\n \n \n  Assembling the BEM Matrix\n\n \n \n     An Explicit Low-Level Example\n\n\n\n\n\n\n\n1. Geometries, Regions, Surfaces\n\n\nThe top-level data structure in \nlibscuff\n\nis a C++ class named \nRWGGeometry.\n The definition of this class is a \nlittle too big to present in full here (you can find it in the \nheader file \nlibscuff.h\n), but we will point out its\nmost important data fields and class methods.\n\n\nGeometries in \nscuff-em\n are represented\na collection of two or more contiguous \nthree-dimensional \nregions\n \nbounded by one or more two-dimensional \nsurfaces.\n\nMaterial properties (permittivity and permeability) are homogeneous \n(spatially constant) in each region and described by a single\n\nscuff-em\n material description\n.\n\n\nEach region is assigned an integer index starting from \n0.\n\nThe \nRWGGeometry\n includes the following data fields for \nidentifying physical regions.\n\n\nclass RWGGeometry \n   { \n      ... \n      int NumRegions;\n      char **RegionLabels;\n      MatProp **RegionMPs;\n      ... \n   }; \n\n\n\n\nHere \nRegionLabels[i]\n is a string description for the \n\ni\nth region in the problem, and \nRegionMPs[i]\n is\na pointer to an instance of \nMatProp\n describing its \nfrequency-dependent material properies. (\nMatProp\n is \na very simple class, implemented by the \n\nlibmatprop\n submodule of \nscuff-em\n, for\nhandling frequency-dependent material properties.)\n\n\nRWGGeometry\n always starts off with a single \nregion (region \n0\n) with label \nExterior\n \nand the material properties of vacuum. \nEach \nREGION\n statement in the\n\n.scuffgeo\n file\n\nthen creates a new region, starting with region \n1.\n\n(This is true unless the label specified to the \nREGION\n\nkeyword is \nExterior,\n in which case the \nstatement just redefines the material properties of region \n0\n.)\nEach \nOBJECT...ENDOBJECT\n section in the \n.scuffgeo\n\nfile also creates a single new region (for the interior of the object).\n\n\nRegions in a geometry are separated from one another by surfaces.\nEach surface is described by a C++ class named \nRWGSurface.\n\nThe \nRWGGeometry\n class maintains an internal array of \n\nRWGSurfaces:\n\n\nclass RWGGeometry \n   { \n      ... \n      int NumSurfaces;\n      RWGSurface **Surfaces;\n      ... \n   }; \n\n\n\n\nEach \nOBJECT...ENDOBJECT\n or \nSURFACE...ENDSURFACE\n\nsection in the \n.scuffgeo\n file adds a new \nRWGSurface\n\nstructure to the geometry. (Note that, in \nscuff-em\n \nparlance, an \"object\" is just a special case of a surface in which the \nsurface is \nclosed.\n) \n\n\nThe \nRWGSurface\n class is again slightly\ntoo complicated to list in full here, but we will discuss its most salient \nfields and methods. Among these are the \nRegionIndices\n field:\n\n\n class RWGSurface\n   { \n      ... \n      int RegionIndices[2];\n      ... \n   }; \n\n\n\n\nThese two integers are the indices of the regions on the two sides of the \nsurface. The \nfirst\n region (\nRegionIndex[0]\n) is \nthe \npositive\n region for the surface; this means that the electric\nand magnetic surface currents on the surface contribute to the fields \nin that region with a positive sign. The second region \n(\nRegionIndex[1]\n) is the \nnegative\n region; currents \non the surface contribute to the fields in that region with a negative\nsign.\n\n\nAnother way to think of this is that the surface normal vector \n\nn\n points \n\naway from\n \nRegionIndex[1]\n \nand \n\ninto\n \nRegionIndex[0]\n.\n\n\n\n\n2. Panels, Edges, Vertices\n\n\nThe mesh describing each surface in a geometry is structure is analyzed \ninto lists of \nvertices\n, triangular \npanels,\n and panel \n\nedges.\n Several internal data fields in the \nRWGSurface\n\nclass are devoted to storing this information. \n\n\nclass RWGSurface\n{ \n  ... \n  int NumVertices;\n  double *Vertices;\n\n  int NumPanels;\n  RWGPanel **Panels;\n\n  int NumEdges;            \n  RWGEdge **Edges;\n  ... \n\n};\n\n\n\n\nHere \nVertices\n is an array of \n3*NumVertices\n \n\ndouble\n values in which the cartesian coordinates of each \nvertex are stored one after another. Thus, the \nx, y, z\n \ncoordinates of the \nnv\nth vertex are \n\nVertices[3*nv+0], Vertices[3*nv+1], Vertices[3*nv+2].\n\n\nPanels\n and \nEdges\n are arrays of pointers\nto specialized data structures for storing geometric data.\n\n\nThe \nRWGPanel\n and \nRWGEdge\n structures\n\n\nThe elemental data structure in the \nscuff-em\n\ngeometry hierarchy is \nRWGPanel\n. Each instance of this structure\ndescribes a single triangular panel in the mesh discretization of an \n\nRWGSurface.\n\n\n \nRWGPanel\n definition \n\n\ntypedef struct RWGPanel\n { \n   int VI[3];            /* indices of vertices in Vertices array */\n   int EI[3];            /* indices of edges in Edges array */\n\n   double Centroid[3];   /* panel centroid */\n   double ZHat[3];       /* normal vector */\n   double Radius;        /* radius of enclosing sphere */\n   double Area;          /* panel area */\n\n   int Index;            /* index of this panel within RWGSurface */\n\n } RWGPanel;\n\n\n\n\nHere the elements of the \nVI\n array are the indices of the \nthree panel vertices within the list of vertices for the given \n\nRWGSurface.\n The \nIndex\n field in \nRWGPanel\n\nindicates that panel's index within the \nPanels\n array \nof the parent \nRWGSurface.\n The remaining fields tabulate some useful\ngeometric data on the panel.\n\n\nIn addition to an \nRWGPanel\n structure for each triangle \nin the surface mesh, we also create an \nRWGEdge\n structure\nfor each panel \nedge.\n\n\n \nRWGEdge\n definition \n\n\ntypedef struct RWGEdge \n { \n   int iV1, iV2, iQP, iQM;  /* indices of panel vertices (iV1\nlt;iV2) */\n   double Centroid[3];      /* edge centroid */\n   double Length;           /* length of edge */\n   double Radius;           /* radius of enclosing sphere */\n\n   int iPPanel;             /* index of PPanel within RWGSurface (0..NumPanels-1)*/\n   int iMPanel;             /* index of MPanel within RWGSurface (0..NumPanels-1)*/\n   int PIndex;              /* index of this edge within PPanel (0..2)*/\n   int MIndex;              /* index of this edge within MPanel (0..2)*/\n   int Index;               /* index of this edge within RWGSurface (0..NumEdges-1)*/\n\n   RWGEdge *Next;           /* pointer to next edge in linked list */\n\n } RWGEdge;\n\n\n\n\nThe \niQP, iV1, iV2, iQM\n fields here are indices into the \nlist of vertices for the parent \nRWGSurface.\n \n\niV1\n and \niV2\n are the actual endpoints of the edge.\n\niQP\n and \niQM\n denote respectively the current\n\nsource\n and \nsink\n vertices for the RWG basis function corresponding\nto this edge.\n\n\niPPanel\n and \niMPanel\n are the indices (into the \n\nPanels\n array of the parent \nRWGSurface\n) of the \n\npositive\n and \nnegative\n panels associated with the edge.\n(The positive panel is the one from which the RWG current emanates; \nits vertices are \niQP, iV1, iV2.\n\nThe negative panel is the one into which the RWG current is sunk;\nits vertices are \niQM, iV1, iV2.\n) \nThe \niPPanel\n and \niMPanel\n fields take values\nbetween \n0\n and \nNumPanels-1\n, where \n\nNumPanels\n is defined in the parent \nRWGSurface.\n\n\nPIndex\n and \nMIndex\n are the indices of the edge \nwithin the positive and negative \nRWGPanel\ns.\n(The index of an \nedge\n within a panel is defined as the index \nwithin the panel of the panel \nvertex\n opposite that edge; the \nindex of a vertex is its position in the \nVI\n array in the \n\nRWGPanel\n structure.)\n\n\nThe \nIndex\n field of \nRWGEdge\n is the index of \nthe structure within the \nEdges\n array of the parent \n\nRWGSurface.\n\n\nThe remaining fields store some geometric data on the edge.\nThe \nCentroid\n field stores the cartesian coordinates\nof the midpoint of the line segment between vertices \nV1\n\nand \nV2\n.\n\n\nHere's an example of two panels (panel indices \n17\n and \n\n39\n) in a surface mesh, and a single \nedge (edge index \n24\n) shared between them. \nPanel \n17\n is the positive panel for the edge, \nwhile panel \n39\n is the negative panel for the edge; the corresponding\ndirection of current flow is indicated by the arrows.\nThe larger red numbers near the vertices are the indices of those\nvertices in the \nVertices\n array. \nThe smaller magenta and cyan numbers are the indices of the vertices \nwithin the \nVI\n arrays in the two \nRWGPanels\n.\n(The other four edges of this panel pair would also have corresponding \n\nRWGEdge\n structures; these are not shown in the figure.)\n\n\n\n\n\n\n3. Assembling the BEM Matrix\n\n\nThe \nRWGGeometry\n class contains a hierarchy of \nroutines for assembling the BEM matrix. If you are simply\nusing the code to solve scattering problems, you will\nonly ever need to call the top-level routine \n\nAssembleBEMMatrix\n or perhaps the \nsecond-highest-level routine, \nAssembleBEMMatrixBlock.\n\nHowever, developers of surface-integral-equation methods \nmay wish to access the lower-level routines for \ncomputing the interactions of individual RWG basis functions\nor for computing certain integrals over triangular regions.\n\n\nAssembleBEMMatrix\n\n\nThe top-level matrix assembly routine is \n\nAssembleBEMMatrix.\n This routine loops over \nall unique pairs of \nRWGSurfaces\n in the geometry. \nFor each unique pair \nof surfaces, the routine calls \nAssembleBEMMatrixBlock\n \nto assemble the subblock of the BEM matrix corresponding to a single \npair of \nRWGSurfaces,\n then stamps this subblock \ninto the appropriate place in the overall BEM matrix. \n\n\nFor example, if a geometry contains three \nRWGSurfaces\n,\nthen its overall BEM matrix has the block structure\n\n\n\n\nwhere the \n\\mathbf{M}__{ij}\n subblock describes the\ninteractions of surfaces \ni\n and \nj\n.\nIn this case \nAssembleBEMMatrix\n proceeds by making 6 calls\nto \nAssembleBEMMatrixBlock\n, one for each of the \ndiagonal and above-diagonal blocks. (The below-diagonal\nblocks are related to their above-diagonal counterparts by \nsymmetry.)\n\n\nAssembleBEMMatrixBlock\n\n\nAssembleBEMMatrixBlock\n computes the subblock of the \nBEM matrix corresponding to a single pair of \nRWGSurface\ns.\nFor compact (non-periodic) geometries, this amounts to making just\na single call to \nSurfaceSurfaceInteractions\n. For \nperiodic geometries, this involves making multiple calls to \n\nSurfaceSurfaceInteractions\n in which one of the two \nsurfaces is displaced through various lattice vectors \nL\n to account\nfor the contribution of periodic images. \n\n\nThe contribution of the \nmatrix subblock computed by \nSurfaceSurfaceInteractions\n\nwith displacement vector \nL\n is weighted in the overall\nBEM matrix by a Bloch phase factor \n\n e^{i\\mathbf{k}\\cdot \\mathbf{L}}\n\nwhere \nk\n is the Bloch wavevector, i.e. we have \n\n\n\n\nwhere the \nL\n superscript indicates that the corresponding\nmatrix subblock is to be computed with one of the two surfaces \ndisplaced through translation vector \nL\n.\n\n\nSurfaceSurfaceInteractions\n\n\nSurfaceSurfaceInteractions\n loops over all \nRWGEdge\n\nstructures on each of the two surfaces it is considering.\nFor each pair of edges, it calls \nEdgeEdgeInteractions\n\nto compute the inner products of the RWG basis functions\nwith the \nG\n and \nC\n dyadic Green's functions\nfor each of the material regions through which the two surfaces\ninteract. (Surfaces may interact through 0, 1, or 2 material \nregions.)\nThen it stamps these values into their appropriate places\nin the BEM matrix subblock. \n\n\nFor example, if we have surfaces \n\nS\n and \nS\n that \ninteract through a single dielectric medium, the structure of \nthe corresponding matrix subblock is\n\n\n\n\nwhere e.g. \nb\nm\n is the \n\nm\nth basis function on surface \nS\n. \nThe kernels\nhere are scalar multiples of the \nG\n and \nC\n\ndyadics:\n\n\n\n\nwhere \nk\n, \nZ\n are the wavenumber and (absolute)\nwave impedance of the dielectric medium at the frequency\nin question.\n\n\nThe matrix structure above is for the case of two surfaces\ninteracting through a single material region (for example,\n\nS\n and \nS\n\nmight be the outer surfaces of two compact objects embedded \nin vacuum or in a homogeneous medium, in which case the \nsurfaces interact only throught that medium).\nIf the surfaces interact through \ntwo\n material regions\n(for example, if we have \n\nS\n=\nS\n\nand we are computing the self-interaction of the outer\nsurface of a dielectric object embedded in vacuum) then\neach matrix entry is actually a sum of \ntwo\n \ninner products, one involving the \n kernels for \nthe interior medium and one involving the kernels for \nthe exterior. (If the surfaces are PEC, then the dimension\nof the matrix is halved with only the \nEE\n terms\nretained.)\n\n\nEdgeEdgeInteractions\n\n\nEdgeEdgeInteractions\n considers a pair of RWG basis\nfunctions and computes the inner products of these basis functions\nwith the \nG\n and \nC\n dyadic Green's functions for a \nsingle material medium. Because each basis function is supported\non two triangles, the full inner products involve sums of four\ntriangle-pair contributions:\n\n\n\n\nHere \nl\nm\n,l\nn\n are the lengths of the\ninterior edges to which the RWG basis functions are associated, and\neach of the four terms in the sum is a four-dimensional integral \nover a single pair of panels, computed by \n\nPanelPanelInteractions.\n\n\nPanelPanelInteractions\n\n\nPanelPanelInteractions\n is the lowest-level routine in the \n\nscuff-em\n BEM matrix assembly hierarchy.\nThis routine computes the individual terms in equation (1) above,\ni.e. the contributions of a single pair of panels\nto the inner products of two RWG basis functions with the \nG\n and \n\nC\n dyadic Green's functions:\n\n\n\n\nNote that the RWG basis-function prefactor \nl/2A\n is broken\nup into two factors between equations (1) and (2): the \n1/2A\n\npart is included in the panel-panel integrals (2), while \nthe \nl\n part is included when summing the four panel-panel\ncontributions in equation (1) to obtain the overall inner product. \n\n\nIf the panels are far away from each other, \nPanelPanelInteractions\n \nuses low-order four-dimensional numerical cubature to compute the full\ninteractions. Otherwise, \nPanelPanelInteractions\n uses\nlow-order four-dimensional numerical cubature to compute the interactions\nwith \nsingularity-subtracted versions\n of the \nG\n and \nC\n \nkernels, then adds the contributions of the singular terms after \nlooking them up in an internally-stored cache.\n\n\n\n\n4. An Explicit Low-Level Example\n\n\nHere's a worked example of a matrix-element computation in a \nscuff-em\n run. \n\n\nThe geometry and the labeling of panels, edges, and vertices\n\n\nWe'll consider a\nscattering geometry consisting of a single cube of dielectric\nmaterial, with side length \nL=\n1 \nm, discretized into \ntriangles with minor side length \nL/10\n, yielding a total\nof 1200 triangles, 1800 interior edges, and 3600 RWG basis \nfunctions (1800 each for electric and magnetic currents) \nfor a dielectric geometry. The \n\ngmsh\n geometry file for this example is \n\nCube_N.geo\n,\nthe \ngmsh\n mesh file produced by running\n\ngmsh -2 Cube_N.geo\n is\n\nCube_10.msh\n,\nand a \nscuff-em\n geometry file describing\na geometry consisting of this discretized cube with interior dielectric\npermittivity \n=4 is\n\nDielectricCube.scuffgeo\n.\n\n\n\n\nFor low-level work it is convenient to have data on the internal \nindices that \nscuff-em\n assigns to \npanels, vertices, and edges when it reads in a geometry file.\nWe get this by running \nscuff-analyze\n on the mesh file\nin question with the \n--WriteGMSHLabels\n options:\n\n\n % scuff-analyze --mesh Cube_10.msh --WriteGMSHFiles --WriteGMSHLabels\n\n\n\n\nThis produces a file named \nCube_10.pp\n, which we open in \n\ngmsh\n to produce a graphical depiction of \nthe labeling of panels, edges, and vertices. Zooming in on the region\nnear the origin, we will focus on the two panels lying closest to the \norigin in the \nxy\n plane; we see that \n\nscuff-em\n has assigned these two panels\npanel indices \n0\n and \n1\n, respectively, while\nthe edge they share has been assigned interior-edge index \n0\n.\n\n\n\n\nRWG basis function \nb\n0\n\n\nHere's a schematic depiction of the panels that comprise the\nbasis function \nb\n0\n associated with interior edge\n\n0\n:\n\n\n\n\nIn this diagram, the edge length is \nL\n=0.1, \nO\n denotes \nthe origin of coordinates, and the vertices marked \n\nQ\n are the\nsource and sink vertices for the current distribution. \nThe RWG basis function \nb\n0\n associated with \ninterior edge 0 is \n\n\n\n\nwhere the RWG basis function edge length is \nl\n=\n2\nL\n\nand the panel areas are \n\nA\n0\n=A\n1\n=\nL\n2\n/2.\nNote that \n\nP\n0\n and\n\nP\n1\n are respectively the positive and negative\npanels associated with basis function \nb\n0\n.\n\n\nPanel-panel interactions\n\n\nHere's a \nC++\n code snippet that computes the \nquantities \n\nG\n00\n++\n \nand \n\nG\n00\n+-\n in equation (1a)\nabove, i.e. the contributions of the positive-positive \nand positive-negative panel pairs to the inner product of \n\nb\n0\n with itself through the \nG\n kernel,\nwith the wavenumber set to \nk=\n1.0;\nJust to be totally explicit, the numbers that are being \ncomputed here are\n\n\n\n\n\n // read in geometry from .scuffgeo file\n RWGGeometry *G = new RWGGeometry(\nDielectricCube.scuffgeo\n);\n RWGSurface *S = G-\nSurfaces[0];\n\n // initialize an argument structure for GetPanelPanelInteractions\n GetPPIArgStruct MyPPIArgs, *PPIArgs=\nMyPPIArgs;\n InitGetPPIArgs(PPIArgs);\n PPIArgs-\nSa = PPIArgs-\nSb = S;\n PPIArgs-\nk = 1.0;\n\n // fill in arguments to compute the positive-positive panel pair\n PPIArgs-\nnpa = 0;\n PPIArgs-\niQa = 1;\n PPIArgs-\nnpb = 0;\n PPIArgs-\niQb = 1;\n GetPanelPanelInteractions(PPIArgs);\n printf(\nG++ = %e + %ei\\n\n,real(PPIArgs-\nH[0]),imag(PPIArgs-\nH[0]));\n\n // fill in arguments to compute the positive-negative panel pair\n PPIArgs-\nnpa = 0;\n PPIArgs-\niQa = 1;\n PPIArgs-\nnpb = 1;\n PPIArgs-\niQb = 2;\n GetPanelPanelInteractions(PPIArgs);\n printf(\nG++ = %e + %ei\\n\n,real(PPIArgs-\nH[0]),imag(PPIArgs-\nH[0]));\n\n\n\n\nThis code produces the following output:\n\n\n\nG++ = -3.189105e+00 + -7.950381e-02i\nG+- = -1.537561e+00 + -7.956272e-02i\n\n\n\n\nNotice that, to compute a panel-panel interaction, you allocate\nand initialize an instance of a data structure called \n\nGetPPIArgs\n. This structure contains a large \nnumber of fields which in many cases can be set to default \nvalues; to ensure that these fields are properly initialized,\nalways call \nInitGetPPIArgs()\n on an newly-allocated\ninstance of \nGetPPIArgs\n.\n\n\nThen, you fill in the appropriate fields of this structure \nto specify the two panels over which you want to integrate.\nSpecifically, the fields \n\nSa\n, \nnpa\n\nspecify the first panel (the \nnpa\nth \nRWGPanel\n\nin the \nPanels\n array for surface \nSa\n), \nwhile the field \niQa\n (an integer in the range \n0..2\n)\nidentifies the index of the \nQ\n vertex (RWG current source/sink\nvertex) within the three vertices of the panel. \nThe fields \n\nSb\n, \nnpb\n, and \niQb\n\nsimilarly identify the second panel and source/sink vertex.\nInitialize the \nk\n field in the \n\nGetPPIArgs\n structure to the wavenumber parameter\nin the Helmholtz kernel. (\nk\n may be complex or purely imaginary.)\n\n\nEdge-panel interactions\n\n\nHere's a \nC++\n code snippet that computes the \nfull basis-function inner product\n\n \nb\n0\n | \nG\n | \nb\n0\n \n\nin equation (1a) above.\n\n\n GetEEIArgStruct MyEEIArgs, *EEIArgs=\nMyEEIArgs;\n InitGetEEIArgs(EEIArgs);\n EEIArgs-\nSa = EEIArgs-\nSb = S;\n EEIArgs-\nnea = EEIArgs-\nneb = 0;\n EEIArgs-\nk = 1.0;\n GetEdgeEdgeInteractions(EEIArgs);\n printf(\nlt;b|G|b\ngt; = %e + %ei\\n\n,real(EEIArgs-\nGC[0]),imag(EEIArgs-\nGC[0]));\n\n\n\n\nNote that, similar to the case of \nGetPanelPanelInteractions\n\ndiscussed above, the call to \nGetEdgeEdgeInteractions\n takes as\nargument a pointer to a struct of type \nGetEEIArgStruct\n.\nAs before, you should always call \nInitGetEEIArgs\n \nto initialize this structure, then set whichever fields you \nneed to specify.\nIn this case, the only fields we need to set are \n\nSa,Sb\n (indices of the \nRWGSurface\n), \n\nnea,neb\n \n(indices of the interior edges in the \nEdges\n array \ncorresponding to the RWG basis functions), and \nk\n \n(wavenumber parameter in the Helmholtz kernel). \nThe result of this code snippet is\n\n\n \nb|G|b\n = -6.606176e-02 + 2.356554e-06i\n\n\n\n\nUsing equation (1a) above, we can understand this result in conjunction \nwith the results printed out above for \nG++\n and \n\nG+-\n. For this particular basis function, only two \nof the four panel-panel interactions on the RHS of equation (1a) \nhave distinct values (because the two panels that comprise the \nbasis function have the same shapes and areas, so we have\n\nG-+ = G+-\n and \nG-- = G++\n), and the\n\nedge-length prefactors \nl\nm\n, \nl\nn\n \nboth have value 0.1\n2. Thus for this case \nequation (1a) reads\n\n\n \nb\n0\n | \nG\n | \nb\n0\n \n\n=2\n0.02\n(\nG++ - G+-\n)\n\n\nand, indeed, plugging in the numbers printed out above, we find\n\n\n{6.6e-02, 2.4e-06i} \n= 2\n0.02\n( {-3.19,-7.95e-2i} - {-1.54,7.96e-2i} ).", 
            "title": "Data Structures"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#1-geometries-regions-surfaces", 
            "text": "The top-level data structure in  libscuff \nis a C++ class named  RWGGeometry.  The definition of this class is a \nlittle too big to present in full here (you can find it in the \nheader file  libscuff.h ), but we will point out its\nmost important data fields and class methods.  Geometries in  scuff-em  are represented\na collection of two or more contiguous \nthree-dimensional  regions  \nbounded by one or more two-dimensional  surfaces. \nMaterial properties (permittivity and permeability) are homogeneous \n(spatially constant) in each region and described by a single scuff-em  material description .  Each region is assigned an integer index starting from  0. \nThe  RWGGeometry  includes the following data fields for \nidentifying physical regions.  class RWGGeometry \n   { \n      ... \n      int NumRegions;\n      char **RegionLabels;\n      MatProp **RegionMPs;\n      ... \n   };   Here  RegionLabels[i]  is a string description for the  i th region in the problem, and  RegionMPs[i]  is\na pointer to an instance of  MatProp  describing its \nfrequency-dependent material properies. ( MatProp  is \na very simple class, implemented by the  libmatprop  submodule of  scuff-em , for\nhandling frequency-dependent material properties.)  RWGGeometry  always starts off with a single \nregion (region  0 ) with label  Exterior  \nand the material properties of vacuum. \nEach  REGION  statement in the .scuffgeo  file \nthen creates a new region, starting with region  1. \n(This is true unless the label specified to the  REGION \nkeyword is  Exterior,  in which case the \nstatement just redefines the material properties of region  0 .)\nEach  OBJECT...ENDOBJECT  section in the  .scuffgeo \nfile also creates a single new region (for the interior of the object).  Regions in a geometry are separated from one another by surfaces.\nEach surface is described by a C++ class named  RWGSurface. \nThe  RWGGeometry  class maintains an internal array of  RWGSurfaces:  class RWGGeometry \n   { \n      ... \n      int NumSurfaces;\n      RWGSurface **Surfaces;\n      ... \n   };   Each  OBJECT...ENDOBJECT  or  SURFACE...ENDSURFACE \nsection in the  .scuffgeo  file adds a new  RWGSurface \nstructure to the geometry. (Note that, in  scuff-em  \nparlance, an \"object\" is just a special case of a surface in which the \nsurface is  closed. )   The  RWGSurface  class is again slightly\ntoo complicated to list in full here, but we will discuss its most salient \nfields and methods. Among these are the  RegionIndices  field:   class RWGSurface\n   { \n      ... \n      int RegionIndices[2];\n      ... \n   };   These two integers are the indices of the regions on the two sides of the \nsurface. The  first  region ( RegionIndex[0] ) is \nthe  positive  region for the surface; this means that the electric\nand magnetic surface currents on the surface contribute to the fields \nin that region with a positive sign. The second region \n( RegionIndex[1] ) is the  negative  region; currents \non the surface contribute to the fields in that region with a negative\nsign.  Another way to think of this is that the surface normal vector  n  points  away from   RegionIndex[1]  \nand  into   RegionIndex[0] .", 
            "title": "1. Geometries, Regions, Surfaces"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#2-panels-edges-vertices", 
            "text": "The mesh describing each surface in a geometry is structure is analyzed \ninto lists of  vertices , triangular  panels,  and panel  edges.  Several internal data fields in the  RWGSurface \nclass are devoted to storing this information.   class RWGSurface\n{ \n  ... \n  int NumVertices;\n  double *Vertices;\n\n  int NumPanels;\n  RWGPanel **Panels;\n\n  int NumEdges;            \n  RWGEdge **Edges;\n  ... \n\n};  Here  Vertices  is an array of  3*NumVertices   double  values in which the cartesian coordinates of each \nvertex are stored one after another. Thus, the  x, y, z  \ncoordinates of the  nv th vertex are  Vertices[3*nv+0], Vertices[3*nv+1], Vertices[3*nv+2].  Panels  and  Edges  are arrays of pointers\nto specialized data structures for storing geometric data.", 
            "title": "2. Panels, Edges, Vertices"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#the-rwgpanel-and-rwgedge-structures", 
            "text": "The elemental data structure in the  scuff-em \ngeometry hierarchy is  RWGPanel . Each instance of this structure\ndescribes a single triangular panel in the mesh discretization of an  RWGSurface.    RWGPanel  definition   typedef struct RWGPanel\n { \n   int VI[3];            /* indices of vertices in Vertices array */\n   int EI[3];            /* indices of edges in Edges array */\n\n   double Centroid[3];   /* panel centroid */\n   double ZHat[3];       /* normal vector */\n   double Radius;        /* radius of enclosing sphere */\n   double Area;          /* panel area */\n\n   int Index;            /* index of this panel within RWGSurface */\n\n } RWGPanel;  Here the elements of the  VI  array are the indices of the \nthree panel vertices within the list of vertices for the given  RWGSurface.  The  Index  field in  RWGPanel \nindicates that panel's index within the  Panels  array \nof the parent  RWGSurface.  The remaining fields tabulate some useful\ngeometric data on the panel.  In addition to an  RWGPanel  structure for each triangle \nin the surface mesh, we also create an  RWGEdge  structure\nfor each panel  edge.    RWGEdge  definition   typedef struct RWGEdge \n { \n   int iV1, iV2, iQP, iQM;  /* indices of panel vertices (iV1 lt;iV2) */\n   double Centroid[3];      /* edge centroid */\n   double Length;           /* length of edge */\n   double Radius;           /* radius of enclosing sphere */\n\n   int iPPanel;             /* index of PPanel within RWGSurface (0..NumPanels-1)*/\n   int iMPanel;             /* index of MPanel within RWGSurface (0..NumPanels-1)*/\n   int PIndex;              /* index of this edge within PPanel (0..2)*/\n   int MIndex;              /* index of this edge within MPanel (0..2)*/\n   int Index;               /* index of this edge within RWGSurface (0..NumEdges-1)*/\n\n   RWGEdge *Next;           /* pointer to next edge in linked list */\n\n } RWGEdge;  The  iQP, iV1, iV2, iQM  fields here are indices into the \nlist of vertices for the parent  RWGSurface.   iV1  and  iV2  are the actual endpoints of the edge. iQP  and  iQM  denote respectively the current source  and  sink  vertices for the RWG basis function corresponding\nto this edge.  iPPanel  and  iMPanel  are the indices (into the  Panels  array of the parent  RWGSurface ) of the  positive  and  negative  panels associated with the edge.\n(The positive panel is the one from which the RWG current emanates; \nits vertices are  iQP, iV1, iV2. \nThe negative panel is the one into which the RWG current is sunk;\nits vertices are  iQM, iV1, iV2. ) \nThe  iPPanel  and  iMPanel  fields take values\nbetween  0  and  NumPanels-1 , where  NumPanels  is defined in the parent  RWGSurface.  PIndex  and  MIndex  are the indices of the edge \nwithin the positive and negative  RWGPanel s.\n(The index of an  edge  within a panel is defined as the index \nwithin the panel of the panel  vertex  opposite that edge; the \nindex of a vertex is its position in the  VI  array in the  RWGPanel  structure.)  The  Index  field of  RWGEdge  is the index of \nthe structure within the  Edges  array of the parent  RWGSurface.  The remaining fields store some geometric data on the edge.\nThe  Centroid  field stores the cartesian coordinates\nof the midpoint of the line segment between vertices  V1 \nand  V2 .  Here's an example of two panels (panel indices  17  and  39 ) in a surface mesh, and a single \nedge (edge index  24 ) shared between them. \nPanel  17  is the positive panel for the edge, \nwhile panel  39  is the negative panel for the edge; the corresponding\ndirection of current flow is indicated by the arrows.\nThe larger red numbers near the vertices are the indices of those\nvertices in the  Vertices  array. \nThe smaller magenta and cyan numbers are the indices of the vertices \nwithin the  VI  arrays in the two  RWGPanels .\n(The other four edges of this panel pair would also have corresponding  RWGEdge  structures; these are not shown in the figure.)", 
            "title": "The RWGPanel and RWGEdge structures"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#3-assembling-the-bem-matrix", 
            "text": "The  RWGGeometry  class contains a hierarchy of \nroutines for assembling the BEM matrix. If you are simply\nusing the code to solve scattering problems, you will\nonly ever need to call the top-level routine  AssembleBEMMatrix  or perhaps the \nsecond-highest-level routine,  AssembleBEMMatrixBlock. \nHowever, developers of surface-integral-equation methods \nmay wish to access the lower-level routines for \ncomputing the interactions of individual RWG basis functions\nor for computing certain integrals over triangular regions.  AssembleBEMMatrix  The top-level matrix assembly routine is  AssembleBEMMatrix.  This routine loops over \nall unique pairs of  RWGSurfaces  in the geometry. \nFor each unique pair \nof surfaces, the routine calls  AssembleBEMMatrixBlock  \nto assemble the subblock of the BEM matrix corresponding to a single \npair of  RWGSurfaces,  then stamps this subblock \ninto the appropriate place in the overall BEM matrix.   For example, if a geometry contains three  RWGSurfaces ,\nthen its overall BEM matrix has the block structure   where the  \\mathbf{M}__{ij}  subblock describes the\ninteractions of surfaces  i  and  j .\nIn this case  AssembleBEMMatrix  proceeds by making 6 calls\nto  AssembleBEMMatrixBlock , one for each of the \ndiagonal and above-diagonal blocks. (The below-diagonal\nblocks are related to their above-diagonal counterparts by \nsymmetry.)  AssembleBEMMatrixBlock  AssembleBEMMatrixBlock  computes the subblock of the \nBEM matrix corresponding to a single pair of  RWGSurface s.\nFor compact (non-periodic) geometries, this amounts to making just\na single call to  SurfaceSurfaceInteractions . For \nperiodic geometries, this involves making multiple calls to  SurfaceSurfaceInteractions  in which one of the two \nsurfaces is displaced through various lattice vectors  L  to account\nfor the contribution of periodic images.   The contribution of the \nmatrix subblock computed by  SurfaceSurfaceInteractions \nwith displacement vector  L  is weighted in the overall\nBEM matrix by a Bloch phase factor   e^{i\\mathbf{k}\\cdot \\mathbf{L}} \nwhere  k  is the Bloch wavevector, i.e. we have    where the  L  superscript indicates that the corresponding\nmatrix subblock is to be computed with one of the two surfaces \ndisplaced through translation vector  L .  SurfaceSurfaceInteractions  SurfaceSurfaceInteractions  loops over all  RWGEdge \nstructures on each of the two surfaces it is considering.\nFor each pair of edges, it calls  EdgeEdgeInteractions \nto compute the inner products of the RWG basis functions\nwith the  G  and  C  dyadic Green's functions\nfor each of the material regions through which the two surfaces\ninteract. (Surfaces may interact through 0, 1, or 2 material \nregions.)\nThen it stamps these values into their appropriate places\nin the BEM matrix subblock.   For example, if we have surfaces  S  and  S  that \ninteract through a single dielectric medium, the structure of \nthe corresponding matrix subblock is   where e.g.  b m  is the  m th basis function on surface  S . \nThe kernels\nhere are scalar multiples of the  G  and  C \ndyadics:   where  k ,  Z  are the wavenumber and (absolute)\nwave impedance of the dielectric medium at the frequency\nin question.  The matrix structure above is for the case of two surfaces\ninteracting through a single material region (for example, S  and  S \nmight be the outer surfaces of two compact objects embedded \nin vacuum or in a homogeneous medium, in which case the \nsurfaces interact only throught that medium).\nIf the surfaces interact through  two  material regions\n(for example, if we have  S = S \nand we are computing the self-interaction of the outer\nsurface of a dielectric object embedded in vacuum) then\neach matrix entry is actually a sum of  two  \ninner products, one involving the   kernels for \nthe interior medium and one involving the kernels for \nthe exterior. (If the surfaces are PEC, then the dimension\nof the matrix is halved with only the  EE  terms\nretained.)  EdgeEdgeInteractions  EdgeEdgeInteractions  considers a pair of RWG basis\nfunctions and computes the inner products of these basis functions\nwith the  G  and  C  dyadic Green's functions for a \nsingle material medium. Because each basis function is supported\non two triangles, the full inner products involve sums of four\ntriangle-pair contributions:   Here  l m ,l n  are the lengths of the\ninterior edges to which the RWG basis functions are associated, and\neach of the four terms in the sum is a four-dimensional integral \nover a single pair of panels, computed by  PanelPanelInteractions.  PanelPanelInteractions  PanelPanelInteractions  is the lowest-level routine in the  scuff-em  BEM matrix assembly hierarchy.\nThis routine computes the individual terms in equation (1) above,\ni.e. the contributions of a single pair of panels\nto the inner products of two RWG basis functions with the  G  and  C  dyadic Green's functions:   Note that the RWG basis-function prefactor  l/2A  is broken\nup into two factors between equations (1) and (2): the  1/2A \npart is included in the panel-panel integrals (2), while \nthe  l  part is included when summing the four panel-panel\ncontributions in equation (1) to obtain the overall inner product.   If the panels are far away from each other,  PanelPanelInteractions  \nuses low-order four-dimensional numerical cubature to compute the full\ninteractions. Otherwise,  PanelPanelInteractions  uses\nlow-order four-dimensional numerical cubature to compute the interactions\nwith  singularity-subtracted versions  of the  G  and  C  \nkernels, then adds the contributions of the singular terms after \nlooking them up in an internally-stored cache.", 
            "title": "3. Assembling the BEM Matrix"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#4-an-explicit-low-level-example", 
            "text": "Here's a worked example of a matrix-element computation in a  scuff-em  run.   The geometry and the labeling of panels, edges, and vertices  We'll consider a\nscattering geometry consisting of a single cube of dielectric\nmaterial, with side length  L= 1  m, discretized into \ntriangles with minor side length  L/10 , yielding a total\nof 1200 triangles, 1800 interior edges, and 3600 RWG basis \nfunctions (1800 each for electric and magnetic currents) \nfor a dielectric geometry. The  gmsh  geometry file for this example is  Cube_N.geo ,\nthe  gmsh  mesh file produced by running gmsh -2 Cube_N.geo  is Cube_10.msh ,\nand a  scuff-em  geometry file describing\na geometry consisting of this discretized cube with interior dielectric\npermittivity  =4 is DielectricCube.scuffgeo .   For low-level work it is convenient to have data on the internal \nindices that  scuff-em  assigns to \npanels, vertices, and edges when it reads in a geometry file.\nWe get this by running  scuff-analyze  on the mesh file\nin question with the  --WriteGMSHLabels  options:   % scuff-analyze --mesh Cube_10.msh --WriteGMSHFiles --WriteGMSHLabels  This produces a file named  Cube_10.pp , which we open in  gmsh  to produce a graphical depiction of \nthe labeling of panels, edges, and vertices. Zooming in on the region\nnear the origin, we will focus on the two panels lying closest to the \norigin in the  xy  plane; we see that  scuff-em  has assigned these two panels\npanel indices  0  and  1 , respectively, while\nthe edge they share has been assigned interior-edge index  0 .", 
            "title": "4. An Explicit Low-Level Example"
        }, 
        {
            "location": "/forDevelopers/DataStructures/#rwg-basis-function-b0", 
            "text": "Here's a schematic depiction of the panels that comprise the\nbasis function  b 0  associated with interior edge 0 :   In this diagram, the edge length is  L =0.1,  O  denotes \nthe origin of coordinates, and the vertices marked  Q  are the\nsource and sink vertices for the current distribution. \nThe RWG basis function  b 0  associated with \ninterior edge 0 is    where the RWG basis function edge length is  l = 2 L \nand the panel areas are  A 0 =A 1 = L 2 /2.\nNote that  P 0  and P 1  are respectively the positive and negative\npanels associated with basis function  b 0 .  Panel-panel interactions  Here's a  C++  code snippet that computes the \nquantities  G 00 ++  \nand  G 00 +-  in equation (1a)\nabove, i.e. the contributions of the positive-positive \nand positive-negative panel pairs to the inner product of  b 0  with itself through the  G  kernel,\nwith the wavenumber set to  k= 1.0;\nJust to be totally explicit, the numbers that are being \ncomputed here are   \n // read in geometry from .scuffgeo file\n RWGGeometry *G = new RWGGeometry( DielectricCube.scuffgeo );\n RWGSurface *S = G- Surfaces[0];\n\n // initialize an argument structure for GetPanelPanelInteractions\n GetPPIArgStruct MyPPIArgs, *PPIArgs= MyPPIArgs;\n InitGetPPIArgs(PPIArgs);\n PPIArgs- Sa = PPIArgs- Sb = S;\n PPIArgs- k = 1.0;\n\n // fill in arguments to compute the positive-positive panel pair\n PPIArgs- npa = 0;\n PPIArgs- iQa = 1;\n PPIArgs- npb = 0;\n PPIArgs- iQb = 1;\n GetPanelPanelInteractions(PPIArgs);\n printf( G++ = %e + %ei\\n ,real(PPIArgs- H[0]),imag(PPIArgs- H[0]));\n\n // fill in arguments to compute the positive-negative panel pair\n PPIArgs- npa = 0;\n PPIArgs- iQa = 1;\n PPIArgs- npb = 1;\n PPIArgs- iQb = 2;\n GetPanelPanelInteractions(PPIArgs);\n printf( G++ = %e + %ei\\n ,real(PPIArgs- H[0]),imag(PPIArgs- H[0]));  This code produces the following output:  G++ = -3.189105e+00 + -7.950381e-02i\nG+- = -1.537561e+00 + -7.956272e-02i  Notice that, to compute a panel-panel interaction, you allocate\nand initialize an instance of a data structure called  GetPPIArgs . This structure contains a large \nnumber of fields which in many cases can be set to default \nvalues; to ensure that these fields are properly initialized,\nalways call  InitGetPPIArgs()  on an newly-allocated\ninstance of  GetPPIArgs .  Then, you fill in the appropriate fields of this structure \nto specify the two panels over which you want to integrate.\nSpecifically, the fields  Sa ,  npa \nspecify the first panel (the  npa th  RWGPanel \nin the  Panels  array for surface  Sa ), \nwhile the field  iQa  (an integer in the range  0..2 )\nidentifies the index of the  Q  vertex (RWG current source/sink\nvertex) within the three vertices of the panel. \nThe fields  Sb ,  npb , and  iQb \nsimilarly identify the second panel and source/sink vertex.\nInitialize the  k  field in the  GetPPIArgs  structure to the wavenumber parameter\nin the Helmholtz kernel. ( k  may be complex or purely imaginary.)  Edge-panel interactions  Here's a  C++  code snippet that computes the \nfull basis-function inner product   b 0  |  G  |  b 0   \nin equation (1a) above.   GetEEIArgStruct MyEEIArgs, *EEIArgs= MyEEIArgs;\n InitGetEEIArgs(EEIArgs);\n EEIArgs- Sa = EEIArgs- Sb = S;\n EEIArgs- nea = EEIArgs- neb = 0;\n EEIArgs- k = 1.0;\n GetEdgeEdgeInteractions(EEIArgs);\n printf( lt;b|G|b gt; = %e + %ei\\n ,real(EEIArgs- GC[0]),imag(EEIArgs- GC[0]));  Note that, similar to the case of  GetPanelPanelInteractions \ndiscussed above, the call to  GetEdgeEdgeInteractions  takes as\nargument a pointer to a struct of type  GetEEIArgStruct .\nAs before, you should always call  InitGetEEIArgs  \nto initialize this structure, then set whichever fields you \nneed to specify.\nIn this case, the only fields we need to set are  Sa,Sb  (indices of the  RWGSurface ),  nea,neb  \n(indices of the interior edges in the  Edges  array \ncorresponding to the RWG basis functions), and  k  \n(wavenumber parameter in the Helmholtz kernel). \nThe result of this code snippet is    b|G|b  = -6.606176e-02 + 2.356554e-06i  Using equation (1a) above, we can understand this result in conjunction \nwith the results printed out above for  G++  and  G+- . For this particular basis function, only two \nof the four panel-panel interactions on the RHS of equation (1a) \nhave distinct values (because the two panels that comprise the \nbasis function have the same shapes and areas, so we have G-+ = G+-  and  G-- = G++ ), and the \nedge-length prefactors  l m ,  l n  \nboth have value 0.1 2. Thus for this case \nequation (1a) reads    b 0  |  G  |  b 0   \n=2 0.02 ( G++ - G+- )  and, indeed, plugging in the numbers printed out above, we find  {6.6e-02, 2.4e-06i} \n= 2 0.02 ( {-3.19,-7.95e-2i} - {-1.54,7.96e-2i} ).", 
            "title": "RWG basis function b0"
        }, 
        {
            "location": "/forDevelopers/Documentation/", 
            "text": "The \nscuff-em\n documentation system\n\n\nThe documentation for \nscuff-em\n is maintained in the form\nof plain-text (markdown) files stored in the \ndoc\n subdirectory\nof the \nscuff-em\n repository. These files are processed by\nthe wonderful open-source \nMkDocs\n system\nto build the web-based documentation hierarchy.\n\n\nA major reason for this choice of documentation system is to\nmake it easy for \nscuff-em\n users to edit the existing \ndocumentation and to contribute new documentation. If you \ndiscover incorrect or incomplete portions of the documentation,\nor if you would like to add new documentation, please consider\ncontributing to \nscuff-em\n by making the relevant changes\nin the \ndoc\n subdirectory of your \nscuff-em\n repository,\nthen \nsubmitting a pull request on GitHub.\n\n\nBuilding and serving your own local copy of the documentation\n\n\nIt's easy to build your own local copy of the entire \nscuff-em\n\ndocumentation hierarchy, which you can then view offline.\nThis allows you to access the documentation without Internet \naccess, and also to preview any changes you might make to\nthe documentation before submitting them in the form of a pull\nrequest.\n\n\nOne-time only setup operations\n\n\nTo build the \nscuff-em\n documentation, you will need a \npython\n\ninstallation on your system, and you will need the \nmkdocs\n and \n\npython-markdown-math\n packages. On my system I was able to \ninstall these using the following commands:\n\n\n% sudo pip install mkdocs\n% sudo pip install --upgrade pyinotify\n% git clone https://github.com/mitya57/python-markdown-math.git\n% cd python-markdown-math \n% python setup.py build\n% sudo python setup.py install\n\n\n\n\nBuilding the documentation\n\n\nTo build the documentation, starting from the top-level\ndirectory of your \nscuff-em\n repository, simply say\n\n\n% cd doc\n% mkdocs build\n\n\n\n\nThis will create the HTML hierarchy in the subdirectory\n\ndoc/site.\n\n\nServing the documentation\n\n\nA wonderfully convenient feature provided by MkDocs is the\nability to serve your local version of the documentation \nlocally to a web browser running on your machine, without\nhaving to mess around with configuring apache or any other\nwebserver software. To do this, starting from the \ndoc\n \nsubdirectory of the \nscuff-em\n repository you simply go\nlike this:\n\n\n% cd doc\n% mkdocs serve\n\n\n\n\nThen direct your favorite web browser to the site\n\n127.0.0.1:8000\n, i.e.\n\n\n% google-chrome 127.0.0.1:8000\n\n\n\n\nThis should pull up the top-level page of the \nscuff-em\n\ndocumentation tree, with internal links pointing to \nyour local copies of the various pages.\n\n\nThe great thing about this is that, whenever you save changes \nto a file in the \ndoc\n subdirectory of your \nscuff-em\n \nrepository, the documentation is automatically rebuilt and\nthe webserver automatically refreshed. This allows you to\nedit the \nscuff-em\n documentation in WYSIWIG fashion, \nsimply by working on an \n.md\n file in a text editor in one window,\nwhile having a web browser open to the corresponding subpage\nof \n127.0.0.1:8000\n in another window. Then, every time\nyou save changes to the text file, the web page is automatically\nupdated! I love this brilliant system.", 
            "title": "Documentation"
        }, 
        {
            "location": "/forDevelopers/Documentation/#building-and-serving-your-own-local-copy-of-the-documentation", 
            "text": "It's easy to build your own local copy of the entire  scuff-em \ndocumentation hierarchy, which you can then view offline.\nThis allows you to access the documentation without Internet \naccess, and also to preview any changes you might make to\nthe documentation before submitting them in the form of a pull\nrequest.  One-time only setup operations  To build the  scuff-em  documentation, you will need a  python \ninstallation on your system, and you will need the  mkdocs  and  python-markdown-math  packages. On my system I was able to \ninstall these using the following commands:  % sudo pip install mkdocs\n% sudo pip install --upgrade pyinotify\n% git clone https://github.com/mitya57/python-markdown-math.git\n% cd python-markdown-math \n% python setup.py build\n% sudo python setup.py install  Building the documentation  To build the documentation, starting from the top-level\ndirectory of your  scuff-em  repository, simply say  % cd doc\n% mkdocs build  This will create the HTML hierarchy in the subdirectory doc/site.  Serving the documentation  A wonderfully convenient feature provided by MkDocs is the\nability to serve your local version of the documentation \nlocally to a web browser running on your machine, without\nhaving to mess around with configuring apache or any other\nwebserver software. To do this, starting from the  doc  \nsubdirectory of the  scuff-em  repository you simply go\nlike this:  % cd doc\n% mkdocs serve  Then direct your favorite web browser to the site 127.0.0.1:8000 , i.e.  % google-chrome 127.0.0.1:8000  This should pull up the top-level page of the  scuff-em \ndocumentation tree, with internal links pointing to \nyour local copies of the various pages.  The great thing about this is that, whenever you save changes \nto a file in the  doc  subdirectory of your  scuff-em  \nrepository, the documentation is automatically rebuilt and\nthe webserver automatically refreshed. This allows you to\nedit the  scuff-em  documentation in WYSIWIG fashion, \nsimply by working on an  .md  file in a text editor in one window,\nwhile having a web browser open to the corresponding subpage\nof  127.0.0.1:8000  in another window. Then, every time\nyou save changes to the text file, the web page is automatically\nupdated! I love this brilliant system.", 
            "title": "Building and serving your own local copy of the documentation"
        }
    ]
}