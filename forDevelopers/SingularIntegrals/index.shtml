<!--#set 


    var="title"
    value="scuff-EM code for computing singular integrals"
  -->
<!--#include virtual="/pagetop.shtml"-->

<!-- begin main page body -->

<!---------------------------------------------------------------------->
<!-- main page table, with one row and three columns:                 -->
<!--  navbar, trough, body.                                           -->
<!---------------------------------------------------------------------->
<table cellspacing="0" cellpadding="0" width="100%"><tr>
  
  <!---------------------------------------------------------------------->
  <!-- left column of main page table: nav bar. -------------------------->
  <!---------------------------------------------------------------------->
  <td valign="top" width="180"> 
  <!--#include virtual="/research/navbar.shtml"-->
  </td> 

  <!---------------------------------------------------------------------->
  <!-- central column of main page table: separation trough -------------->
  <!---------------------------------------------------------------------->
  <td width="5%"></td>
 
  <!---------------------------------------------------------------------->
  <!-- right column of main page table: content of page.------------------>
  <!---------------------------------------------------------------------->
  <td valign="top">
    
   <p><br> <p align="center">
   <table align="center"> 
     <tr> <td> <a href="scuff-em">
               <img width="411" height="296" src="images/scuffEM.png">
               </a>
          </td> 
          <td width="5%"> </td>
          <td> <h1>
               Computation of Singular Integrals in <span class=CodeName>scuff-em</span>
               </h1>
          </td>
     </tr>
   </table> 
    
    <!---------------------------------------------------------------------->
    <!-- big table encompassing the entire page ---------------------------->
    <!---------------------------------------------------------------------->
    <table align="center" width="90%"><tr><td>
   
    <p>
    <br>

    <p>
    A key feature of <span class=CodeName>scuff-em</span> is an accurate and 
    efficient code for computing singular four-dimensional integrals over pairs 
    of triangles.
    The algorithm that <span class=CodeName>scuff-em</span>
    uses for this purpose---which I call the ``generalized Taylor-Duffy method''
    in honor of the progenitors of some earlier methods that inspired it---is
    discussed in detail in
    <a href="http://arxiv.org/abs/1312.1703">this paper.</a>

    <p> 
    The code that evaluates singular integrals is of course bundled 
    together with the full <span class=CodeName>scuff-em</span> distribution
    (available for download 
    <a href="scuff-em/reference/scuffEMInstallation.shtml">here</a>),
    but I am also providing it separately on this page in the form of a
    smaller, self-contained standalone package for use by developers who 
    may wish to incorporate the algorithm into their own codes.

    <p> 
    The primary code is contained in a single <code>C++</code> file named 
    <code>TaylorDuffy.cc</code> (around 1,500 lines); the package below
    also includes, as a utility function, the <code>pcubature</code>
    code from 
    <a href="http://ab-initio.mit.edu/wiki/index.php/Cubature">
    Steven G. Johnson's numerical cubature package.
    </a>

    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <p width="75%">
    <table class="TOC" cellpadding="5" cellspacing="5">

      <tr> <th> Table Of Contents </th></tr>

      <tr> <td>
           <a href="scuff-em/SingularIntegrals.shtml#WhatItComputes">
            1. What the code actually computes
            </a>
           </td>
      </tr>

      <tr> <td>
           <a href="scuff-em/SingularIntegrals.shtml#Download">
            2. Downloading and compiling the code
            </a>
           </td>
      </tr>

      <tr> <td> 
            <a href="scuff-em/SingularIntegrals.shtml#CallingConvention">
            3. <code>C++</code> calling convention
            </a>
           </td>
      </tr>

      <tr> <td> 
            <a href="scuff-em/SingularIntegrals.shtml#C++Examples">
            4. <code>C++</code> Examples
            </a>
           </td>
      </tr>

    </table>

    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <p>
    <h2><a name="WhatItComputes"></a> 
    1. What the code actually computes
    </h2>
    <hr>

    <p>
    The code provides a <code>C++</code> function named <code>TaylorDuffy</code>
    which computes the following four-dimensional integral over a triangle-product
    domain:

    <p align="center">
    <img src="scuff-em/SingularIntegrals/TDIntegral.png">

    <p>
    In this expression,

    <p>
    <ul>
     <li> <p> 
          <i>T</i> and <i>T'</i> are triangles with at least one common vertex.
          (You supply to <code>TaylorDuffy</code> the cartesian coordinates
           of the triangle vertices.)
     
     <li> <p> 
          <i>P</i> is a polynomial function of 6 variables (the Cartesian
           components of <b>x,x'</b>). Although the underlying algorithm works 
           for arbitrary polynomials <i>P</i>, in the implementation of 
           <code>TaylorDuffy</code> provided below you will select one of 
           a predetermined set of possible polynomials (see below).
           (Modifying the code to support other polynomials would be 
            a relatively straightforward, if tedious, task.)

     <li> <i>K</i> is a <i>kernel</i> function of a single scalar variable
          <i>r.</i> Although the algorithm works for a fairly wide family of 
          kernel functions, in the implementation of <code>TaylorDuffy</code>
          provided below you will select one of a predetermined set of 
          possible kernels (see below). Again, it should be relatively 
          straightforward to modify the code to support other kernels.
    </ul>

    <p>
     Actually, it is slightly more accurate to say that <code>TaylorDuffy</code> 
     computes <i>multiple</i> simultaneous integrals of the form (1);
     in a single call to <code>TaylorDuffy</code> you can specify, for 
     the same triangle pair <i>T,T'</i>, more than one 
     (polynomial, kernel) pair, i.e. <i>{P<sub>n</sub>, K<sub>n</sub>}</i> 
     for <i>n=1,2,...,N</i>, and 
     <code>TaylorDuffy</code> will compute all <i>N</i> integrals at once.
     This is faster than making <i>N</i> separate calls due to the 
     reuse of computational overhead.

    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <p>
    <h2><a name="Download"></a> 
    2. Downloading and compiling the code
    </h2>
    <hr>

    <p>
    Download the tarball: 
    <a href="scuff-em/SingularIntegrals/scuff-singular-integrals.tar.gz">
    scuff-singular-integrals.tar.gz</a>.
  
    <p>
    Now unpack and compile the test program as follows:

    <p>
    <pre class="listing">
 % gunzip -c scuff-singular-integrals.tar.gz | tar xvf -
 % cd scuff-singular-integrals
 % make 
    </pre>

    <p> This should build a small executable test program
        called <code>scuff-test-SIs,</code> which you can 
        run with no command-line options to execute the 
        test example discussed below:

    <p>
    <pre class="listing">
 % scuff-test-SIs 
    </pre

    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <p>
    <h2><a name="CallingConvention"></a> 
    3. <code>C++</code> calling convention
    </h2>
    <hr>

    <p>
    The <code>TaylorDuffy</code> routine has many input
    arguments (many of which may be set to default values)
    and multiple output values. For this reason, instead
    of the typical calling convention in which you specify
    multiple input arguments to a <code>C++</code> function
    and get back a single output value,
    <code>TaylorDuffy</code> accepts as its argument a
    (pointer to a) single big argument <i>structure</i>.

    <p>
    Thus, within a <code>C/C++</code> program, 
    to evaluate one or more integrals of the form (1) for a given
    pair of triangles you will 
    <b>(1)</b> instantiate and initialize a data structure
               of type <code>TaylorDuffyArgStruct</code>,
               which stores all input and output arguments, 
    and then 
    <b>(2)</b> simply call <code>TaylorDuffy()</code>
               with a pointer to your argument structure
               as the only parameter. On return, the 
               results (the values of the integral) 
               will be stored in the argument structure.

    <p>
    The process looks something like this: 

    <p>
    <pre class="listing">
 // instantiate and initialize argument structure 
 TaylorDuffyArgStruct MyTDArgs, *TDArgs=&MyTDArgs;
 InitTaylorDuffyArgs(TDArgs);                       // always call this!

 // fill in necessary fields 
 TDArgs->WhichCase = TD_COMMONVERTEX
 TDArgs->NumPKs    = 1; 
 ...

 // evaluate the integral
 TaylorDuffy(TDArgs);

 // results are now available inside TDArgs
 printf("Result: %e \n", real(TDArgs->Result[0]) );
    </pre>

    <h3>Thread Safety</h3>

    <p><code>TaylorDuffy()</code> is thread-safe; you may call it 
       from multiple simultaneously-executing threads without fear
       of crosstalk or race conditions. (Indeed, 
       <span class=CodeName>scuff-em</span> does just this if compiled
       with support for <span class=CodeName>openmp</span>
       or <span class=CodeName>pthreads</span>.)

    <!---------------------------------------------------------------------->
    <!---------------------------------------------------------------------->
    <!---------------------------------------------------------------------->
    <p>
    <h3> Fields in <code>TaylorDuffyArgStruct</code> </h3>

    <p>
    The table below details all fields in the argument structure
    passed to <code>TaylorDuffy.</code>

    <p>
    In general, you should always call <code>InitTaylorDuffyArgs</code>
    first to set all optional fields to default values, then fill in 
    your desired values for mandatory fields (and overwrite the default
    values for any optional fields you wish to tweak).

    <p>
    <table border="1" cellpadding="5" cellspacing="5">

    <!----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->
    <tr>
      <th> Field </th>
      <th> Description </th>
    </tr>

    <!----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->
    <tr> 
       <th colspan=2 height="100"> 
           <i>Mandatory input fields describing the triangles</i>
       </th> 
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <pre>int WhichCase; </td>
      <td> Counts the number of common vertices between the 
           two triangles. You should set this to 1, 2, or 3 
           for the common-vertex, common-edge, or common-triangle
           cases. (The file <code>TaylorDuffy.h</code> defines
           the constants 
           <code>TD_COMMONVERTEX=1</code>,
           <code>TD_COMMONEDGE=2</code>,
           <code>TD_COMMONTRIANGLE=3</code>).
      </td>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <table>
            <tr><td><code>double *V1, *V2, *V3;</code></td></tr>
            <tr><td><code>double *V2P, *V3P;</code></td></tr>
           </table>
      </td>
      <td> Pointers to caller-allocated arrays of length 3 
           containing the <i>x,y,z</i> coordinates of the 
           triangle vertices.
           <p>
           <code>V1, V2, V3</code> are the vertices of triangle 
           <i>T</i>. For example, <code>V2[0,1,2]</code>
           are the <code>x,y,z</code> coordinates of the 
           second vertex.
           <p>
           <code>V2P, V3P</code> are the vertices of triangle
           <i>T'</i> that are <i>not</i> shared with triangle 
           <i>T</i>. It is not always necessary to initialize 
           these fields. In particular,

           <p>
            <ul>
            <li> In the common-triangle case (<code>WhichCase=3</code>),
                 neither <code>V2P</code> nor <code>V3P</code>
                 is referenced.
            <li> In the common-edge case (<code>WhichCase=2</code>),
                 only <code>V3P</code> is referenced; <code>V2P</code>
                 is ignored.
            <li> In the common-vertex case (<code>WhichCase=1</code>),
                 both <code>V2P</code> and <code>V3P</code>
                 are referenced.
            </ul>

      </td>
    </tr>

    <!----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->
    <tr> 
       <th colspan=2 height="100"> 
           <i>Mandatory input fields describing the <b>P</b> 
              and <b>K</b> functions</i>
       </th>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <table>
            <tr><td><code>int NumPKs;</code></td></tr>
            <tr><td><code>int *PIndex;</code></td></tr>
            <tr><td><code>int *KIndex;</code></td></tr>
            <tr><td><code>int *KParam;</code></td></tr>
           </table>
      </td>
      <td> 
           <p>
           <code>NumPKs</code> specifies the number of 
           integrals of the form (1) you wish to compute 
           (that is, the number of pairings of a polynomial
           <i>P</i> with a kernel <i>K</i>) for the given
           pair of triangles.
           If you only need to compute a single integral,
           set <code>NumPKs=1.</code>

           <p>
           <code>PIndex</code> and <code>KIndex</code> 
           are pointers to caller-allocated arrays
           of length <code>NumPKs</code>. The <code>n</code>th
           entries in these arrays are the indices 
           (in the tables below) of the 
           <code>n</code>th <i>P</i> and <i>K</i>
           functions.

           <p>
           <code>KParam</code> is a pointer to a 
           caller-allocated array of length
           <code>NumPKs</code> containing values of 
           certain parameters that enter the kernel
           functions. The entries of this array are 
           interpreted in different ways depending on 
           the corresponding entries in the 
           <code>KIndex</code> array:

           <ul>
            <li> If <code>KIndex[n]==0</code> 
                 (the <i>r<sup>p</sup></i> kernel),
                 then <code>KParam[n]</code> is
                 interpreted as the parameter <i>p</i>,
                 i.e. the integer power to which <i>r</i>
                 is raised. (The <code>cdouble-</code>valued
                 quantity
                 <code>KParam[n]</code> is converted to
                 <code>int</code> inside <code>TaylorDuffy.</code>)
            <li> <p>If <code>KIndex[n]==1</code> or <code>2</code>
                 (the Helmholtz kernels), then 
                 <code>KParam[n]</code> is interpreted as 
                 the parameter <i>k</i>, i.e. the 
                 Helmholtz wavenumber. This quantity can
                 be purely real, purely imaginary, or complex.
           </ul>
      </td> 
    </tr>

    <!----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->
    <tr> 
       <th colspan=2 height="100"> 
           <i>Input fields that are required for certain 
              <b>P</b> functions</i>
       </th>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <code>double *Q, *QP;</code>
      </td>
      <td> Pointers to caller-allocated arrays of length 3 
           containing the <i>x,y,z</i> coordinates of the 
           RWG source/sink vertices <b>Q,Q'</b>. These are 
           only referenced if any entry in the <code>PIndex</code>
           array corresponds to one of the polynomials in the 
           table below whose definition involves <b>Q,Q'.</b>
      </td>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <code>double *nHat;</code>
      </td>
      <td> Pointers to caller-allocated arrays of length 3 
           containing the <i>x,y,z</i> components of the 
           unit normal vector <b>n</b>. This is only referenced
           if any entry in the <code>PIndex</code> array 
           corresponds to one of the polynomials in the 
           table below whose definition involves <b>n.</b>
      </td>
    </tr>

    <!----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->
    <tr> 
       <th colspan=2 height="100"> 
           <i>Optional input fields controlling integration behavior 
           </i>
       </th>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <code>double AbsTol, RelTol;</code>
      </td>
      <td> The absolute and relative error tolerances to which
           the adaptive integrator will attempt to compute 
           the integral. (The defaults are <code>AbsTol=0.0</code>
           and <code>RelTol=1.0e-10</code>.) 
      </td>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <code>int MaxEval;</code>
      </td>
      <td> An upper bound on the number of function samples
           the adaptive integrator may compute. (The default 
           is <code>MaxEval=1000.</code>) Reducing this 
           number will cause the code to run more quickly,
           possibly at the expense of lower accuracy.
      </td>
    </tr>

    <!----%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->
    <tr> 
       <th colspan=2 height="100"> 
           <i>Output fields 
           </i>
       </th>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <code>cdouble *Result, *Error;</code>
      </td>
      <td> Pointers to caller-allocated output buffers 
           with enough space to store <code>NumPKs</code> 
           values of type <code>cdouble</code>. On return,
           <code>Result[n]</code> is the value of the 
           integral for the <code>n</code>th <i>P,K</i> pairing,
           and <code>Error[n]</code> is an estimate of 
           the error incurred by the numerical quadrature.
      </td>
    </tr>

    <!---------------------------------------------------------->
    <tr>
      <td> <code>int nCalls;</code> 
      </td>
      <td> The number of function evaluations used to evaluate
           the numerical cubature.
           This number will not exceed <code>MaxEval.</code>
      </td>
    </tr>

    </table>

    <!---------------------------------------------------------------------->
    <!---------------------------------------------------------------------->
    <!---------------------------------------------------------------------->
    <p>
    <h3> Values of the <code>PIndex</code> field </h3>

    <p>
    The implementation of <code>TaylorDuffy</code> provided here
    contains support for the following choices of the <i>P</i>
    polynomial in equation (1). (The values of the <code>PIndex</code>
    field here are constants defined in <code>TaylorDuffy.h</code>.)

    <p align="center">
    <img src="scuff-em/SingularIntegrals/PIndexTable.png">

    <p>
    In this table, <i>A,A'</i> are the areas of triangles 
    <i>T,T'</i>, and 
    the quantities <b>Q, Q', n</b> are vector-valued
    parameters that you specify by setting fields in the argument
    structure for the <code>TaylorDuffy</code> routine (see above).
    Also, in the final three table entries, the tilde symbol above
    a vector-valued quantity indicates the result of crossing that 
    quantity with <b>n,</b> i.e.

    <p align="center">
    <img src="scuff-em/SingularIntegrals/TildedQuantities.png">

    <p> For RWG basis-function enthusiasts, note that the last 5 entries 
        in the table are appropriate for computing matrix elements of the 
        EFIE and MFIE operators between RWG basis functions, but observe
        carefully that the prefactor <i>1/(AA')</i> is only <i>part</i>
        of the full prefactor that arises for RWG basis functions; there 
        is also a factor <i>ll'</i> (product of edge lengths) 
        which is missing from these calculations, and you must put that 
        in yourself, by hand.

    <p>
    <h3> Values of the <code>KIndex</code> field </h3>

    The implementation of <code>TaylorDuffy</code> provided here
    contains support for the following choices of the <i>K</i>
    kernel in equation (1). (The values of the <code>KIndex</code>
    field here are constants defined in <code>TaylorDuffy.h</code>.)

    <p align="center">
    <img src="scuff-em/SingularIntegrals/KIndexTable.png">

    <p>
    In this table, the values of the parameters <i>p</i> and 
    <i>k</i> are what you put into the <code>KParam</code>
    array in the <code>TaylorDuffyArgStruct</code>. 

    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <!----------------------------------------------------------------------->
    <p>
    <h2><a name="C++Examples"></a> 
    4. Examples: Calling the code from <code>C++</code> programs
    </h2>
    <hr>

    <p>
    The downloadable tarball above includes a little test program
    that computes two singular integrals for a single pair of 
    panels that share a common edge. The full program looks like
    this:

    <p>
    <p align="center">
    <table border="1" cellpadding="5" cellspacing="5"><tr><td>
    <object data=scuff-em/SingularIntegrals/scuff-test-SIs.cc.html width="600" height="600"> 
    </td></tr></table>
 
    <!--#include virtual="/scuff-EM/scuffEMFooter.shtml"-->
    
    <!---------------------------------------------------------------------->
    <!-- end big table encompassing the entire page ------------------------>
    <!---------------------------------------------------------------------->
    </td>
    </table>

<!----------------------------------------------------------------------->
<!-- end main page table                                               -->
<!----------------------------------------------------------------------->
</tr></table>
   
<!----------------------------------------------------------------------->
<!-- end main page body ------------------------------------------------->
<!----------------------------------------------------------------------->
   
<!--#include virtual="/pageend.shtml"-->
